V// source: plugin/customControl/js/jquery.ui.sortable.js\u000a/*! jQuery UI - v1.11.4 - 2015-08-30\u000a* http://jqueryui.com\u000a* Includes: core.js, widget.js, mouse.js, draggable.js, droppable.js, sortable.js\u000a* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */\u000a\u000a(function( factory ) {\u000a	if ( typeof define === "function" && define.amd ) {\u000a\u000a		// AMD. Register as an anonymous module.\u000a		define([ "jquery" ], factory );\u000a	} else {\u000a\u000a		// Browser globals\u000a		factory( jQuery );\u000a	}\u000a}(function( $ ) {\u000a/*!\u000a * jQuery UI Core 1.11.4\u000a * http://jqueryui.com\u000a *\u000a * Copyright jQuery Foundation and other contributors\u000a * Released under the MIT license.\u000a * http://jquery.org/license\u000a *\u000a * http://api.jqueryui.com/category/ui-core/\u000a */\u000a\u000a\u000a// $.ui might exist from components with no dependencies, e.g., $.ui.position\u000a$.ui = $.ui || {};\u000a\u000a$.extend( $.ui, {\u000a	version: "1.11.4",\u000a\u000a	keyCode: {\u000a		BACKSPACE: 8,\u000a		COMMA: 188,\u000a		DELETE: 46,\u000a		DOWN: 40,\u000a		END: 35,\u000a		ENTER: 13,\u000a		ESCAPE: 27,\u000a		HOME: 36,\u000a		LEFT: 37,\u000a		PAGE_DOWN: 34,\u000a		PAGE_UP: 33,\u000a		PERIOD: 190,\u000a		RIGHT: 39,\u000a		SPACE: 32,\u000a		TAB: 9,\u000a		UP: 38\u000a	}\u000a});\u000a\u000a// plugins\u000a$.fn.extend({\u000a	scrollParent: function( includeHidden ) {\u000a		var position = this.css( "position" ),\u000a			excludeStaticParent = position === "absolute",\u000a			overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,\u000a			scrollParent = this.parents().filter( function() {\u000a				var parent = $( this );\u000a				if ( excludeStaticParent && parent.css( "position" ) === "static" ) {\u000a					return false;\u000a				}\u000a				return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );\u000a			}).eq( 0 );\u000a\u000a		return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;\u000a	},\u000a\u000a	uniqueId: (function() {\u000a		var uuid = 0;\u000a\u000a		return function() {\u000a			return this.each(function() {\u000a				if ( !this.id ) {\u000a					this.id = "ui-id-" + ( ++uuid );\u000a				}\u000a			});\u000a		};\u000a	})(),\u000a\u000a	removeUniqueId: function() {\u000a		return this.each(function() {\u000a			if ( /^ui-id-\u005cd+$/.test( this.id ) ) {\u000a				$( this ).removeAttr( "id" );\u000a			}\u000a		});\u000a	}\u000a});\u000a\u000a// selectors\u000afunction focusable( element, isTabIndexNotNaN ) {\u000a	var map, mapName, img,\u000a		nodeName = element.nodeName.toLowerCase();\u000a	if ( "area" === nodeName ) {\u000a		map = element.parentNode;\u000a		mapName = map.name;\u000a		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {\u000a			return false;\u000a		}\u000a		img = $( "img[usemap='#" + mapName + "']" )[ 0 ];\u000a		return !!img && visible( img );\u000a	}\u000a	return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?\u000a		!element.disabled :\u000a		"a" === nodeName ?\u000a			element.href || isTabIndexNotNaN :\u000a			isTabIndexNotNaN) &&\u000a		// the element and all of its ancestors must be visible\u000a		visible( element );\u000a}\u000a\u000afunction visible( element ) {\u000a	return $.expr.filters.visible( element ) &&\u000a		!$( element ).parents().addBack().filter(function() {\u000a			return $.css( this, "visibility" ) === "hidden";\u000a		}).length;\u000a}\u000a\u000a$.extend( $.expr[ ":" ], {\u000a	data: $.expr.createPseudo ?\u000a		$.expr.createPseudo(function( dataName ) {\u000a			return function( elem ) {\u000a				return !!$.data( elem, dataName );\u000a			};\u000a		}) :\u000a		// support: jQuery <1.8\u000a		function( elem, i, match ) {\u000a			return !!$.data( elem, match[ 3 ] );\u000a		},\u000a\u000a	focusable: function( element ) {\u000a		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );\u000a	},\u000a\u000a	tabbable: function( element ) {\u000a		var tabIndex = $.attr( element, "tabindex" ),\u000a			isTabIndexNaN = isNaN( tabIndex );\u000a		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\u000a	}\u000a});\u000a\u000a// support: jQuery <1.8\u000aif ( !$( "<a>" ).outerWidth( 1 ).jquery ) {\u000a	$.each( [ "Width", "Height" ], function( i, name ) {\u000a		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],\u000a			type = name.toLowerCase(),\u000a			orig = {\u000a				innerWidth: $.fn.innerWidth,\u000a				innerHeight: $.fn.innerHeight,\u000a				outerWidth: $.fn.outerWidth,\u000a				outerHeight: $.fn.outerHeight\u000a			};\u000a\u000a		function reduce( elem, size, border, margin ) {\u000a			$.each( side, function() {\u000a				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;\u000a				if ( border ) {\u000a					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;\u000a				}\u000a				if ( margin ) {\u000a					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;\u000a				}\u000a			});\u000a			return size;\u000a		}\u000a\u000a		$.fn[ "inner" + name ] = function( size ) {\u000a			if ( size === undefined ) {\u000a				return orig[ "inner" + name ].call( this );\u000a			}\u000a\u000a			return this.each(function() {\u000a				$( this ).css( type, reduce( this, size ) + "px" );\u000a			});\u000a		};\u000a\u000a		$.fn[ "outer" + name] = function( size, margin ) {\u000a			if ( typeof size !== "number" ) {\u000a				return orig[ "outer" + name ].call( this, size );\u000a			}\u000a\u000a			return this.each(function() {\u000a				$( this).css( type, reduce( this, size, true, margin ) + "px" );\u000a			});\u000a		};\u000a	});\u000a}\u000a\u000a// support: jQuery <1.8\u000aif ( !$.fn.addBack ) {\u000a	$.fn.addBack = function( selector ) {\u000a		return this.add( selector == null ?\u000a			this.prevObject : this.prevObject.filter( selector )\u000a		);\u000a	};\u000a}\u000a\u000a// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\u000aif ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {\u000a	$.fn.removeData = (function( removeData ) {\u000a		return function( key ) {\u000a			if ( arguments.length ) {\u000a				return removeData.call( this, $.camelCase( key ) );\u000a			} else {\u000a				return removeData.call( this );\u000a			}\u000a		};\u000a	})( $.fn.removeData );\u000a}\u000a\u000a// deprecated\u000a$.ui.ie = !!/msie [\u005cw.]+/.exec( navigator.userAgent.toLowerCase() );\u000a\u000a$.fn.extend({\u000a	focus: (function( orig ) {\u000a		return function( delay, fn ) {\u000a			return typeof delay === "number" ?\u000a				this.each(function() {\u000a					var elem = this;\u000a					setTimeout(function() {\u000a						$( elem ).focus();\u000a						if ( fn ) {\u000a							fn.call( elem );\u000a						}\u000a					}, delay );\u000a				}) :\u000a				orig.apply( this, arguments );\u000a		};\u000a	})( $.fn.focus ),\u000a\u000a	disableSelection: (function() {\u000a		var eventType = "onselectstart" in document.createElement( "div" ) ?\u000a			"selectstart" :\u000a			"mousedown";\u000a\u000a		return function() {\u000a			return this.bind( eventType + ".ui-disableSelection", function( event ) {\u000a				event.preventDefault();\u000a			});\u000a		};\u000a	})(),\u000a\u000a	enableSelection: function() {\u000a		return this.unbind( ".ui-disableSelection" );\u000a	},\u000a\u000a	zIndex: function( zIndex ) {\u000a		if ( zIndex !== undefined ) {\u000a			return this.css( "zIndex", zIndex );\u000a		}\u000a\u000a		if ( this.length ) {\u000a			var elem = $( this[ 0 ] ), position, value;\u000a			while ( elem.length && elem[ 0 ] !== document ) {\u000a				// Ignore z-index if position is set to a value where z-index is ignored by the browser\u000a				// This makes behavior of this function consistent across browsers\u000a				// WebKit always returns auto if the element is positioned\u000a				position = elem.css( "position" );\u000a				if ( position === "absolute" || position === "relative" || position === "fixed" ) {\u000a					// IE returns 0 when zIndex is not specified\u000a					// other browsers return a string\u000a					// we ignore the case of nested elements with an explicit value of 0\u000a					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>\u000a					value = parseInt( elem.css( "zIndex" ), 10 );\u000a					if ( !isNaN( value ) && value !== 0 ) {\u000a						return value;\u000a					}\u000a				}\u000a				elem = elem.parent();\u000a			}\u000a		}\u000a\u000a		return 0;\u000a	}\u000a});\u000a\u000a// $.ui.plugin is deprecated. Use $.widget() extensions instead.\u000a$.ui.plugin = {\u000a	add: function( module, option, set ) {\u000a		var i,\u000a			proto = $.ui[ module ].prototype;\u000a		for ( i in set ) {\u000a			proto.plugins[ i ] = proto.plugins[ i ] || [];\u000a			proto.plugins[ i ].push( [ option, set[ i ] ] );\u000a		}\u000a	},\u000a	call: function( instance, name, args, allowDisconnected ) {\u000a		var i,\u000a			set = instance.plugins[ name ];\u000a\u000a		if ( !set ) {\u000a			return;\u000a		}\u000a\u000a		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {\u000a			return;\u000a		}\u000a\u000a		for ( i = 0; i < set.length; i++ ) {\u000a			if ( instance.options[ set[ i ][ 0 ] ] ) {\u000a				set[ i ][ 1 ].apply( instance.element, args );\u000a			}\u000a		}\u000a	}\u000a};\u000a\u000a\u000a/*!\u000a * jQuery UI Widget 1.11.4\u000a * http://jqueryui.com\u000a *\u000a * Copyright jQuery Foundation and other contributors\u000a * Released under the MIT license.\u000a * http://jquery.org/license\u000a *\u000a * http://api.jqueryui.com/jQuery.widget/\u000a */\u000a\u000a\u000avar widget_uuid = 0,\u000a	widget_slice = Array.prototype.slice;\u000a\u000a$.cleanData = (function( orig ) {\u000a	return function( elems ) {\u000a		var events, elem, i;\u000a		for ( i = 0; (elem = elems[i]) != null; i++ ) {\u000a			try {\u000a\u000a				// Only trigger remove when necessary to save time\u000a				events = $._data( elem, "events" );\u000a				if ( events && events.remove ) {\u000a					$( elem ).triggerHandler( "remove" );\u000a				}\u000a\u000a			// http://bugs.jquery.com/ticket/8235\u000a			} catch ( e ) {}\u000a		}\u000a		orig( elems );\u000a	};\u000a})( $.cleanData );\u000a\u000a$.widget = function( name, base, prototype ) {\u000a	var fullName, existingConstructor, constructor, basePrototype,\u000a		// proxiedPrototype allows the provided prototype to remain unmodified\u000a		// so that it can be used as a mixin for multiple widgets (#8876)\u000a		proxiedPrototype = {},\u000a		namespace = name.split( "." )[ 0 ];\u000a\u000a	name = name.split( "." )[ 1 ];\u000a	fullName = namespace + "-" + name;\u000a\u000a	if ( !prototype ) {\u000a		prototype = base;\u000a		base = $.Widget;\u000a	}\u000a\u000a	// create selector for plugin\u000a	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {\u000a		return !!$.data( elem, fullName );\u000a	};\u000a\u000a	$[ namespace ] = $[ namespace ] || {};\u000a	existingConstructor = $[ namespace ][ name ];\u000a	constructor = $[ namespace ][ name ] = function( options, element ) {\u000a		// allow instantiation without "new" keyword\u000a		if ( !this._createWidget ) {\u000a			return new constructor( options, element );\u000a		}\u000a\u000a		// allow instantiation without initializing for simple inheritance\u000a		// must use "new" keyword (the code above always passes args)\u000a		if ( arguments.length ) {\u000a			this._createWidget( options, element );\u000a		}\u000a	};\u000a	// extend with the existing constructor to carry over any static properties\u000a	$.extend( constructor, existingConstructor, {\u000a		version: prototype.version,\u000a		// copy the object used to create the prototype in case we need to\u000a		// redefine the widget later\u000a		_proto: $.extend( {}, prototype ),\u000a		// track widgets that inherit from this widget in case this widget is\u000a		// redefined after a widget inherits from it\u000a		_childConstructors: []\u000a	});\u000a\u000a	basePrototype = new base();\u000a	// we need to make the options hash a property directly on the new instance\u000a	// otherwise we'll modify the options hash on the prototype that we're\u000a	// inheriting from\u000a	basePrototype.options = $.widget.extend( {}, basePrototype.options );\u000a	$.each( prototype, function( prop, value ) {\u000a		if ( !$.isFunction( value ) ) {\u000a			proxiedPrototype[ prop ] = value;\u000a			return;\u000a		}\u000a		proxiedPrototype[ prop ] = (function() {\u000a			var _super = function() {\u000a					return base.prototype[ prop ].apply( this, arguments );\u000a				},\u000a				_superApply = function( args ) {\u000a					return base.prototype[ prop ].apply( this, args );\u000a				};\u000a			return function() {\u000a				var __super = this._super,\u000a					__superApply = this._superApply,\u000a					returnValue;\u000a\u000a				this._super = _super;\u000a				this._superApply = _superApply;\u000a\u000a				returnValue = value.apply( this, arguments );\u000a\u000a				this._super = __super;\u000a				this._superApply = __superApply;\u000a\u000a				return returnValue;\u000a			};\u000a		})();\u000a	});\u000a	constructor.prototype = $.widget.extend( basePrototype, {\u000a		// TODO: remove support for widgetEventPrefix\u000a		// always use the name + a colon as the prefix, e.g., draggable:start\u000a		// don't prefix for widgets that aren't DOM-based\u000a		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name\u000a	}, proxiedPrototype, {\u000a		constructor: constructor,\u000a		namespace: namespace,\u000a		widgetName: name,\u000a		widgetFullName: fullName\u000a	});\u000a\u000a	// If this widget is being redefined then we need to find all widgets that\u000a	// are inheriting from it and redefine all of them so that they inherit from\u000a	// the new version of this widget. We're essentially trying to replace one\u000a	// level in the prototype chain.\u000a	if ( existingConstructor ) {\u000a		$.each( existingConstructor._childConstructors, function( i, child ) {\u000a			var childPrototype = child.prototype;\u000a\u000a			// redefine the child widget using the same prototype that was\u000a			// originally used, but inherit from the new version of the base\u000a			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );\u000a		});\u000a		// remove the list of existing child constructors from the old constructor\u000a		// so the old child constructors can be garbage collected\u000a		delete existingConstructor._childConstructors;\u000a	} else {\u000a		base._childConstructors.push( constructor );\u000a	}\u000a\u000a	$.widget.bridge( name, constructor );\u000a\u000a	return constructor;\u000a};\u000a\u000a$.widget.extend = function( target ) {\u000a	var input = widget_slice.call( arguments, 1 ),\u000a		inputIndex = 0,\u000a		inputLength = input.length,\u000a		key,\u000a		value;\u000a	for ( ; inputIndex < inputLength; inputIndex++ ) {\u000a		for ( key in input[ inputIndex ] ) {\u000a			value = input[ inputIndex ][ key ];\u000a			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\u000a				// Clone objects\u000a				if ( $.isPlainObject( value ) ) {\u000a					target[ key ] = $.isPlainObject( target[ key ] ) ?\u000a						$.widget.extend( {}, target[ key ], value ) :\u000a						// Don't extend strings, arrays, etc. with objects\u000a						$.widget.extend( {}, value );\u000a				// Copy everything else by reference\u000a				} else {\u000a					target[ key ] = value;\u000a				}\u000a			}\u000a		}\u000a	}\u000a	return target;\u000a};\u000a\u000a$.widget.bridge = function( name, object ) {\u000a	var fullName = object.prototype.widgetFullName || name;\u000a	$.fn[ name ] = function( options ) {\u000a		var isMethodCall = typeof options === "string",\u000a			args = widget_slice.call( arguments, 1 ),\u000a			returnValue = this;\u000a\u000a		if ( isMethodCall ) {\u000a			this.each(function() {\u000a				var methodValue,\u000a					instance = $.data( this, fullName );\u000a				if ( options === "instance" ) {\u000a					returnValue = instance;\u000a					return false;\u000a				}\u000a				if ( !instance ) {\u000a					return $.error( "cannot call methods on " + name + " prior to initialization; " +\u000a						"attempted to call method '" + options + "'" );\u000a				}\u000a				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {\u000a					return $.error( "no such method '" + options + "' for " + name + " widget instance" );\u000a				}\u000a				methodValue = instance[ options ].apply( instance, args );\u000a				if ( methodValue !== instance && methodValue !== undefined ) {\u000a					returnValue = methodValue && methodValue.jquery ?\u000a						returnValue.pushStack( methodValue.get() ) :\u000a						methodValue;\u000a					return false;\u000a				}\u000a			});\u000a		} else {\u000a\u000a			// Allow multiple hashes to be passed on init\u000a			if ( args.length ) {\u000a				options = $.widget.extend.apply( null, [ options ].concat(args) );\u000a			}\u000a\u000a			this.each(function() {\u000a				var instance = $.data( this, fullName );\u000a				if ( instance ) {\u000a					instance.option( options || {} );\u000a					if ( instance._init ) {\u000a						instance._init();\u000a					}\u000a				} else {\u000a					$.data( this, fullName, new object( options, this ) );\u000a				}\u000a			});\u000a		}\u000a\u000a		return returnValue;\u000a	};\u000a};\u000a\u000a$.Widget = function( /* options, element */ ) {};\u000a$.Widget._childConstructors = [];\u000a\u000a$.Widget.prototype = {\u000a	widgetName: "widget",\u000a	widgetEventPrefix: "",\u000a	defaultElement: "<div>",\u000a	options: {\u000a		disabled: false,\u000a\u000a		// callbacks\u000a		create: null\u000a	},\u000a	_createWidget: function( options, element ) {\u000a		element = $( element || this.defaultElement || this )[ 0 ];\u000a		this.element = $( element );\u000a		this.uuid = widget_uuid++;\u000a		this.eventNamespace = "." + this.widgetName + this.uuid;\u000a\u000a		this.bindings = $();\u000a		this.hoverable = $();\u000a		this.focusable = $();\u000a\u000a		if ( element !== this ) {\u000a			$.data( element, this.widgetFullName, this );\u000a			this._on( true, this.element, {\u000a				remove: function( event ) {\u000a					if ( event.target === element ) {\u000a						this.destroy();\u000a					}\u000a				}\u000a			});\u000a			this.document = $( element.style ?\u000a				// element within the document\u000a				element.ownerDocument :\u000a				// element is window or document\u000a				element.document || element );\u000a			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );\u000a		}\u000a\u000a		this.options = $.widget.extend( {},\u000a			this.options,\u000a			this._getCreateOptions(),\u000a			options );\u000a\u000a		this._create();\u000a		this._trigger( "create", null, this._getCreateEventData() );\u000a		this._init();\u000a	},\u000a	_getCreateOptions: $.noop,\u000a	_getCreateEventData: $.noop,\u000a	_create: $.noop,\u000a	_init: $.noop,\u000a\u000a	destroy: function() {\u000a		this._destroy();\u000a		// we can probably remove the unbind calls in 2.0\u000a		// all event bindings should go through this._on()\u000a		this.element\u000a			.unbind( this.eventNamespace )\u000a			.removeData( this.widgetFullName )\u000a			// support: jquery <1.6.3\u000a			// http://bugs.jquery.com/ticket/9413\u000a			.removeData( $.camelCase( this.widgetFullName ) );\u000a		this.widget()\u000a			.unbind( this.eventNamespace )\u000a			.removeAttr( "aria-disabled" )\u000a			.removeClass(\u000a				this.widgetFullName + "-disabled " +\u000a				"ui-state-disabled" );\u000a\u000a		// clean up events and states\u000a		this.bindings.unbind( this.eventNamespace );\u000a		this.hoverable.removeClass( "ui-state-hover" );\u000a		this.focusable.removeClass( "ui-state-focus" );\u000a	},\u000a	_destroy: $.noop,\u000a\u000a	widget: function() {\u000a		return this.element;\u000a	},\u000a\u000a	option: function( key, value ) {\u000a		var options = key,\u000a			parts,\u000a			curOption,\u000a			i;\u000a\u000a		if ( arguments.length === 0 ) {\u000a			// don't return a reference to the internal hash\u000a			return $.widget.extend( {}, this.options );\u000a		}\u000a\u000a		if ( typeof key === "string" ) {\u000a			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }\u000a			options = {};\u000a			parts = key.split( "." );\u000a			key = parts.shift();\u000a			if ( parts.length ) {\u000a				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\u000a				for ( i = 0; i < parts.length - 1; i++ ) {\u000a					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\u000a					curOption = curOption[ parts[ i ] ];\u000a				}\u000a				key = parts.pop();\u000a				if ( arguments.length === 1 ) {\u000a					return curOption[ key ] === undefined ? null : curOption[ key ];\u000a				}\u000a				curOption[ key ] = value;\u000a			} else {\u000a				if ( arguments.length === 1 ) {\u000a					return this.options[ key ] === undefined ? null : this.options[ key ];\u000a				}\u000a				options[ key ] = value;\u000a			}\u000a		}\u000a\u000a		this._setOptions( options );\u000a\u000a		return this;\u000a	},\u000a	_setOptions: function( options ) {\u000a		var key;\u000a\u000a		for ( key in options ) {\u000a			this._setOption( key, options[ key ] );\u000a		}\u000a\u000a		return this;\u000a	},\u000a	_setOption: function( key, value ) {\u000a		this.options[ key ] = value;\u000a\u000a		if ( key === "disabled" ) {\u000a			this.widget()\u000a				.toggleClass( this.widgetFullName + "-disabled", !!value );\u000a\u000a			// If the widget is becoming disabled, then nothing is interactive\u000a			if ( value ) {\u000a				this.hoverable.removeClass( "ui-state-hover" );\u000a				this.focusable.removeClass( "ui-state-focus" );\u000a			}\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	enable: function() {\u000a		return this._setOptions({ disabled: false });\u000a	},\u000a	disable: function() {\u000a		return this._setOptions({ disabled: true });\u000a	},\u000a\u000a	_on: function( suppressDisabledCheck, element, handlers ) {\u000a		var delegateElement,\u000a			instance = this;\u000a\u000a		// no suppressDisabledCheck flag, shuffle arguments\u000a		if ( typeof suppressDisabledCheck !== "boolean" ) {\u000a			handlers = element;\u000a			element = suppressDisabledCheck;\u000a			suppressDisabledCheck = false;\u000a		}\u000a\u000a		// no element argument, shuffle and use this.element\u000a		if ( !handlers ) {\u000a			handlers = element;\u000a			element = this.element;\u000a			delegateElement = this.widget();\u000a		} else {\u000a			element = delegateElement = $( element );\u000a			this.bindings = this.bindings.add( element );\u000a		}\u000a\u000a		$.each( handlers, function( event, handler ) {\u000a			function handlerProxy() {\u000a				// allow widgets to customize the disabled handling\u000a				// - disabled as an array instead of boolean\u000a				// - disabled class as method for disabling individual parts\u000a				if ( !suppressDisabledCheck &&\u000a						( instance.options.disabled === true ||\u000a							$( this ).hasClass( "ui-state-disabled" ) ) ) {\u000a					return;\u000a				}\u000a				return ( typeof handler === "string" ? instance[ handler ] : handler )\u000a					.apply( instance, arguments );\u000a			}\u000a\u000a			// copy the guid so direct unbinding works\u000a			if ( typeof handler !== "string" ) {\u000a				handlerProxy.guid = handler.guid =\u000a					handler.guid || handlerProxy.guid || $.guid++;\u000a			}\u000a\u000a			var match = event.match( /^([\u005cw:-]*)\u005cs*(.*)$/ ),\u000a				eventName = match[1] + instance.eventNamespace,\u000a				selector = match[2];\u000a			if ( selector ) {\u000a				delegateElement.delegate( selector, eventName, handlerProxy );\u000a			} else {\u000a				element.bind( eventName, handlerProxy );\u000a			}\u000a		});\u000a	},\u000a\u000a	_off: function( element, eventName ) {\u000a		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +\u000a			this.eventNamespace;\u000a		element.unbind( eventName ).undelegate( eventName );\u000a\u000a		// Clear the stack to avoid memory leaks (#10056)\u000a		this.bindings = $( this.bindings.not( element ).get() );\u000a		this.focusable = $( this.focusable.not( element ).get() );\u000a		this.hoverable = $( this.hoverable.not( element ).get() );\u000a	},\u000a\u000a	_delay: function( handler, delay ) {\u000a		function handlerProxy() {\u000a			return ( typeof handler === "string" ? instance[ handler ] : handler )\u000a				.apply( instance, arguments );\u000a		}\u000a		var instance = this;\u000a		return setTimeout( handlerProxy, delay || 0 );\u000a	},\u000a\u000a	_hoverable: function( element ) {\u000a		this.hoverable = this.hoverable.add( element );\u000a		this._on( element, {\u000a			mouseenter: function( event ) {\u000a				$( event.currentTarget ).addClass( "ui-state-hover" );\u000a			},\u000a			mouseleave: function( event ) {\u000a				$( event.currentTarget ).removeClass( "ui-state-hover" );\u000a			}\u000a		});\u000a	},\u000a\u000a	_focusable: function( element ) {\u000a		this.focusable = this.focusable.add( element );\u000a		this._on( element, {\u000a			focusin: function( event ) {\u000a				$( event.currentTarget ).addClass( "ui-state-focus" );\u000a			},\u000a			focusout: function( event ) {\u000a				$( event.currentTarget ).removeClass( "ui-state-focus" );\u000a			}\u000a		});\u000a	},\u000a\u000a	_trigger: function( type, event, data ) {\u000a		var prop, orig,\u000a			callback = this.options[ type ];\u000a\u000a		data = data || {};\u000a		event = $.Event( event );\u000a		event.type = ( type === this.widgetEventPrefix ?\u000a			type :\u000a			this.widgetEventPrefix + type ).toLowerCase();\u000a		// the original event may come from any element\u000a		// so we need to reset the target on the new event\u000a		event.target = this.element[ 0 ];\u000a\u000a		// copy original event properties over to the new event\u000a		orig = event.originalEvent;\u000a		if ( orig ) {\u000a			for ( prop in orig ) {\u000a				if ( !( prop in event ) ) {\u000a					event[ prop ] = orig[ prop ];\u000a				}\u000a			}\u000a		}\u000a\u000a		this.element.trigger( event, data );\u000a		return !( $.isFunction( callback ) &&\u000a			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||\u000a			event.isDefaultPrevented() );\u000a	}\u000a};\u000a\u000a$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {\u000a	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {\u000a		if ( typeof options === "string" ) {\u000a			options = { effect: options };\u000a		}\u000a		var hasOptions,\u000a			effectName = !options ?\u000a				method :\u000a				options === true || typeof options === "number" ?\u000a					defaultEffect :\u000a					options.effect || defaultEffect;\u000a		options = options || {};\u000a		if ( typeof options === "number" ) {\u000a			options = { duration: options };\u000a		}\u000a		hasOptions = !$.isEmptyObject( options );\u000a		options.complete = callback;\u000a		if ( options.delay ) {\u000a			element.delay( options.delay );\u000a		}\u000a		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\u000a			element[ method ]( options );\u000a		} else if ( effectName !== method && element[ effectName ] ) {\u000a			element[ effectName ]( options.duration, options.easing, callback );\u000a		} else {\u000a			element.queue(function( next ) {\u000a				$( this )[ method ]();\u000a				if ( callback ) {\u000a					callback.call( element[ 0 ] );\u000a				}\u000a				next();\u000a			});\u000a		}\u000a	};\u000a});\u000a\u000avar widget = $.widget;\u000a\u000a\u000a/*!\u000a * jQuery UI Mouse 1.11.4\u000a * http://jqueryui.com\u000a *\u000a * Copyright jQuery Foundation and other contributors\u000a * Released under the MIT license.\u000a * http://jquery.org/license\u000a *\u000a * http://api.jqueryui.com/mouse/\u000a */\u000a\u000a\u000avar mouseHandled = false;\u000a$( document ).mouseup( function() {\u000a	mouseHandled = false;\u000a});\u000a\u000avar mouse = $.widget("ui.mouse", {\u000a	version: "1.11.4",\u000a	options: {\u000a		cancel: "input,textarea,button,select,option",\u000a		distance: 1,\u000a		delay: 0\u000a	},\u000a	_mouseInit: function() {\u000a		var that = this;\u000a\u000a		this.element\u000a			.bind("mousedown." + this.widgetName, function(event) {\u000a				return that._mouseDown(event);\u000a			})\u000a			.bind("click." + this.widgetName, function(event) {\u000a				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {\u000a					$.removeData(event.target, that.widgetName + ".preventClickEvent");\u000a					event.stopImmediatePropagation();\u000a					return false;\u000a				}\u000a			});\u000a\u000a		this.started = false;\u000a	},\u000a\u000a	// TODO: make sure destroying one instance of mouse doesn't mess with\u000a	// other instances of mouse\u000a	_mouseDestroy: function() {\u000a		this.element.unbind("." + this.widgetName);\u000a		if ( this._mouseMoveDelegate ) {\u000a			this.document\u000a				.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)\u000a				.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);\u000a		}\u000a	},\u000a\u000a	_mouseDown: function(event) {\u000a		// don't let more than one widget handle mouseStart\u000a		if ( mouseHandled ) {\u000a			return;\u000a		}\u000a\u000a		this._mouseMoved = false;\u000a\u000a		// we may have missed mouseup (out of window)\u000a		(this._mouseStarted && this._mouseUp(event));\u000a\u000a		this._mouseDownEvent = event;\u000a\u000a		var that = this,\u000a			btnIsLeft = (event.which === 1),\u000a			// event.target.nodeName works around a bug in IE 8 with\u000a			// disabled inputs (#7620)\u000a			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\u000a		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\u000a			return true;\u000a		}\u000a\u000a		this.mouseDelayMet = !this.options.delay;\u000a		if (!this.mouseDelayMet) {\u000a			this._mouseDelayTimer = setTimeout(function() {\u000a				that.mouseDelayMet = true;\u000a			}, this.options.delay);\u000a		}\u000a\u000a		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\u000a			this._mouseStarted = (this._mouseStart(event) !== false);\u000a			if (!this._mouseStarted) {\u000a				event.preventDefault();\u000a				return true;\u000a			}\u000a		}\u000a\u000a		// Click event may never have fired (Gecko & Opera)\u000a		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {\u000a			$.removeData(event.target, this.widgetName + ".preventClickEvent");\u000a		}\u000a\u000a		// these delegates are required to keep context\u000a		this._mouseMoveDelegate = function(event) {\u000a			return that._mouseMove(event);\u000a		};\u000a		this._mouseUpDelegate = function(event) {\u000a			return that._mouseUp(event);\u000a		};\u000a\u000a		this.document\u000a			.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )\u000a			.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );\u000a\u000a		event.preventDefault();\u000a\u000a		mouseHandled = true;\u000a		return true;\u000a	},\u000a\u000a	_mouseMove: function(event) {\u000a		// Only check for mouseups outside the document if you've moved inside the document\u000a		// at least once. This prevents the firing of mouseup in the case of IE<9, which will\u000a		// fire a mousemove event if content is placed under the cursor. See #7778\u000a		// Support: IE <9\u000a		if ( this._mouseMoved ) {\u000a			// IE mouseup check - mouseup happened when mouse was out of window\u000a			if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {\u000a				return this._mouseUp(event);\u000a\u000a			// Iframe mouseup check - mouseup occurred in another document\u000a			} else if ( !event.which ) {\u000a				return this._mouseUp( event );\u000a			}\u000a		}\u000a\u000a		if ( event.which || event.button ) {\u000a			this._mouseMoved = true;\u000a		}\u000a\u000a		if (this._mouseStarted) {\u000a			this._mouseDrag(event);\u000a			return event.preventDefault();\u000a		}\u000a\u000a		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\u000a			this._mouseStarted =\u000a				(this._mouseStart(this._mouseDownEvent, event) !== false);\u000a			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\u000a		}\u000a\u000a		return !this._mouseStarted;\u000a	},\u000a\u000a	_mouseUp: function(event) {\u000a		this.document\u000a			.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )\u000a			.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );\u000a\u000a		if (this._mouseStarted) {\u000a			this._mouseStarted = false;\u000a\u000a			if (event.target === this._mouseDownEvent.target) {\u000a				$.data(event.target, this.widgetName + ".preventClickEvent", true);\u000a			}\u000a\u000a			this._mouseStop(event);\u000a		}\u000a\u000a		mouseHandled = false;\u000a		return false;\u000a	},\u000a\u000a	_mouseDistanceMet: function(event) {\u000a		return (Math.max(\u000a				Math.abs(this._mouseDownEvent.pageX - event.pageX),\u000a				Math.abs(this._mouseDownEvent.pageY - event.pageY)\u000a			) >= this.options.distance\u000a		);\u000a	},\u000a\u000a	_mouseDelayMet: function(/* event */) {\u000a		return this.mouseDelayMet;\u000a	},\u000a\u000a	// These are placeholder methods, to be overriden by extending plugin\u000a	_mouseStart: function(/* event */) {},\u000a	_mouseDrag: function(/* event */) {},\u000a	_mouseStop: function(/* event */) {},\u000a	_mouseCapture: function(/* event */) { return true; }\u000a});\u000a\u000a\u000a/*!\u000a * jQuery UI Draggable 1.11.4\u000a * http://jqueryui.com\u000a *\u000a * Copyright jQuery Foundation and other contributors\u000a * Released under the MIT license.\u000a * http://jquery.org/license\u000a *\u000a * http://api.jqueryui.com/draggable/\u000a */\u000a\u000a\u000a$.widget("ui.draggable", $.ui.mouse, {\u000a	version: "1.11.4",\u000a	widgetEventPrefix: "drag",\u000a	options: {\u000a		addClasses: true,\u000a		appendTo: "parent",\u000a		axis: false,\u000a		connectToSortable: false,\u000a		containment: false,\u000a		cursor: "auto",\u000a		cursorAt: false,\u000a		grid: false,\u000a		handle: false,\u000a		helper: "original",\u000a		iframeFix: false,\u000a		opacity: false,\u000a		refreshPositions: false,\u000a		revert: false,\u000a		revertDuration: 500,\u000a		scope: "default",\u000a		scroll: true,\u000a		scrollSensitivity: 20,\u000a		scrollSpeed: 20,\u000a		snap: false,\u000a		snapMode: "both",\u000a		snapTolerance: 20,\u000a		stack: false,\u000a		zIndex: false,\u000a\u000a		// callbacks\u000a		drag: null,\u000a		start: null,\u000a		stop: null\u000a	},\u000a	_create: function() {\u000a\u000a		if ( this.options.helper === "original" ) {\u000a			this._setPositionRelative();\u000a		}\u000a		if (this.options.addClasses){\u000a			this.element.addClass("ui-draggable");\u000a		}\u000a		if (this.options.disabled){\u000a			this.element.addClass("ui-draggable-disabled");\u000a		}\u000a		this._setHandleClassName();\u000a\u000a		this._mouseInit();\u000a	},\u000a\u000a	_setOption: function( key, value ) {\u000a		this._super( key, value );\u000a		if ( key === "handle" ) {\u000a			this._removeHandleClassName();\u000a			this._setHandleClassName();\u000a		}\u000a	},\u000a\u000a	_destroy: function() {\u000a		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {\u000a			this.destroyOnClear = true;\u000a			return;\u000a		}\u000a		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );\u000a		this._removeHandleClassName();\u000a		this._mouseDestroy();\u000a	},\u000a\u000a	_mouseCapture: function(event) {\u000a		var o = this.options;\u000a\u000a		this._blurActiveElement( event );\u000a\u000a		// among others, prevent a drag on a resizable-handle\u000a		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {\u000a			return false;\u000a		}\u000a\u000a		//Quit if we're not on a valid handle\u000a		this.handle = this._getHandle(event);\u000a		if (!this.handle) {\u000a			return false;\u000a		}\u000a\u000a		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );\u000a\u000a		return true;\u000a\u000a	},\u000a\u000a	_blockFrames: function( selector ) {\u000a		this.iframeBlocks = this.document.find( selector ).map(function() {\u000a			var iframe = $( this );\u000a\u000a			return $( "<div>" )\u000a				.css( "position", "absolute" )\u000a				.appendTo( iframe.parent() )\u000a				.outerWidth( iframe.outerWidth() )\u000a				.outerHeight( iframe.outerHeight() )\u000a				.offset( iframe.offset() )[ 0 ];\u000a		});\u000a	},\u000a\u000a	_unblockFrames: function() {\u000a		if ( this.iframeBlocks ) {\u000a			this.iframeBlocks.remove();\u000a			delete this.iframeBlocks;\u000a		}\u000a	},\u000a\u000a	_blurActiveElement: function( event ) {\u000a		var document = this.document[ 0 ];\u000a\u000a		// Only need to blur if the event occurred on the draggable itself, see #10527\u000a		if ( !this.handleElement.is( event.target ) ) {\u000a			return;\u000a		}\u000a\u000a		// support: IE9\u000a		// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>\u000a		try {\u000a\u000a			// Support: IE9, IE10\u000a			// If the <body> is blurred, IE will switch windows, see #9520\u000a			if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {\u000a\u000a				// Blur any element that currently has focus, see #4261\u000a				$( document.activeElement ).blur();\u000a			}\u000a		} catch ( error ) {}\u000a	},\u000a\u000a	_mouseStart: function(event) {\u000a\u000a		var o = this.options;\u000a\u000a		//Create and append the visible helper\u000a		this.helper = this._createHelper(event);\u000a\u000a		this.helper.addClass("ui-draggable-dragging");\u000a\u000a		//Cache the helper size\u000a		this._cacheHelperProportions();\u000a\u000a		//If ddmanager is used for droppables, set the global draggable\u000a		if ($.ui.ddmanager) {\u000a			$.ui.ddmanager.current = this;\u000a		}\u000a\u000a		/*\u000a		 * - Position generation -\u000a		 * This block generates everything position related - it's the core of draggables.\u000a		 */\u000a\u000a		//Cache the margins of the original element\u000a		this._cacheMargins();\u000a\u000a		//Store the helper's css position\u000a		this.cssPosition = this.helper.css( "position" );\u000a		this.scrollParent = this.helper.scrollParent( true );\u000a		this.offsetParent = this.helper.offsetParent();\u000a		this.hasFixedAncestor = this.helper.parents().filter(function() {\u000a				return $( this ).css( "position" ) === "fixed";\u000a			}).length > 0;\u000a\u000a		//The element's absolute position on the page minus margins\u000a		this.positionAbs = this.element.offset();\u000a		this._refreshOffsets( event );\u000a\u000a		//Generate the original position\u000a		this.originalPosition = this.position = this._generatePosition( event, false );\u000a		this.originalPageX = event.pageX;\u000a		this.originalPageY = event.pageY;\u000a\u000a		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied\u000a		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\u000a\u000a		//Set a containment if given in the options\u000a		this._setContainment();\u000a\u000a		//Trigger event + callbacks\u000a		if (this._trigger("start", event) === false) {\u000a			this._clear();\u000a			return false;\u000a		}\u000a\u000a		//Recache the helper size\u000a		this._cacheHelperProportions();\u000a\u000a		//Prepare the droppable offsets\u000a		if ($.ui.ddmanager && !o.dropBehaviour) {\u000a			$.ui.ddmanager.prepareOffsets(this, event);\u000a		}\u000a\u000a		// Reset helper's right/bottom css if they're set and set explicit width/height instead\u000a		// as this prevents resizing of elements with right/bottom set (see #7772)\u000a		this._normalizeRightBottom();\u000a\u000a		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position\u000a\u000a		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)\u000a		if ( $.ui.ddmanager ) {\u000a			$.ui.ddmanager.dragStart(this, event);\u000a		}\u000a\u000a		return true;\u000a	},\u000a\u000a	_refreshOffsets: function( event ) {\u000a		this.offset = {\u000a			top: this.positionAbs.top - this.margins.top,\u000a			left: this.positionAbs.left - this.margins.left,\u000a			scroll: false,\u000a			parent: this._getParentOffset(),\u000a			relative: this._getRelativeOffset()\u000a		};\u000a\u000a		this.offset.click = {\u000a			left: event.pageX - this.offset.left,\u000a			top: event.pageY - this.offset.top\u000a		};\u000a	},\u000a\u000a	_mouseDrag: function(event, noPropagation) {\u000a		// reset any necessary cached properties (see #5009)\u000a		if ( this.hasFixedAncestor ) {\u000a			this.offset.parent = this._getParentOffset();\u000a		}\u000a\u000a		//Compute the helpers position\u000a		this.position = this._generatePosition( event, true );\u000a		this.positionAbs = this._convertPositionTo("absolute");\u000a\u000a		//Call plugins and callbacks and use the resulting position if something is returned\u000a		if (!noPropagation) {\u000a			var ui = this._uiHash();\u000a			if (this._trigger("drag", event, ui) === false) {\u000a				this._mouseUp({});\u000a				return false;\u000a			}\u000a			this.position = ui.position;\u000a		}\u000a\u000a		this.helper[ 0 ].style.left = this.position.left + "px";\u000a		this.helper[ 0 ].style.top = this.position.top + "px";\u000a\u000a		if ($.ui.ddmanager) {\u000a			$.ui.ddmanager.drag(this, event);\u000a		}\u000a\u000a		return false;\u000a	},\u000a\u000a	_mouseStop: function(event) {\u000a\u000a		//If we are using droppables, inform the manager about the drop\u000a		var that = this,\u000a			dropped = false;\u000a		if ($.ui.ddmanager && !this.options.dropBehaviour) {\u000a			dropped = $.ui.ddmanager.drop(this, event);\u000a		}\u000a\u000a		//if a drop comes from outside (a sortable)\u000a		if (this.dropped) {\u000a			dropped = this.dropped;\u000a			this.dropped = false;\u000a		}\u000a\u000a		if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {\u000a			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {\u000a				if (that._trigger("stop", event) !== false) {\u000a					that._clear();\u000a				}\u000a			});\u000a		} else {\u000a			if (this._trigger("stop", event) !== false) {\u000a				this._clear();\u000a			}\u000a		}\u000a\u000a		return false;\u000a	},\u000a\u000a	_mouseUp: function( event ) {\u000a		this._unblockFrames();\u000a\u000a		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)\u000a		if ( $.ui.ddmanager ) {\u000a			$.ui.ddmanager.dragStop(this, event);\u000a		}\u000a\u000a		// Only need to focus if the event occurred on the draggable itself, see #10527\u000a		if ( this.handleElement.is( event.target ) ) {\u000a			// The interaction is over; whether or not the click resulted in a drag, focus the element\u000a			this.element.focus();\u000a		}\u000a\u000a		return $.ui.mouse.prototype._mouseUp.call(this, event);\u000a	},\u000a\u000a	cancel: function() {\u000a\u000a		if (this.helper.is(".ui-draggable-dragging")) {\u000a			this._mouseUp({});\u000a		} else {\u000a			this._clear();\u000a		}\u000a\u000a		return this;\u000a\u000a	},\u000a\u000a	_getHandle: function(event) {\u000a		return this.options.handle ?\u000a			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :\u000a			true;\u000a	},\u000a\u000a	_setHandleClassName: function() {\u000a		this.handleElement = this.options.handle ?\u000a			this.element.find( this.options.handle ) : this.element;\u000a		this.handleElement.addClass( "ui-draggable-handle" );\u000a	},\u000a\u000a	_removeHandleClassName: function() {\u000a		this.handleElement.removeClass( "ui-draggable-handle" );\u000a	},\u000a\u000a	_createHelper: function(event) {\u000a\u000a		var o = this.options,\u000a			helperIsFunction = $.isFunction( o.helper ),\u000a			helper = helperIsFunction ?\u000a				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :\u000a				( o.helper === "clone" ?\u000a					this.element.clone().removeAttr( "id" ) :\u000a					this.element );\u000a\u000a		if (!helper.parents("body").length) {\u000a			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));\u000a		}\u000a\u000a		// http://bugs.jqueryui.com/ticket/9446\u000a		// a helper function can return the original element\u000a		// which wouldn't have been set to relative in _create\u000a		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {\u000a			this._setPositionRelative();\u000a		}\u000a\u000a		if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {\u000a			helper.css("position", "absolute");\u000a		}\u000a\u000a		return helper;\u000a\u000a	},\u000a\u000a	_setPositionRelative: function() {\u000a		if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {\u000a			this.element[ 0 ].style.position = "relative";\u000a		}\u000a	},\u000a\u000a	_adjustOffsetFromHelper: function(obj) {\u000a		if (typeof obj === "string") {\u000a			obj = obj.split(" ");\u000a		}\u000a		if ($.isArray(obj)) {\u000a			obj = { left: +obj[0], top: +obj[1] || 0 };\u000a		}\u000a		if ("left" in obj) {\u000a			this.offset.click.left = obj.left + this.margins.left;\u000a		}\u000a		if ("right" in obj) {\u000a			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\u000a		}\u000a		if ("top" in obj) {\u000a			this.offset.click.top = obj.top + this.margins.top;\u000a		}\u000a		if ("bottom" in obj) {\u000a			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\u000a		}\u000a	},\u000a\u000a	_isRootNode: function( element ) {\u000a		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];\u000a	},\u000a\u000a	_getParentOffset: function() {\u000a\u000a		//Get the offsetParent and cache its position\u000a		var po = this.offsetParent.offset(),\u000a			document = this.document[ 0 ];\u000a\u000a		// This is a special case where we need to modify a offset calculated on start, since the following happened:\u000a		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\u000a		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\u000a		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\u000a		if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\u000a			po.left += this.scrollParent.scrollLeft();\u000a			po.top += this.scrollParent.scrollTop();\u000a		}\u000a\u000a		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {\u000a			po = { top: 0, left: 0 };\u000a		}\u000a\u000a		return {\u000a			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),\u000a			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)\u000a		};\u000a\u000a	},\u000a\u000a	_getRelativeOffset: function() {\u000a		if ( this.cssPosition !== "relative" ) {\u000a			return { top: 0, left: 0 };\u000a		}\u000a\u000a		var p = this.element.position(),\u000a			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );\u000a\u000a		return {\u000a			top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),\u000a			left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )\u000a		};\u000a\u000a	},\u000a\u000a	_cacheMargins: function() {\u000a		this.margins = {\u000a			left: (parseInt(this.element.css("marginLeft"), 10) || 0),\u000a			top: (parseInt(this.element.css("marginTop"), 10) || 0),\u000a			right: (parseInt(this.element.css("marginRight"), 10) || 0),\u000a			bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)\u000a		};\u000a	},\u000a\u000a	_cacheHelperProportions: function() {\u000a		this.helperProportions = {\u000a			width: this.helper.outerWidth(),\u000a			height: this.helper.outerHeight()\u000a		};\u000a	},\u000a\u000a	_setContainment: function() {\u000a\u000a		var isUserScrollable, c, ce,\u000a			o = this.options,\u000a			document = this.document[ 0 ];\u000a\u000a		this.relativeContainer = null;\u000a\u000a		if ( !o.containment ) {\u000a			this.containment = null;\u000a			return;\u000a		}\u000a\u000a		if ( o.containment === "window" ) {\u000a			this.containment = [\u000a				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,\u000a				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,\u000a				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,\u000a				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top\u000a			];\u000a			return;\u000a		}\u000a\u000a		if ( o.containment === "document") {\u000a			this.containment = [\u000a				0,\u000a				0,\u000a				$( document ).width() - this.helperProportions.width - this.margins.left,\u000a				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top\u000a			];\u000a			return;\u000a		}\u000a\u000a		if ( o.containment.constructor === Array ) {\u000a			this.containment = o.containment;\u000a			return;\u000a		}\u000a\u000a		if ( o.containment === "parent" ) {\u000a			o.containment = this.helper[ 0 ].parentNode;\u000a		}\u000a\u000a		c = $( o.containment );\u000a		ce = c[ 0 ];\u000a\u000a		if ( !ce ) {\u000a			return;\u000a		}\u000a\u000a		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );\u000a\u000a		this.containment = [\u000a			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),\u000a			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),\u000a			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -\u000a				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -\u000a				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -\u000a				this.helperProportions.width -\u000a				this.margins.left -\u000a				this.margins.right,\u000a			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -\u000a				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -\u000a				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -\u000a				this.helperProportions.height -\u000a				this.margins.top -\u000a				this.margins.bottom\u000a		];\u000a		this.relativeContainer = c;\u000a	},\u000a\u000a	_convertPositionTo: function(d, pos) {\u000a\u000a		if (!pos) {\u000a			pos = this.position;\u000a		}\u000a\u000a		var mod = d === "absolute" ? 1 : -1,\u000a			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );\u000a\u000a		return {\u000a			top: (\u000a				pos.top	+																// The absolute mouse position\u000a				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)\u000a				( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)\u000a			),\u000a			left: (\u000a				pos.left +																// The absolute mouse position\u000a				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)\u000a				( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)\u000a			)\u000a		};\u000a\u000a	},\u000a\u000a	_generatePosition: function( event, constrainPosition ) {\u000a\u000a		var containment, co, top, left,\u000a			o = this.options,\u000a			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),\u000a			pageX = event.pageX,\u000a			pageY = event.pageY;\u000a\u000a		// Cache the scroll\u000a		if ( !scrollIsRootNode || !this.offset.scroll ) {\u000a			this.offset.scroll = {\u000a				top: this.scrollParent.scrollTop(),\u000a				left: this.scrollParent.scrollLeft()\u000a			};\u000a		}\u000a\u000a		/*\u000a		 * - Position constraining -\u000a		 * Constrain the position to a mix of grid, containment.\u000a		 */\u000a\u000a		// If we are not dragging yet, we won't check for options\u000a		if ( constrainPosition ) {\u000a			if ( this.containment ) {\u000a				if ( this.relativeContainer ){\u000a					co = this.relativeContainer.offset();\u000a					containment = [\u000a						this.containment[ 0 ] + co.left,\u000a						this.containment[ 1 ] + co.top,\u000a						this.containment[ 2 ] + co.left,\u000a						this.containment[ 3 ] + co.top\u000a					];\u000a				} else {\u000a					containment = this.containment;\u000a				}\u000a\u000a				if (event.pageX - this.offset.click.left < containment[0]) {\u000a					pageX = containment[0] + this.offset.click.left;\u000a				}\u000a				if (event.pageY - this.offset.click.top < containment[1]) {\u000a					pageY = containment[1] + this.offset.click.top;\u000a				}\u000a				if (event.pageX - this.offset.click.left > containment[2]) {\u000a					pageX = containment[2] + this.offset.click.left;\u000a				}\u000a				if (event.pageY - this.offset.click.top > containment[3]) {\u000a					pageY = containment[3] + this.offset.click.top;\u000a				}\u000a			}\u000a\u000a			if (o.grid) {\u000a				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)\u000a				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;\u000a				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\u000a\u000a				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;\u000a				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\u000a			}\u000a\u000a			if ( o.axis === "y" ) {\u000a				pageX = this.originalPageX;\u000a			}\u000a\u000a			if ( o.axis === "x" ) {\u000a				pageY = this.originalPageY;\u000a			}\u000a		}\u000a\u000a		return {\u000a			top: (\u000a				pageY -																	// The absolute mouse position\u000a				this.offset.click.top	-												// Click offset (relative to the element)\u000a				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)\u000a				( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )\u000a			),\u000a			left: (\u000a				pageX -																	// The absolute mouse position\u000a				this.offset.click.left -												// Click offset (relative to the element)\u000a				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)\u000a				( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )\u000a			)\u000a		};\u000a\u000a	},\u000a\u000a	_clear: function() {\u000a		this.helper.removeClass("ui-draggable-dragging");\u000a		if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {\u000a			this.helper.remove();\u000a		}\u000a		this.helper = null;\u000a		this.cancelHelperRemoval = false;\u000a		if ( this.destroyOnClear ) {\u000a			this.destroy();\u000a		}\u000a	},\u000a\u000a	_normalizeRightBottom: function() {\u000a		if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {\u000a			this.helper.width( this.helper.width() );\u000a			this.helper.css( "right", "auto" );\u000a		}\u000a		if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {\u000a			this.helper.height( this.helper.height() );\u000a			this.helper.css( "bottom", "auto" );\u000a		}\u000a	},\u000a\u000a	// From now on bulk stuff - mainly helpers\u000a\u000a	_trigger: function( type, event, ui ) {\u000a		ui = ui || this._uiHash();\u000a		$.ui.plugin.call( this, type, [ event, ui, this ], true );\u000a\u000a		// Absolute position and offset (see #6884 ) have to be recalculated after plugins\u000a		if ( /^(drag|start|stop)/.test( type ) ) {\u000a			this.positionAbs = this._convertPositionTo( "absolute" );\u000a			ui.offset = this.positionAbs;\u000a		}\u000a		return $.Widget.prototype._trigger.call( this, type, event, ui );\u000a	},\u000a\u000a	plugins: {},\u000a\u000a	_uiHash: function() {\u000a		return {\u000a			helper: this.helper,\u000a			position: this.position,\u000a			originalPosition: this.originalPosition,\u000a			offset: this.positionAbs\u000a		};\u000a	}\u000a\u000a});\u000a\u000a$.ui.plugin.add( "draggable", "connectToSortable", {\u000a	start: function( event, ui, draggable ) {\u000a		var uiSortable = $.extend( {}, ui, {\u000a			item: draggable.element\u000a		});\u000a\u000a		draggable.sortables = [];\u000a		$( draggable.options.connectToSortable ).each(function() {\u000a			var sortable = $( this ).sortable( "instance" );\u000a\u000a			if ( sortable && !sortable.options.disabled ) {\u000a				draggable.sortables.push( sortable );\u000a\u000a				// refreshPositions is called at drag start to refresh the containerCache\u000a				// which is used in drag. This ensures it's initialized and synchronized\u000a				// with any changes that might have happened on the page since initialization.\u000a				sortable.refreshPositions();\u000a				sortable._trigger("activate", event, uiSortable);\u000a			}\u000a		});\u000a	},\u000a	stop: function( event, ui, draggable ) {\u000a		var uiSortable = $.extend( {}, ui, {\u000a			item: draggable.element\u000a		});\u000a\u000a		draggable.cancelHelperRemoval = false;\u000a\u000a		$.each( draggable.sortables, function() {\u000a			var sortable = this;\u000a\u000a			if ( sortable.isOver ) {\u000a				sortable.isOver = 0;\u000a\u000a				// Allow this sortable to handle removing the helper\u000a				draggable.cancelHelperRemoval = true;\u000a				sortable.cancelHelperRemoval = false;\u000a\u000a				// Use _storedCSS To restore properties in the sortable,\u000a				// as this also handles revert (#9675) since the draggable\u000a				// may have modified them in unexpected ways (#8809)\u000a				sortable._storedCSS = {\u000a					position: sortable.placeholder.css( "position" ),\u000a					top: sortable.placeholder.css( "top" ),\u000a					left: sortable.placeholder.css( "left" )\u000a				};\u000a\u000a				sortable._mouseStop(event);\u000a\u000a				// Once drag has ended, the sortable should return to using\u000a				// its original helper, not the shared helper from draggable\u000a				sortable.options.helper = sortable.options._helper;\u000a			} else {\u000a				// Prevent this Sortable from removing the helper.\u000a				// However, don't set the draggable to remove the helper\u000a				// either as another connected Sortable may yet handle the removal.\u000a				sortable.cancelHelperRemoval = true;\u000a\u000a				sortable._trigger( "deactivate", event, uiSortable );\u000a			}\u000a		});\u000a	},\u000a	drag: function( event, ui, draggable ) {\u000a		$.each( draggable.sortables, function() {\u000a			var innermostIntersecting = false,\u000a				sortable = this;\u000a\u000a			// Copy over variables that sortable's _intersectsWith uses\u000a			sortable.positionAbs = draggable.positionAbs;\u000a			sortable.helperProportions = draggable.helperProportions;\u000a			sortable.offset.click = draggable.offset.click;\u000a\u000a			if ( sortable._intersectsWith( sortable.containerCache ) ) {\u000a				innermostIntersecting = true;\u000a\u000a				$.each( draggable.sortables, function() {\u000a					// Copy over variables that sortable's _intersectsWith uses\u000a					this.positionAbs = draggable.positionAbs;\u000a					this.helperProportions = draggable.helperProportions;\u000a					this.offset.click = draggable.offset.click;\u000a\u000a					if ( this !== sortable &&\u000a							this._intersectsWith( this.containerCache ) &&\u000a							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {\u000a						innermostIntersecting = false;\u000a					}\u000a\u000a					return innermostIntersecting;\u000a				});\u000a			}\u000a\u000a			if ( innermostIntersecting ) {\u000a				// If it intersects, we use a little isOver variable and set it once,\u000a				// so that the move-in stuff gets fired only once.\u000a				if ( !sortable.isOver ) {\u000a					sortable.isOver = 1;\u000a\u000a					// Store draggable's parent in case we need to reappend to it later.\u000a					draggable._parent = ui.helper.parent();\u000a\u000a					sortable.currentItem = ui.helper\u000a						.appendTo( sortable.element )\u000a						.data( "ui-sortable-item", true );\u000a\u000a					// Store helper option to later restore it\u000a					sortable.options._helper = sortable.options.helper;\u000a\u000a					sortable.options.helper = function() {\u000a						return ui.helper[ 0 ];\u000a					};\u000a\u000a					// Fire the start events of the sortable with our passed browser event,\u000a					// and our own helper (so it doesn't create a new one)\u000a					event.target = sortable.currentItem[ 0 ];\u000a					sortable._mouseCapture( event, true );\u000a					sortable._mouseStart( event, true, true );\u000a\u000a					// Because the browser event is way off the new appended portlet,\u000a					// modify necessary variables to reflect the changes\u000a					sortable.offset.click.top = draggable.offset.click.top;\u000a					sortable.offset.click.left = draggable.offset.click.left;\u000a					sortable.offset.parent.left -= draggable.offset.parent.left -\u000a						sortable.offset.parent.left;\u000a					sortable.offset.parent.top -= draggable.offset.parent.top -\u000a						sortable.offset.parent.top;\u000a\u000a					draggable._trigger( "toSortable", event );\u000a\u000a					// Inform draggable that the helper is in a valid drop zone,\u000a					// used solely in the revert option to handle "valid/invalid".\u000a					draggable.dropped = sortable.element;\u000a\u000a					// Need to refreshPositions of all sortables in the case that\u000a					// adding to one sortable changes the location of the other sortables (#9675)\u000a					$.each( draggable.sortables, function() {\u000a						this.refreshPositions();\u000a					});\u000a\u000a					// hack so receive/update callbacks work (mostly)\u000a					draggable.currentItem = draggable.element;\u000a					sortable.fromOutside = draggable;\u000a				}\u000a\u000a				if ( sortable.currentItem ) {\u000a					sortable._mouseDrag( event );\u000a					// Copy the sortable's position because the draggable's can potentially reflect\u000a					// a relative position, while sortable is always absolute, which the dragged\u000a					// element has now become. (#8809)\u000a					ui.position = sortable.position;\u000a				}\u000a			} else {\u000a				// If it doesn't intersect with the sortable, and it intersected before,\u000a				// we fake the drag stop of the sortable, but make sure it doesn't remove\u000a				// the helper by using cancelHelperRemoval.\u000a				if ( sortable.isOver ) {\u000a\u000a					sortable.isOver = 0;\u000a					sortable.cancelHelperRemoval = true;\u000a\u000a					// Calling sortable's mouseStop would trigger a revert,\u000a					// so revert must be temporarily false until after mouseStop is called.\u000a					sortable.options._revert = sortable.options.revert;\u000a					sortable.options.revert = false;\u000a\u000a					sortable._trigger( "out", event, sortable._uiHash( sortable ) );\u000a					sortable._mouseStop( event, true );\u000a\u000a					// restore sortable behaviors that were modfied\u000a					// when the draggable entered the sortable area (#9481)\u000a					sortable.options.revert = sortable.options._revert;\u000a					sortable.options.helper = sortable.options._helper;\u000a\u000a					if ( sortable.placeholder ) {\u000a						sortable.placeholder.remove();\u000a					}\u000a\u000a					// Restore and recalculate the draggable's offset considering the sortable\u000a					// may have modified them in unexpected ways. (#8809, #10669)\u000a					ui.helper.appendTo( draggable._parent );\u000a					draggable._refreshOffsets( event );\u000a					ui.position = draggable._generatePosition( event, true );\u000a\u000a					draggable._trigger( "fromSortable", event );\u000a\u000a					// Inform draggable that the helper is no longer in a valid drop zone\u000a					draggable.dropped = false;\u000a\u000a					// Need to refreshPositions of all sortables just in case removing\u000a					// from one sortable changes the location of other sortables (#9675)\u000a					$.each( draggable.sortables, function() {\u000a						this.refreshPositions();\u000a					});\u000a				}\u000a			}\u000a		});\u000a	}\u000a});\u000a\u000a$.ui.plugin.add("draggable", "cursor", {\u000a	start: function( event, ui, instance ) {\u000a		var t = $( "body" ),\u000a			o = instance.options;\u000a\u000a		if (t.css("cursor")) {\u000a			o._cursor = t.css("cursor");\u000a		}\u000a		t.css("cursor", o.cursor);\u000a	},\u000a	stop: function( event, ui, instance ) {\u000a		var o = instance.options;\u000a		if (o._cursor) {\u000a			$("body").css("cursor", o._cursor);\u000a		}\u000a	}\u000a});\u000a\u000a$.ui.plugin.add("draggable", "opacity", {\u000a	start: function( event, ui, instance ) {\u000a		var t = $( ui.helper ),\u000a			o = instance.options;\u000a		if (t.css("opacity")) {\u000a			o._opacity = t.css("opacity");\u000a		}\u000a		t.css("opacity", o.opacity);\u000a	},\u000a	stop: function( event, ui, instance ) {\u000a		var o = instance.options;\u000a		if (o._opacity) {\u000a			$(ui.helper).css("opacity", o._opacity);\u000a		}\u000a	}\u000a});\u000a\u000a$.ui.plugin.add("draggable", "scroll", {\u000a	start: function( event, ui, i ) {\u000a		if ( !i.scrollParentNotHidden ) {\u000a			i.scrollParentNotHidden = i.helper.scrollParent( false );\u000a		}\u000a\u000a		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {\u000a			i.overflowOffset = i.scrollParentNotHidden.offset();\u000a		}\u000a	},\u000a	drag: function( event, ui, i  ) {\u000a\u000a		var o = i.options,\u000a			scrolled = false,\u000a			scrollParent = i.scrollParentNotHidden[ 0 ],\u000a			document = i.document[ 0 ];\u000a\u000a		if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {\u000a			if ( !o.axis || o.axis !== "x" ) {\u000a				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {\u000a					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;\u000a				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {\u000a					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;\u000a				}\u000a			}\u000a\u000a			if ( !o.axis || o.axis !== "y" ) {\u000a				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {\u000a					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;\u000a				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {\u000a					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;\u000a				}\u000a			}\u000a\u000a		} else {\u000a\u000a			if (!o.axis || o.axis !== "x") {\u000a				if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\u000a					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\u000a				} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\u000a					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\u000a				}\u000a			}\u000a\u000a			if (!o.axis || o.axis !== "y") {\u000a				if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\u000a					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\u000a				} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\u000a					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\u000a				}\u000a			}\u000a\u000a		}\u000a\u000a		if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\u000a			$.ui.ddmanager.prepareOffsets(i, event);\u000a		}\u000a\u000a	}\u000a});\u000a\u000a$.ui.plugin.add("draggable", "snap", {\u000a	start: function( event, ui, i ) {\u000a\u000a		var o = i.options;\u000a\u000a		i.snapElements = [];\u000a\u000a		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {\u000a			var $t = $(this),\u000a				$o = $t.offset();\u000a			if (this !== i.element[0]) {\u000a				i.snapElements.push({\u000a					item: this,\u000a					width: $t.outerWidth(), height: $t.outerHeight(),\u000a					top: $o.top, left: $o.left\u000a				});\u000a			}\u000a		});\u000a\u000a	},\u000a	drag: function( event, ui, inst ) {\u000a\u000a		var ts, bs, ls, rs, l, r, t, b, i, first,\u000a			o = inst.options,\u000a			d = o.snapTolerance,\u000a			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,\u000a			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;\u000a\u000a		for (i = inst.snapElements.length - 1; i >= 0; i--){\u000a\u000a			l = inst.snapElements[i].left - inst.margins.left;\u000a			r = l + inst.snapElements[i].width;\u000a			t = inst.snapElements[i].top - inst.margins.top;\u000a			b = t + inst.snapElements[i].height;\u000a\u000a			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {\u000a				if (inst.snapElements[i].snapping) {\u000a					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\u000a				}\u000a				inst.snapElements[i].snapping = false;\u000a				continue;\u000a			}\u000a\u000a			if (o.snapMode !== "inner") {\u000a				ts = Math.abs(t - y2) <= d;\u000a				bs = Math.abs(b - y1) <= d;\u000a				ls = Math.abs(l - x2) <= d;\u000a				rs = Math.abs(r - x1) <= d;\u000a				if (ts) {\u000a					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;\u000a				}\u000a				if (bs) {\u000a					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;\u000a				}\u000a				if (ls) {\u000a					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;\u000a				}\u000a				if (rs) {\u000a					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;\u000a				}\u000a			}\u000a\u000a			first = (ts || bs || ls || rs);\u000a\u000a			if (o.snapMode !== "outer") {\u000a				ts = Math.abs(t - y1) <= d;\u000a				bs = Math.abs(b - y2) <= d;\u000a				ls = Math.abs(l - x1) <= d;\u000a				rs = Math.abs(r - x2) <= d;\u000a				if (ts) {\u000a					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;\u000a				}\u000a				if (bs) {\u000a					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;\u000a				}\u000a				if (ls) {\u000a					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;\u000a				}\u000a				if (rs) {\u000a					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;\u000a				}\u000a			}\u000a\u000a			if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {\u000a				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\u000a			}\u000a			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);\u000a\u000a		}\u000a\u000a	}\u000a});\u000a\u000a$.ui.plugin.add("draggable", "stack", {\u000a	start: function( event, ui, instance ) {\u000a		var min,\u000a			o = instance.options,\u000a			group = $.makeArray($(o.stack)).sort(function(a, b) {\u000a				return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);\u000a			});\u000a\u000a		if (!group.length) { return; }\u000a\u000a		min = parseInt($(group[0]).css("zIndex"), 10) || 0;\u000a		$(group).each(function(i) {\u000a			$(this).css("zIndex", min + i);\u000a		});\u000a		this.css("zIndex", (min + group.length));\u000a	}\u000a});\u000a\u000a$.ui.plugin.add("draggable", "zIndex", {\u000a	start: function( event, ui, instance ) {\u000a		var t = $( ui.helper ),\u000a			o = instance.options;\u000a\u000a		if (t.css("zIndex")) {\u000a			o._zIndex = t.css("zIndex");\u000a		}\u000a		t.css("zIndex", o.zIndex);\u000a	},\u000a	stop: function( event, ui, instance ) {\u000a		var o = instance.options;\u000a\u000a		if (o._zIndex) {\u000a			$(ui.helper).css("zIndex", o._zIndex);\u000a		}\u000a	}\u000a});\u000a\u000avar draggable = $.ui.draggable;\u000a\u000a\u000a/*!\u000a * jQuery UI Droppable 1.11.4\u000a * http://jqueryui.com\u000a *\u000a * Copyright jQuery Foundation and other contributors\u000a * Released under the MIT license.\u000a * http://jquery.org/license\u000a *\u000a * http://api.jqueryui.com/droppable/\u000a */\u000a\u000a\u000a$.widget( "ui.droppable", {\u000a	version: "1.11.4",\u000a	widgetEventPrefix: "drop",\u000a	options: {\u000a		accept: "*",\u000a		activeClass: false,\u000a		addClasses: true,\u000a		greedy: false,\u000a		hoverClass: false,\u000a		scope: "default",\u000a		tolerance: "intersect",\u000a\u000a		// callbacks\u000a		activate: null,\u000a		deactivate: null,\u000a		drop: null,\u000a		out: null,\u000a		over: null\u000a	},\u000a	_create: function() {\u000a\u000a		var proportions,\u000a			o = this.options,\u000a			accept = o.accept;\u000a\u000a		this.isover = false;\u000a		this.isout = true;\u000a\u000a		this.accept = $.isFunction( accept ) ? accept : function( d ) {\u000a			return d.is( accept );\u000a		};\u000a\u000a		this.proportions = function( /* valueToWrite */ ) {\u000a			if ( arguments.length ) {\u000a				// Store the droppable's proportions\u000a				proportions = arguments[ 0 ];\u000a			} else {\u000a				// Retrieve or derive the droppable's proportions\u000a				return proportions ?\u000a					proportions :\u000a					proportions = {\u000a						width: this.element[ 0 ].offsetWidth,\u000a						height: this.element[ 0 ].offsetHeight\u000a					};\u000a			}\u000a		};\u000a\u000a		this._addToManager( o.scope );\u000a\u000a		o.addClasses && this.element.addClass( "ui-droppable" );\u000a\u000a	},\u000a\u000a	_addToManager: function( scope ) {\u000a		// Add the reference and positions to the manager\u000a		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];\u000a		$.ui.ddmanager.droppables[ scope ].push( this );\u000a	},\u000a\u000a	_splice: function( drop ) {\u000a		var i = 0;\u000a		for ( ; i < drop.length; i++ ) {\u000a			if ( drop[ i ] === this ) {\u000a				drop.splice( i, 1 );\u000a			}\u000a		}\u000a	},\u000a\u000a	_destroy: function() {\u000a		var drop = $.ui.ddmanager.droppables[ this.options.scope ];\u000a\u000a		this._splice( drop );\u000a\u000a		this.element.removeClass( "ui-droppable ui-droppable-disabled" );\u000a	},\u000a\u000a	_setOption: function( key, value ) {\u000a\u000a		if ( key === "accept" ) {\u000a			this.accept = $.isFunction( value ) ? value : function( d ) {\u000a				return d.is( value );\u000a			};\u000a		} else if ( key === "scope" ) {\u000a			var drop = $.ui.ddmanager.droppables[ this.options.scope ];\u000a\u000a			this._splice( drop );\u000a			this._addToManager( value );\u000a		}\u000a\u000a		this._super( key, value );\u000a	},\u000a\u000a	_activate: function( event ) {\u000a		var draggable = $.ui.ddmanager.current;\u000a		if ( this.options.activeClass ) {\u000a			this.element.addClass( this.options.activeClass );\u000a		}\u000a		if ( draggable ){\u000a			this._trigger( "activate", event, this.ui( draggable ) );\u000a		}\u000a	},\u000a\u000a	_deactivate: function( event ) {\u000a		var draggable = $.ui.ddmanager.current;\u000a		if ( this.options.activeClass ) {\u000a			this.element.removeClass( this.options.activeClass );\u000a		}\u000a		if ( draggable ){\u000a			this._trigger( "deactivate", event, this.ui( draggable ) );\u000a		}\u000a	},\u000a\u000a	_over: function( event ) {\u000a\u000a		var draggable = $.ui.ddmanager.current;\u000a\u000a		// Bail if draggable and droppable are same element\u000a		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {\u000a			return;\u000a		}\u000a\u000a		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\u000a			if ( this.options.hoverClass ) {\u000a				this.element.addClass( this.options.hoverClass );\u000a			}\u000a			this._trigger( "over", event, this.ui( draggable ) );\u000a		}\u000a\u000a	},\u000a\u000a	_out: function( event ) {\u000a\u000a		var draggable = $.ui.ddmanager.current;\u000a\u000a		// Bail if draggable and droppable are same element\u000a		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {\u000a			return;\u000a		}\u000a\u000a		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\u000a			if ( this.options.hoverClass ) {\u000a				this.element.removeClass( this.options.hoverClass );\u000a			}\u000a			this._trigger( "out", event, this.ui( draggable ) );\u000a		}\u000a\u000a	},\u000a\u000a	_drop: function( event, custom ) {\u000a\u000a		var draggable = custom || $.ui.ddmanager.current,\u000a			childrenIntersection = false;\u000a\u000a		// Bail if draggable and droppable are same element\u000a		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {\u000a			return false;\u000a		}\u000a\u000a		this.element.find( ":data(ui-droppable)" ).not( ".ui-draggable-dragging" ).each(function() {\u000a			var inst = $( this ).droppable( "instance" );\u000a			if (\u000a				inst.options.greedy &&\u000a				!inst.options.disabled &&\u000a				inst.options.scope === draggable.options.scope &&\u000a				inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&\u000a				$.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance, event )\u000a			) { childrenIntersection = true; return false; }\u000a		});\u000a		if ( childrenIntersection ) {\u000a			return false;\u000a		}\u000a\u000a		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\u000a			if ( this.options.activeClass ) {\u000a				this.element.removeClass( this.options.activeClass );\u000a			}\u000a			if ( this.options.hoverClass ) {\u000a				this.element.removeClass( this.options.hoverClass );\u000a			}\u000a			this._trigger( "drop", event, this.ui( draggable ) );\u000a			return this.element;\u000a		}\u000a\u000a		return false;\u000a\u000a	},\u000a\u000a	ui: function( c ) {\u000a		return {\u000a			draggable: ( c.currentItem || c.element ),\u000a			helper: c.helper,\u000a			position: c.position,\u000a			offset: c.positionAbs\u000a		};\u000a	}\u000a\u000a});\u000a\u000a$.ui.intersect = (function() {\u000a	function isOverAxis( x, reference, size ) {\u000a		return ( x >= reference ) && ( x < ( reference + size ) );\u000a	}\u000a\u000a	return function( draggable, droppable, toleranceMode, event ) {\u000a\u000a		if ( !droppable.offset ) {\u000a			return false;\u000a		}\u000a\u000a		var x1 = ( draggable.positionAbs || draggable.position.absolute ).left + draggable.margins.left,\u000a			y1 = ( draggable.positionAbs || draggable.position.absolute ).top + draggable.margins.top,\u000a			x2 = x1 + draggable.helperProportions.width,\u000a			y2 = y1 + draggable.helperProportions.height,\u000a			l = droppable.offset.left,\u000a			t = droppable.offset.top,\u000a			r = l + droppable.proportions().width,\u000a			b = t + droppable.proportions().height;\u000a\u000a		switch ( toleranceMode ) {\u000a		case "fit":\u000a			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );\u000a		case "intersect":\u000a			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half\u000a				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half\u000a				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half\u000a				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half\u000a		case "pointer":\u000a			return isOverAxis( event.pageY, t, droppable.proportions().height ) && isOverAxis( event.pageX, l, droppable.proportions().width );\u000a		case "touch":\u000a			return (\u000a				( y1 >= t && y1 <= b ) || // Top edge touching\u000a				( y2 >= t && y2 <= b ) || // Bottom edge touching\u000a				( y1 < t && y2 > b ) // Surrounded vertically\u000a			) && (\u000a				( x1 >= l && x1 <= r ) || // Left edge touching\u000a				( x2 >= l && x2 <= r ) || // Right edge touching\u000a				( x1 < l && x2 > r ) // Surrounded horizontally\u000a			);\u000a		default:\u000a			return false;\u000a		}\u000a	};\u000a})();\u000a\u000a/*\u000a	This manager tracks offsets of draggables and droppables\u000a*/\u000a$.ui.ddmanager = {\u000a	current: null,\u000a	droppables: { "default": [] },\u000a	prepareOffsets: function( t, event ) {\u000a\u000a		var i, j,\u000a			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],\u000a			type = event ? event.type : null, // workaround for #2317\u000a			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();\u000a\u000a		droppablesLoop: for ( i = 0; i < m.length; i++ ) {\u000a\u000a			// No disabled and non-accepted\u000a			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {\u000a				continue;\u000a			}\u000a\u000a			// Filter out elements in the current dragged item\u000a			for ( j = 0; j < list.length; j++ ) {\u000a				if ( list[ j ] === m[ i ].element[ 0 ] ) {\u000a					m[ i ].proportions().height = 0;\u000a					continue droppablesLoop;\u000a				}\u000a			}\u000a\u000a			m[ i ].visible = m[ i ].element.css( "display" ) !== "none";\u000a			if ( !m[ i ].visible ) {\u000a				continue;\u000a			}\u000a\u000a			// Activate the droppable if used directly from draggables\u000a			if ( type === "mousedown" ) {\u000a				m[ i ]._activate.call( m[ i ], event );\u000a			}\u000a\u000a			m[ i ].offset = m[ i ].element.offset();\u000a			m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });\u000a\u000a		}\u000a\u000a	},\u000a	drop: function( draggable, event ) {\u000a\u000a		var dropped = false;\u000a		// Create a copy of the droppables in case the list changes during the drop (#9116)\u000a		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {\u000a\u000a			if ( !this.options ) {\u000a				return;\u000a			}\u000a			if ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance, event ) ) {\u000a				dropped = this._drop.call( this, event ) || dropped;\u000a			}\u000a\u000a			if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\u000a				this.isout = true;\u000a				this.isover = false;\u000a				this._deactivate.call( this, event );\u000a			}\u000a\u000a		});\u000a		return dropped;\u000a\u000a	},\u000a	dragStart: function( draggable, event ) {\u000a		// Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)\u000a		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {\u000a			if ( !draggable.options.refreshPositions ) {\u000a				$.ui.ddmanager.prepareOffsets( draggable, event );\u000a			}\u000a		});\u000a	},\u000a	drag: function( draggable, event ) {\u000a\u000a		// If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.\u000a		if ( draggable.options.refreshPositions ) {\u000a			$.ui.ddmanager.prepareOffsets( draggable, event );\u000a		}\u000a\u000a		// Run through all droppables and check their positions based on specific tolerance options\u000a		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {\u000a\u000a			if ( this.options.disabled || this.greedyChild || !this.visible ) {\u000a				return;\u000a			}\u000a\u000a			var parentInstance, scope, parent,\u000a				intersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),\u000a				c = !intersects && this.isover ? "isout" : ( intersects && !this.isover ? "isover" : null );\u000a			if ( !c ) {\u000a				return;\u000a			}\u000a\u000a			if ( this.options.greedy ) {\u000a				// find droppable parents with same scope\u000a				scope = this.options.scope;\u000a				parent = this.element.parents( ":data(ui-droppable)" ).filter(function() {\u000a					return $( this ).droppable( "instance" ).options.scope === scope;\u000a				});\u000a\u000a				if ( parent.length ) {\u000a					parentInstance = $( parent[ 0 ] ).droppable( "instance" );\u000a					parentInstance.greedyChild = ( c === "isover" );\u000a				}\u000a			}\u000a\u000a			// we just moved into a greedy child\u000a			if ( parentInstance && c === "isover" ) {\u000a				parentInstance.isover = false;\u000a				parentInstance.isout = true;\u000a				parentInstance._out.call( parentInstance, event );\u000a			}\u000a\u000a			this[ c ] = true;\u000a			this[c === "isout" ? "isover" : "isout"] = false;\u000a			this[c === "isover" ? "_over" : "_out"].call( this, event );\u000a\u000a			// we just moved out of a greedy child\u000a			if ( parentInstance && c === "isout" ) {\u000a				parentInstance.isout = false;\u000a				parentInstance.isover = true;\u000a				parentInstance._over.call( parentInstance, event );\u000a			}\u000a		});\u000a\u000a	},\u000a	dragStop: function( draggable, event ) {\u000a		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );\u000a		// Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)\u000a		if ( !draggable.options.refreshPositions ) {\u000a			$.ui.ddmanager.prepareOffsets( draggable, event );\u000a		}\u000a	}\u000a};\u000a\u000avar droppable = $.ui.droppable;\u000a\u000a\u000a/*!\u000a * jQuery UI Sortable 1.11.4\u000a * http://jqueryui.com\u000a *\u000a * Copyright jQuery Foundation and other contributors\u000a * Released under the MIT license.\u000a * http://jquery.org/license\u000a *\u000a * http://api.jqueryui.com/sortable/\u000a */\u000a\u000a\u000avar sortable = $.widget("ui.sortable", $.ui.mouse, {\u000a	version: "1.11.4",\u000a	widgetEventPrefix: "sort",\u000a	ready: false,\u000a	options: {\u000a		appendTo: "parent",\u000a		axis: false,\u000a		connectWith: false,\u000a		containment: false,\u000a		cursor: "auto",\u000a		cursorAt: false,\u000a		dropOnEmpty: true,\u000a		forcePlaceholderSize: false,\u000a		forceHelperSize: false,\u000a		grid: false,\u000a		handle: false,\u000a		helper: "original",\u000a		items: "> *",\u000a		opacity: false,\u000a		placeholder: false,\u000a		revert: false,\u000a		scroll: true,\u000a		scrollSensitivity: 20,\u000a		scrollSpeed: 20,\u000a		scope: "default",\u000a		tolerance: "intersect",\u000a		zIndex: 1000,\u000a\u000a		// callbacks\u000a		activate: null,\u000a		beforeStop: null,\u000a		change: null,\u000a		deactivate: null,\u000a		out: null,\u000a		over: null,\u000a		receive: null,\u000a		remove: null,\u000a		sort: null,\u000a		start: null,\u000a		stop: null,\u000a		update: null\u000a	},\u000a\u000a	_isOverAxis: function( x, reference, size ) {\u000a		return ( x >= reference ) && ( x < ( reference + size ) );\u000a	},\u000a\u000a	_isFloating: function( item ) {\u000a		return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));\u000a	},\u000a\u000a	_create: function() {\u000a		this.containerCache = {};\u000a		this.element.addClass("ui-sortable");\u000a\u000a		//Get the items\u000a		this.refresh();\u000a\u000a		//Let's determine the parent's offset\u000a		this.offset = this.element.offset();\u000a\u000a		//Initialize mouse events for interaction\u000a		this._mouseInit();\u000a\u000a		this._setHandleClassName();\u000a\u000a		//We're ready to go\u000a		this.ready = true;\u000a\u000a	},\u000a\u000a	_setOption: function( key, value ) {\u000a		this._super( key, value );\u000a\u000a		if ( key === "handle" ) {\u000a			this._setHandleClassName();\u000a		}\u000a	},\u000a\u000a	_setHandleClassName: function() {\u000a		this.element.find( ".ui-sortable-handle" ).removeClass( "ui-sortable-handle" );\u000a		$.each( this.items, function() {\u000a			( this.instance.options.handle ?\u000a				this.item.find( this.instance.options.handle ) : this.item )\u000a				.addClass( "ui-sortable-handle" );\u000a		});\u000a	},\u000a\u000a	_destroy: function() {\u000a		this.element\u000a			.removeClass( "ui-sortable ui-sortable-disabled" )\u000a			.find( ".ui-sortable-handle" )\u000a				.removeClass( "ui-sortable-handle" );\u000a		this._mouseDestroy();\u000a\u000a		for ( var i = this.items.length - 1; i >= 0; i-- ) {\u000a			this.items[i].item.removeData(this.widgetName + "-item");\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	_mouseCapture: function(event, overrideHandle) {\u000a		var currentItem = null,\u000a			validHandle = false,\u000a			that = this;\u000a\u000a		if (this.reverting) {\u000a			return false;\u000a		}\u000a\u000a		if(this.options.disabled || this.options.type === "static") {\u000a			return false;\u000a		}\u000a\u000a		//We have to refresh the items data once first\u000a		this._refreshItems(event);\u000a\u000a		//Find out if the clicked node (or one of its parents) is a actual item in this.items\u000a		$(event.target).parents().each(function() {\u000a			if($.data(this, that.widgetName + "-item") === that) {\u000a				currentItem = $(this);\u000a				return false;\u000a			}\u000a		});\u000a		if($.data(event.target, that.widgetName + "-item") === that) {\u000a			currentItem = $(event.target);\u000a		}\u000a\u000a		if(!currentItem) {\u000a			return false;\u000a		}\u000a		if(this.options.handle && !overrideHandle) {\u000a			$(this.options.handle, currentItem).find("*").addBack().each(function() {\u000a				if(this === event.target) {\u000a					validHandle = true;\u000a				}\u000a			});\u000a			if(!validHandle) {\u000a				return false;\u000a			}\u000a		}\u000a\u000a		this.currentItem = currentItem;\u000a		this._removeCurrentsFromItems();\u000a		return true;\u000a\u000a	},\u000a\u000a	_mouseStart: function(event, overrideHandle, noActivation) {\u000a\u000a		var i, body,\u000a			o = this.options;\u000a\u000a		this.currentContainer = this;\u000a\u000a		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture\u000a		this.refreshPositions();\u000a\u000a		//Create and append the visible helper\u000a		this.helper = this._createHelper(event);\u000a\u000a		//Cache the helper size\u000a		this._cacheHelperProportions();\u000a\u000a		/*\u000a		 * - Position generation -\u000a		 * This block generates everything position related - it's the core of draggables.\u000a		 */\u000a\u000a		//Cache the margins of the original element\u000a		this._cacheMargins();\u000a\u000a		//Get the next scrolling parent\u000a		this.scrollParent = this.helper.scrollParent();\u000a\u000a		//The element's absolute position on the page minus margins\u000a		this.offset = this.currentItem.offset();\u000a		this.offset = {\u000a			top: this.offset.top - this.margins.top,\u000a			left: this.offset.left - this.margins.left\u000a		};\u000a\u000a		$.extend(this.offset, {\u000a			click: { //Where the click happened, relative to the element\u000a				left: event.pageX - this.offset.left,\u000a				top: event.pageY - this.offset.top\u000a			},\u000a			parent: this._getParentOffset(),\u000a			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\u000a		});\u000a\u000a		// Only after we got the offset, we can change the helper's position to absolute\u000a		// TODO: Still need to figure out a way to make relative sorting possible\u000a		this.helper.css("position", "absolute");\u000a		this.cssPosition = this.helper.css("position");\u000a\u000a		//Generate the original position\u000a		this.originalPosition = this._generatePosition(event);\u000a		this.originalPageX = event.pageX;\u000a		this.originalPageY = event.pageY;\u000a\u000a		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied\u000a		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\u000a\u000a		//Cache the former DOM position\u000a		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };\u000a\u000a		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way\u000a		if(this.helper[0] !== this.currentItem[0]) {\u000a			this.currentItem.hide();\u000a		}\u000a\u000a		//Create the placeholder\u000a		this._createPlaceholder();\u000a\u000a		//Set a containment if given in the options\u000a		if(o.containment) {\u000a			this._setContainment();\u000a		}\u000a\u000a		if( o.cursor && o.cursor !== "auto" ) { // cursor option\u000a			body = this.document.find( "body" );\u000a\u000a			// support: IE\u000a			this.storedCursor = body.css( "cursor" );\u000a			body.css( "cursor", o.cursor );\u000a\u000a			this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );\u000a		}\u000a\u000a		if(o.opacity) { // opacity option\u000a			if (this.helper.css("opacity")) {\u000a				this._storedOpacity = this.helper.css("opacity");\u000a			}\u000a			this.helper.css("opacity", o.opacity);\u000a		}\u000a\u000a		if(o.zIndex) { // zIndex option\u000a			if (this.helper.css("zIndex")) {\u000a				this._storedZIndex = this.helper.css("zIndex");\u000a			}\u000a			this.helper.css("zIndex", o.zIndex);\u000a		}\u000a\u000a		//Prepare scrolling\u000a		if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {\u000a			this.overflowOffset = this.scrollParent.offset();\u000a		}\u000a\u000a		//Call callbacks\u000a		this._trigger("start", event, this._uiHash());\u000a\u000a		//Recache the helper size\u000a		if(!this._preserveHelperProportions) {\u000a			this._cacheHelperProportions();\u000a		}\u000a\u000a\u000a		//Post "activate" events to possible containers\u000a		if( !noActivation ) {\u000a			for ( i = this.containers.length - 1; i >= 0; i-- ) {\u000a				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );\u000a			}\u000a		}\u000a\u000a		//Prepare possible droppables\u000a		if($.ui.ddmanager) {\u000a			$.ui.ddmanager.current = this;\u000a		}\u000a\u000a		if ($.ui.ddmanager && !o.dropBehaviour) {\u000a			$.ui.ddmanager.prepareOffsets(this, event);\u000a		}\u000a\u000a		this.dragging = true;\u000a\u000a		this.helper.addClass("ui-sortable-helper");\u000a		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position\u000a		return true;\u000a\u000a	},\u000a\u000a	_mouseDrag: function(event) {\u000a		var i, item, itemElement, intersection,\u000a			o = this.options,\u000a			scrolled = false;\u000a\u000a		//Compute the helpers position\u000a		this.position = this._generatePosition(event);\u000a		this.positionAbs = this._convertPositionTo("absolute");\u000a\u000a		if (!this.lastPositionAbs) {\u000a			this.lastPositionAbs = this.positionAbs;\u000a		}\u000a\u000a		//Do scrolling\u000a		if(this.options.scroll) {\u000a			if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {\u000a\u000a				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {\u000a					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\u000a				} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {\u000a					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\u000a				}\u000a\u000a				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {\u000a					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\u000a				} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {\u000a					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\u000a				}\u000a\u000a			} else {\u000a\u000a				if(event.pageY - this.document.scrollTop() < o.scrollSensitivity) {\u000a					scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);\u000a				} else if(this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {\u000a					scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);\u000a				}\u000a\u000a				if(event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {\u000a					scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);\u000a				} else if(this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {\u000a					scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);\u000a				}\u000a\u000a			}\u000a\u000a			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\u000a				$.ui.ddmanager.prepareOffsets(this, event);\u000a			}\u000a		}\u000a\u000a		//Regenerate the absolute position used for position checks\u000a		this.positionAbs = this._convertPositionTo("absolute");\u000a\u000a		//Set the helper position\u000a		if(!this.options.axis || this.options.axis !== "y") {\u000a			this.helper[0].style.left = this.position.left+"px";\u000a		}\u000a		if(!this.options.axis || this.options.axis !== "x") {\u000a			this.helper[0].style.top = this.position.top+"px";\u000a		}\u000a\u000a		//Rearrange\u000a		for (i = this.items.length - 1; i >= 0; i--) {\u000a\u000a			//Cache variables and intersection, continue if no intersection\u000a			item = this.items[i];\u000a			itemElement = item.item[0];\u000a			intersection = this._intersectsWithPointer(item);\u000a			if (!intersection) {\u000a				continue;\u000a			}\u000a\u000a			// Only put the placeholder inside the current Container, skip all\u000a			// items from other containers. This works because when moving\u000a			// an item from one container to another the\u000a			// currentContainer is switched before the placeholder is moved.\u000a			//\u000a			// Without this, moving items in "sub-sortables" can cause\u000a			// the placeholder to jitter between the outer and inner container.\u000a			if (item.instance !== this.currentContainer) {\u000a				continue;\u000a			}\u000a\u000a			// cannot intersect with itself\u000a			// no useless actions that have been done before\u000a			// no action if the item moved is the parent of the item checked\u000a			if (itemElement !== this.currentItem[0] &&\u000a				this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&\u000a				!$.contains(this.placeholder[0], itemElement) &&\u000a				(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)\u000a			) {\u000a\u000a				this.direction = intersection === 1 ? "down" : "up";\u000a\u000a				if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {\u000a					this._rearrange(event, item);\u000a				} else {\u000a					break;\u000a				}\u000a\u000a				this._trigger("change", event, this._uiHash());\u000a				break;\u000a			}\u000a		}\u000a\u000a		//Post events to containers\u000a		this._contactContainers(event);\u000a\u000a		//Interconnect with droppables\u000a		if($.ui.ddmanager) {\u000a			$.ui.ddmanager.drag(this, event);\u000a		}\u000a\u000a		//Call callbacks\u000a		this._trigger("sort", event, this._uiHash());\u000a\u000a		this.lastPositionAbs = this.positionAbs;\u000a		return false;\u000a\u000a	},\u000a\u000a	_mouseStop: function(event, noPropagation) {\u000a\u000a		if(!event) {\u000a			return;\u000a		}\u000a\u000a		//If we are using droppables, inform the manager about the drop\u000a		if ($.ui.ddmanager && !this.options.dropBehaviour) {\u000a			$.ui.ddmanager.drop(this, event);\u000a		}\u000a\u000a		if(this.options.revert) {\u000a			var that = this,\u000a				cur = this.placeholder.offset(),\u000a				axis = this.options.axis,\u000a				animation = {};\u000a\u000a			if ( !axis || axis === "x" ) {\u000a				animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);\u000a			}\u000a			if ( !axis || axis === "y" ) {\u000a				animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);\u000a			}\u000a			this.reverting = true;\u000a			$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {\u000a				that._clear(event);\u000a			});\u000a		} else {\u000a			this._clear(event, noPropagation);\u000a		}\u000a\u000a		return false;\u000a\u000a	},\u000a\u000a	cancel: function() {\u000a\u000a		if(this.dragging) {\u000a\u000a			this._mouseUp({ target: null });\u000a\u000a			if(this.options.helper === "original") {\u000a				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");\u000a			} else {\u000a				this.currentItem.show();\u000a			}\u000a\u000a			//Post deactivating events to containers\u000a			for (var i = this.containers.length - 1; i >= 0; i--){\u000a				this.containers[i]._trigger("deactivate", null, this._uiHash(this));\u000a				if(this.containers[i].containerCache.over) {\u000a					this.containers[i]._trigger("out", null, this._uiHash(this));\u000a					this.containers[i].containerCache.over = 0;\u000a				}\u000a			}\u000a\u000a		}\u000a\u000a		if (this.placeholder) {\u000a			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\u000a			if(this.placeholder[0].parentNode) {\u000a				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\u000a			}\u000a			if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {\u000a				this.helper.remove();\u000a			}\u000a\u000a			$.extend(this, {\u000a				helper: null,\u000a				dragging: false,\u000a				reverting: false,\u000a				_noFinalSort: null\u000a			});\u000a\u000a			if(this.domPosition.prev) {\u000a				$(this.domPosition.prev).after(this.currentItem);\u000a			} else {\u000a				$(this.domPosition.parent).prepend(this.currentItem);\u000a			}\u000a		}\u000a\u000a		return this;\u000a\u000a	},\u000a\u000a	serialize: function(o) {\u000a\u000a		var items = this._getItemsAsjQuery(o && o.connected),\u000a			str = [];\u000a		o = o || {};\u000a\u000a		$(items).each(function() {\u000a			var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\u005c-=_](.+)/));\u000a			if (res) {\u000a				str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));\u000a			}\u000a		});\u000a\u000a		if(!str.length && o.key) {\u000a			str.push(o.key + "=");\u000a		}\u000a\u000a		return str.join("&");\u000a\u000a	},\u000a\u000a	toArray: function(o) {\u000a\u000a		var items = this._getItemsAsjQuery(o && o.connected),\u000a			ret = [];\u000a\u000a		o = o || {};\u000a\u000a		items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });\u000a		return ret;\u000a\u000a	},\u000a\u000a	/* Be careful with the following core functions */\u000a	_intersectsWith: function(item) {\u000a\u000a		var x1 = this.positionAbs.left,\u000a			x2 = x1 + this.helperProportions.width,\u000a			y1 = this.positionAbs.top,\u000a			y2 = y1 + this.helperProportions.height,\u000a			l = item.left,\u000a			r = l + item.width,\u000a			t = item.top,\u000a			b = t + item.height,\u000a			dyClick = this.offset.click.top,\u000a			dxClick = this.offset.click.left,\u000a			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),\u000a			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),\u000a			isOverElement = isOverElementHeight && isOverElementWidth;\u000a\u000a		if ( this.options.tolerance === "pointer" ||\u000a			this.options.forcePointerForContainers ||\u000a			(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])\u000a		) {\u000a			return isOverElement;\u000a		} else {\u000a\u000a			return (l < x1 + (this.helperProportions.width / 2) && // Right Half\u000a				x2 - (this.helperProportions.width / 2) < r && // Left Half\u000a				t < y1 + (this.helperProportions.height / 2) && // Bottom Half\u000a				y2 - (this.helperProportions.height / 2) < b ); // Top Half\u000a\u000a		}\u000a	},\u000a\u000a	_intersectsWithPointer: function(item) {\u000a\u000a		var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),\u000a			isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),\u000a			isOverElement = isOverElementHeight && isOverElementWidth,\u000a			verticalDirection = this._getDragVerticalDirection(),\u000a			horizontalDirection = this._getDragHorizontalDirection();\u000a\u000a		if (!isOverElement) {\u000a			return false;\u000a		}\u000a\u000a		return this.floating ?\u000a			( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )\u000a			: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );\u000a\u000a	},\u000a\u000a	_intersectsWithSides: function(item) {\u000a\u000a		var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),\u000a			isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),\u000a			verticalDirection = this._getDragVerticalDirection(),\u000a			horizontalDirection = this._getDragHorizontalDirection();\u000a\u000a		if (this.floating && horizontalDirection) {\u000a			return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));\u000a		} else {\u000a			return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));\u000a		}\u000a\u000a	},\u000a\u000a	_getDragVerticalDirection: function() {\u000a		var delta = this.positionAbs.top - this.lastPositionAbs.top;\u000a		return delta !== 0 && (delta > 0 ? "down" : "up");\u000a	},\u000a\u000a	_getDragHorizontalDirection: function() {\u000a		var delta = this.positionAbs.left - this.lastPositionAbs.left;\u000a		return delta !== 0 && (delta > 0 ? "right" : "left");\u000a	},\u000a\u000a	refresh: function(event) {\u000a		this._refreshItems(event);\u000a		this._setHandleClassName();\u000a		this.refreshPositions();\u000a		return this;\u000a	},\u000a\u000a	_connectWith: function() {\u000a		var options = this.options;\u000a		return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;\u000a	},\u000a\u000a	_getItemsAsjQuery: function(connected) {\u000a\u000a		var i, j, cur, inst,\u000a			items = [],\u000a			queries = [],\u000a			connectWith = this._connectWith();\u000a\u000a		if(connectWith && connected) {\u000a			for (i = connectWith.length - 1; i >= 0; i--){\u000a				cur = $(connectWith[i], this.document[0]);\u000a				for ( j = cur.length - 1; j >= 0; j--){\u000a					inst = $.data(cur[j], this.widgetFullName);\u000a					if(inst && inst !== this && !inst.options.disabled) {\u000a						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);\u000a\u000a		function addItems() {\u000a			items.push( this );\u000a		}\u000a		for (i = queries.length - 1; i >= 0; i--){\u000a			queries[i][0].each( addItems );\u000a		}\u000a\u000a		return $(items);\u000a\u000a	},\u000a\u000a	_removeCurrentsFromItems: function() {\u000a\u000a		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");\u000a\u000a		this.items = $.grep(this.items, function (item) {\u000a			for (var j=0; j < list.length; j++) {\u000a				if(list[j] === item.item[0]) {\u000a					return false;\u000a				}\u000a			}\u000a			return true;\u000a		});\u000a\u000a	},\u000a\u000a	_refreshItems: function(event) {\u000a\u000a		this.items = [];\u000a		this.containers = [this];\u000a\u000a		var i, j, cur, inst, targetData, _queries, item, queriesLength,\u000a			items = this.items,\u000a			queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],\u000a			connectWith = this._connectWith();\u000a\u000a		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down\u000a			for (i = connectWith.length - 1; i >= 0; i--){\u000a				cur = $(connectWith[i], this.document[0]);\u000a				for (j = cur.length - 1; j >= 0; j--){\u000a					inst = $.data(cur[j], this.widgetFullName);\u000a					if(inst && inst !== this && !inst.options.disabled) {\u000a						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);\u000a						this.containers.push(inst);\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		for (i = queries.length - 1; i >= 0; i--) {\u000a			targetData = queries[i][1];\u000a			_queries = queries[i][0];\u000a\u000a			for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {\u000a				item = $(_queries[j]);\u000a\u000a				item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)\u000a\u000a				items.push({\u000a					item: item,\u000a					instance: targetData,\u000a					width: 0, height: 0,\u000a					left: 0, top: 0\u000a				});\u000a			}\u000a		}\u000a\u000a	},\u000a\u000a	refreshPositions: function(fast) {\u000a\u000a		// Determine whether items are being displayed horizontally\u000a		this.floating = this.items.length ?\u000a			this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :\u000a			false;\u000a\u000a		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change\u000a		if(this.offsetParent && this.helper) {\u000a			this.offset.parent = this._getParentOffset();\u000a		}\u000a\u000a		var i, item, t, p;\u000a\u000a		for (i = this.items.length - 1; i >= 0; i--){\u000a			item = this.items[i];\u000a\u000a			//We ignore calculating positions of all connected containers when we're not over them\u000a			if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {\u000a				continue;\u000a			}\u000a\u000a			t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;\u000a\u000a			if (!fast) {\u000a				item.width = t.outerWidth();\u000a				item.height = t.outerHeight();\u000a			}\u000a\u000a			p = t.offset();\u000a			item.left = p.left;\u000a			item.top = p.top;\u000a		}\u000a\u000a		if(this.options.custom && this.options.custom.refreshContainers) {\u000a			this.options.custom.refreshContainers.call(this);\u000a		} else {\u000a			for (i = this.containers.length - 1; i >= 0; i--){\u000a				p = this.containers[i].element.offset();\u000a				this.containers[i].containerCache.left = p.left;\u000a				this.containers[i].containerCache.top = p.top;\u000a				this.containers[i].containerCache.width = this.containers[i].element.outerWidth();\u000a				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();\u000a			}\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	_createPlaceholder: function(that) {\u000a		that = that || this;\u000a		var className,\u000a			o = that.options;\u000a\u000a		if(!o.placeholder || o.placeholder.constructor === String) {\u000a			className = o.placeholder;\u000a			o.placeholder = {\u000a				element: function() {\u000a\u000a					var nodeName = that.currentItem[0].nodeName.toLowerCase(),\u000a						element = $( "<" + nodeName + ">", that.document[0] )\u000a							.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")\u000a							.removeClass("ui-sortable-helper");\u000a\u000a					if ( nodeName === "tbody" ) {\u000a						that._createTrPlaceholder(\u000a							that.currentItem.find( "tr" ).eq( 0 ),\u000a							$( "<tr>", that.document[ 0 ] ).appendTo( element )\u000a						);\u000a					} else if ( nodeName === "tr" ) {\u000a						that._createTrPlaceholder( that.currentItem, element );\u000a					} else if ( nodeName === "img" ) {\u000a						element.attr( "src", that.currentItem.attr( "src" ) );\u000a					}\u000a\u000a					if ( !className ) {\u000a						element.css( "visibility", "hidden" );\u000a					}\u000a\u000a					return element;\u000a				},\u000a				update: function(container, p) {\u000a\u000a					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that\u000a					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified\u000a					if(className && !o.forcePlaceholderSize) {\u000a						return;\u000a					}\u000a\u000a					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item\u000a					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }\u000a					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }\u000a				}\u000a			};\u000a		}\u000a\u000a		//Create the placeholder\u000a		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));\u000a\u000a		//Append it after the actual current item\u000a		that.currentItem.after(that.placeholder);\u000a\u000a		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)\u000a		o.placeholder.update(that, that.placeholder);\u000a\u000a	},\u000a\u000a	_createTrPlaceholder: function( sourceTr, targetTr ) {\u000a		var that = this;\u000a\u000a		sourceTr.children().each(function() {\u000a			$( "<td>&#160;</td>", that.document[ 0 ] )\u000a				.attr( "colspan", $( this ).attr( "colspan" ) || 1 )\u000a				.appendTo( targetTr );\u000a		});\u000a	},\u000a\u000a	_contactContainers: function(event) {\u000a		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,\u000a			innermostContainer = null,\u000a			innermostIndex = null;\u000a\u000a		// get innermost container that intersects with item\u000a		for (i = this.containers.length - 1; i >= 0; i--) {\u000a\u000a			// never consider a container that's located within the item itself\u000a			if($.contains(this.currentItem[0], this.containers[i].element[0])) {\u000a				continue;\u000a			}\u000a\u000a			if(this._intersectsWith(this.containers[i].containerCache)) {\u000a\u000a				// if we've already found a container and it's more "inner" than this, then continue\u000a				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {\u000a					continue;\u000a				}\u000a\u000a				innermostContainer = this.containers[i];\u000a				innermostIndex = i;\u000a\u000a			} else {\u000a				// container doesn't intersect. trigger "out" event if necessary\u000a				if(this.containers[i].containerCache.over) {\u000a					this.containers[i]._trigger("out", event, this._uiHash(this));\u000a					this.containers[i].containerCache.over = 0;\u000a				}\u000a			}\u000a\u000a		}\u000a\u000a		// if no intersecting containers found, return\u000a		if(!innermostContainer) {\u000a			return;\u000a		}\u000a\u000a		// move the item into the container if it's not there already\u000a		if(this.containers.length === 1) {\u000a			if (!this.containers[innermostIndex].containerCache.over) {\u000a				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));\u000a				this.containers[innermostIndex].containerCache.over = 1;\u000a			}\u000a		} else {\u000a\u000a			//When entering a new container, we will find the item with the least distance and append our item near it\u000a			dist = 10000;\u000a			itemWithLeastDistance = null;\u000a			floating = innermostContainer.floating || this._isFloating(this.currentItem);\u000a			posProperty = floating ? "left" : "top";\u000a			sizeProperty = floating ? "width" : "height";\u000a			axis = floating ? "clientX" : "clientY";\u000a\u000a			for (j = this.items.length - 1; j >= 0; j--) {\u000a				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {\u000a					continue;\u000a				}\u000a				if(this.items[j].item[0] === this.currentItem[0]) {\u000a					continue;\u000a				}\u000a\u000a				cur = this.items[j].item.offset()[posProperty];\u000a				nearBottom = false;\u000a				if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {\u000a					nearBottom = true;\u000a				}\u000a\u000a				if ( Math.abs( event[ axis ] - cur ) < dist ) {\u000a					dist = Math.abs( event[ axis ] - cur );\u000a					itemWithLeastDistance = this.items[ j ];\u000a					this.direction = nearBottom ? "up": "down";\u000a				}\u000a			}\u000a\u000a			//Check if dropOnEmpty is enabled\u000a			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {\u000a				return;\u000a			}\u000a\u000a			if(this.currentContainer === this.containers[innermostIndex]) {\u000a				if ( !this.currentContainer.containerCache.over ) {\u000a					this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );\u000a					this.currentContainer.containerCache.over = 1;\u000a				}\u000a				return;\u000a			}\u000a\u000a			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);\u000a			this._trigger("change", event, this._uiHash());\u000a			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));\u000a			this.currentContainer = this.containers[innermostIndex];\u000a\u000a			//Update the placeholder\u000a			this.options.placeholder.update(this.currentContainer, this.placeholder);\u000a\u000a			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));\u000a			this.containers[innermostIndex].containerCache.over = 1;\u000a		}\u000a\u000a\u000a	},\u000a\u000a	_createHelper: function(event) {\u000a\u000a		var o = this.options,\u000a			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);\u000a\u000a		//Add the helper to the DOM if that didn't happen already\u000a		if(!helper.parents("body").length) {\u000a			$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);\u000a		}\u000a\u000a		if(helper[0] === this.currentItem[0]) {\u000a			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };\u000a		}\u000a\u000a		if(!helper[0].style.width || o.forceHelperSize) {\u000a			helper.width(this.currentItem.width());\u000a		}\u000a		if(!helper[0].style.height || o.forceHelperSize) {\u000a			helper.height(this.currentItem.height());\u000a		}\u000a\u000a		return helper;\u000a\u000a	},\u000a\u000a	_adjustOffsetFromHelper: function(obj) {\u000a		if (typeof obj === "string") {\u000a			obj = obj.split(" ");\u000a		}\u000a		if ($.isArray(obj)) {\u000a			obj = {left: +obj[0], top: +obj[1] || 0};\u000a		}\u000a		if ("left" in obj) {\u000a			this.offset.click.left = obj.left + this.margins.left;\u000a		}\u000a		if ("right" in obj) {\u000a			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\u000a		}\u000a		if ("top" in obj) {\u000a			this.offset.click.top = obj.top + this.margins.top;\u000a		}\u000a		if ("bottom" in obj) {\u000a			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\u000a		}\u000a	},\u000a\u000a	_getParentOffset: function() {\u000a\u000a\u000a		//Get the offsetParent and cache its position\u000a		this.offsetParent = this.helper.offsetParent();\u000a		var po = this.offsetParent.offset();\u000a\u000a		// This is a special case where we need to modify a offset calculated on start, since the following happened:\u000a		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\u000a		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\u000a		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\u000a		if(this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {\u000a			po.left += this.scrollParent.scrollLeft();\u000a			po.top += this.scrollParent.scrollTop();\u000a		}\u000a\u000a		// This needs to be actually done for all browsers, since pageX/pageY includes this information\u000a		// with an ugly IE fix\u000a		if( this.offsetParent[0] === this.document[0].body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {\u000a			po = { top: 0, left: 0 };\u000a		}\u000a\u000a		return {\u000a			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),\u000a			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)\u000a		};\u000a\u000a	},\u000a\u000a	_getRelativeOffset: function() {\u000a\u000a		if(this.cssPosition === "relative") {\u000a			var p = this.currentItem.position();\u000a			return {\u000a				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),\u000a				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()\u000a			};\u000a		} else {\u000a			return { top: 0, left: 0 };\u000a		}\u000a\u000a	},\u000a\u000a	_cacheMargins: function() {\u000a		this.margins = {\u000a			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),\u000a			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)\u000a		};\u000a	},\u000a\u000a	_cacheHelperProportions: function() {\u000a		this.helperProportions = {\u000a			width: this.helper.outerWidth(),\u000a			height: this.helper.outerHeight()\u000a		};\u000a	},\u000a\u000a	_setContainment: function() {\u000a\u000a		var ce, co, over,\u000a			o = this.options;\u000a		if(o.containment === "parent") {\u000a			o.containment = this.helper[0].parentNode;\u000a		}\u000a		if(o.containment === "document" || o.containment === "window") {\u000a			this.containment = [\u000a				0 - this.offset.relative.left - this.offset.parent.left,\u000a				0 - this.offset.relative.top - this.offset.parent.top,\u000a				o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left,\u000a				(o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top\u000a			];\u000a		}\u000a\u000a		if(!(/^(document|window|parent)$/).test(o.containment)) {\u000a			ce = $(o.containment)[0];\u000a			co = $(o.containment).offset();\u000a			over = ($(ce).css("overflow") !== "hidden");\u000a\u000a			this.containment = [\u000a				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,\u000a				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,\u000a				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,\u000a				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top\u000a			];\u000a		}\u000a\u000a	},\u000a\u000a	_convertPositionTo: function(d, pos) {\u000a\u000a		if(!pos) {\u000a			pos = this.position;\u000a		}\u000a		var mod = d === "absolute" ? 1 : -1,\u000a			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\u000a			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\u000a\u000a		return {\u000a			top: (\u000a				pos.top	+																// The absolute mouse position\u000a				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)\u000a				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)\u000a			),\u000a			left: (\u000a				pos.left +																// The absolute mouse position\u000a				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)\u000a				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)\u000a			)\u000a		};\u000a\u000a	},\u000a\u000a	_generatePosition: function(event) {\u000a\u000a		var top, left,\u000a			o = this.options,\u000a			pageX = event.pageX,\u000a			pageY = event.pageY,\u000a			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\u000a\u000a		// This is another very weird special case that only happens for relative elements:\u000a		// 1. If the css position is relative\u000a		// 2. and the scroll parent is the document or similar to the offset parent\u000a		// we have to refresh the relative offset during the scroll so there are no jumps\u000a		if(this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {\u000a			this.offset.relative = this._getRelativeOffset();\u000a		}\u000a\u000a		/*\u000a		 * - Position constraining -\u000a		 * Constrain the position to a mix of grid, containment.\u000a		 */\u000a\u000a		if(this.originalPosition) { //If we are not dragging yet, we won't check for options\u000a\u000a			if(this.containment) {\u000a				if(event.pageX - this.offset.click.left < this.containment[0]) {\u000a					pageX = this.containment[0] + this.offset.click.left;\u000a				}\u000a				if(event.pageY - this.offset.click.top < this.containment[1]) {\u000a					pageY = this.containment[1] + this.offset.click.top;\u000a				}\u000a				if(event.pageX - this.offset.click.left > this.containment[2]) {\u000a					pageX = this.containment[2] + this.offset.click.left;\u000a				}\u000a				if(event.pageY - this.offset.click.top > this.containment[3]) {\u000a					pageY = this.containment[3] + this.offset.click.top;\u000a				}\u000a			}\u000a\u000a			if(o.grid) {\u000a				top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];\u000a				pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\u000a\u000a				left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];\u000a				pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\u000a			}\u000a\u000a		}\u000a\u000a		return {\u000a			top: (\u000a				pageY -																// The absolute mouse position\u000a				this.offset.click.top -													// Click offset (relative to the element)\u000a				this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)\u000a				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))\u000a			),\u000a			left: (\u000a				pageX -																// The absolute mouse position\u000a				this.offset.click.left -												// Click offset (relative to the element)\u000a				this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent\u000a				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)\u000a				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))\u000a			)\u000a		};\u000a\u000a	},\u000a\u000a	_rearrange: function(event, i, a, hardRefresh) {\u000a\u000a		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));\u000a\u000a		//Various things done here to improve the performance:\u000a		// 1. we create a setTimeout, that calls refreshPositions\u000a		// 2. on the instance, we have a counter variable, that get's higher after every append\u000a		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same\u000a		// 4. this lets only the last addition to the timeout stack through\u000a		this.counter = this.counter ? ++this.counter : 1;\u000a		var counter = this.counter;\u000a\u000a		this._delay(function() {\u000a			if(counter === this.counter) {\u000a				this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove\u000a			}\u000a		});\u000a\u000a	},\u000a\u000a	_clear: function(event, noPropagation) {\u000a\u000a		this.reverting = false;\u000a		// We delay all events that have to be triggered to after the point where the placeholder has been removed and\u000a		// everything else normalized again\u000a		var i,\u000a			delayedTriggers = [];\u000a\u000a		// We first have to update the dom position of the actual currentItem\u000a		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)\u000a		if(!this._noFinalSort && this.currentItem.parent().length) {\u000a			this.placeholder.before(this.currentItem);\u000a		}\u000a		this._noFinalSort = null;\u000a\u000a		if(this.helper[0] === this.currentItem[0]) {\u000a			for(i in this._storedCSS) {\u000a				if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {\u000a					this._storedCSS[i] = "";\u000a				}\u000a			}\u000a			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");\u000a		} else {\u000a			this.currentItem.show();\u000a		}\u000a\u000a		if(this.fromOutside && !noPropagation) {\u000a			delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });\u000a		}\u000a		if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {\u000a			delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed\u000a		}\u000a\u000a		// Check if the items Container has Changed and trigger appropriate\u000a		// events.\u000a		if (this !== this.currentContainer) {\u000a			if(!noPropagation) {\u000a				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });\u000a				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));\u000a				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));\u000a			}\u000a		}\u000a\u000a\u000a		//Post events to containers\u000a		function delayEvent( type, instance, container ) {\u000a			return function( event ) {\u000a				container._trigger( type, event, instance._uiHash( instance ) );\u000a			};\u000a		}\u000a		for (i = this.containers.length - 1; i >= 0; i--){\u000a			if (!noPropagation) {\u000a				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );\u000a			}\u000a			if(this.containers[i].containerCache.over) {\u000a				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );\u000a				this.containers[i].containerCache.over = 0;\u000a			}\u000a		}\u000a\u000a		//Do what was originally in plugins\u000a		if ( this.storedCursor ) {\u000a			this.document.find( "body" ).css( "cursor", this.storedCursor );\u000a			this.storedStylesheet.remove();\u000a		}\u000a		if(this._storedOpacity) {\u000a			this.helper.css("opacity", this._storedOpacity);\u000a		}\u000a		if(this._storedZIndex) {\u000a			this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);\u000a		}\u000a\u000a		this.dragging = false;\u000a\u000a		if(!noPropagation) {\u000a			this._trigger("beforeStop", event, this._uiHash());\u000a		}\u000a\u000a		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\u000a		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\u000a\u000a		if ( !this.cancelHelperRemoval ) {\u000a			if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {\u000a				this.helper.remove();\u000a			}\u000a			this.helper = null;\u000a		}\u000a\u000a		if(!noPropagation) {\u000a			for (i=0; i < delayedTriggers.length; i++) {\u000a				delayedTriggers[i].call(this, event);\u000a			} //Trigger all delayed events\u000a			this._trigger("stop", event, this._uiHash());\u000a		}\u000a\u000a		this.fromOutside = false;\u000a		return !this.cancelHelperRemoval;\u000a\u000a	},\u000a\u000a	_trigger: function() {\u000a		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {\u000a			this.cancel();\u000a		}\u000a	},\u000a\u000a	_uiHash: function(_inst) {\u000a		var inst = _inst || this;\u000a		return {\u000a			helper: inst.helper,\u000a			placeholder: inst.placeholder || $([]),\u000a			position: inst.position,\u000a			originalPosition: inst.originalPosition,\u000a			offset: inst.positionAbs,\u000a			item: inst.currentItem,\u000a			sender: _inst ? _inst.element : null\u000a		};\u000a	}\u000a\u000a});\u000a\u000a\u000a\u000a}));\u000a;\u000a
p0
.