V// source: js/lib/jquery/jquery.js\u000a/*!\u000a * jQuery JavaScript Library v3.3.1\u000a * https://jquery.com/\u000a *\u000a * Includes Sizzle.js\u000a * https://sizzlejs.com/\u000a *\u000a * Copyright JS Foundation and other contributors\u000a * Released under the MIT license\u000a * https://jquery.org/license\u000a *\u000a * Date: 2018-01-20T17:24Z\u000a */\u000a( function( global, factory ) {\u000a\u000a	"use strict";\u000a\u000a	if ( typeof module === "object" && typeof module.exports === "object" ) {\u000a\u000a		// For CommonJS and CommonJS-like environments where a proper `window`\u000a		// is present, execute the factory and get jQuery.\u000a		// For environments that do not have a `window` with a `document`\u000a		// (such as Node.js), expose a factory as module.exports.\u000a		// This accentuates the need for the creation of a real `window`.\u000a		// e.g. var jQuery = require("jquery")(window);\u000a		// See ticket #14549 for more info.\u000a		module.exports = global.document ?\u000a			factory( global, true ) :\u000a			function( w ) {\u000a				if ( !w.document ) {\u000a					throw new Error( "jQuery requires a window with a document" );\u000a				}\u000a				return factory( w );\u000a			};\u000a	} else {\u000a		factory( global );\u000a	}\u000a\u000a// Pass this if window is not defined yet\u000a} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {\u000a\u000a// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\u000a// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\u000a// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\u000a// enough that all such attempts are guarded in a try block.\u000a"use strict";\u000a\u000avar arr = [];\u000a\u000avar document = window.document;\u000a\u000avar getProto = Object.getPrototypeOf;\u000a\u000avar slice = arr.slice;\u000a\u000avar concat = arr.concat;\u000a\u000avar push = arr.push;\u000a\u000avar indexOf = arr.indexOf;\u000a\u000avar class2type = {};\u000a\u000avar toString = class2type.toString;\u000a\u000avar hasOwn = class2type.hasOwnProperty;\u000a\u000avar fnToString = hasOwn.toString;\u000a\u000avar ObjectFunctionString = fnToString.call( Object );\u000a\u000avar support = {};\u000a\u000avar isFunction = function isFunction( obj ) {\u000a\u000a      // Support: Chrome <=57, Firefox <=52\u000a      // In some browsers, typeof returns "function" for HTML <object> elements\u000a      // (i.e., `typeof document.createElement( "object" ) === "function"`).\u000a      // We don't want to classify *any* DOM node as a function.\u000a      return typeof obj === "function" && typeof obj.nodeType !== "number";\u000a  };\u000a\u000a\u000avar isWindow = function isWindow( obj ) {\u000a		return obj != null && obj === obj.window;\u000a	};\u000a\u000a\u000a\u000a\u000a	var preservedScriptAttributes = {\u000a		type: true,\u000a		src: true,\u000a		noModule: true\u000a	};\u000a\u000a	function DOMEval( code, doc, node ) {\u000a		doc = doc || document;\u000a\u000a		var i,\u000a			script = doc.createElement( "script" );\u000a\u000a		script.text = code;\u000a		if ( node ) {\u000a			for ( i in preservedScriptAttributes ) {\u000a				if ( node[ i ] ) {\u000a					script[ i ] = node[ i ];\u000a				}\u000a			}\u000a		}\u000a		doc.head.appendChild( script ).parentNode.removeChild( script );\u000a	}\u000a\u000a\u000afunction toType( obj ) {\u000a	if ( obj == null ) {\u000a		return obj + "";\u000a	}\u000a\u000a	// Support: Android <=2.3 only (functionish RegExp)\u000a	return typeof obj === "object" || typeof obj === "function" ?\u000a		class2type[ toString.call( obj ) ] || "object" :\u000a		typeof obj;\u000a}\u000a/* global Symbol */\u000a// Defining this global in .eslintrc.json would create a danger of using the global\u000a// unguarded in another place, it seems safer to define global only for this module\u000a\u000a\u000a\u000avar\u000a	version = "3.3.1",\u000a\u000a	// Define a local copy of jQuery\u000a	jQuery = function( selector, context ) {\u000a\u000a		// The jQuery object is actually just the init constructor 'enhanced'\u000a		// Need init if jQuery is called (just allow error to be thrown if not included)\u000a		return new jQuery.fn.init( selector, context );\u000a	},\u000a\u000a	// Support: Android <=4.0 only\u000a	// Make sure we trim BOM and NBSP\u000a	rtrim = /^[\u005cs\u005cuFEFF\u005cxA0]+|[\u005cs\u005cuFEFF\u005cxA0]+$/g;\u000a\u000ajQuery.fn = jQuery.prototype = {\u000a\u000a	// The current version of jQuery being used\u000a	jquery: version,\u000a\u000a	constructor: jQuery,\u000a\u000a	// The default length of a jQuery object is 0\u000a	length: 0,\u000a\u000a	toArray: function() {\u000a		return slice.call( this );\u000a	},\u000a\u000a	// Get the Nth element in the matched element set OR\u000a	// Get the whole matched element set as a clean array\u000a	get: function( num ) {\u000a\u000a		// Return all the elements in a clean array\u000a		if ( num == null ) {\u000a			return slice.call( this );\u000a		}\u000a\u000a		// Return just the one element from the set\u000a		return num < 0 ? this[ num + this.length ] : this[ num ];\u000a	},\u000a\u000a	// Take an array of elements and push it onto the stack\u000a	// (returning the new matched element set)\u000a	pushStack: function( elems ) {\u000a\u000a		// Build a new jQuery matched element set\u000a		var ret = jQuery.merge( this.constructor(), elems );\u000a\u000a		// Add the old object onto the stack (as a reference)\u000a		ret.prevObject = this;\u000a\u000a		// Return the newly-formed element set\u000a		return ret;\u000a	},\u000a\u000a	// Execute a callback for every element in the matched set.\u000a	each: function( callback ) {\u000a		return jQuery.each( this, callback );\u000a	},\u000a\u000a	map: function( callback ) {\u000a		return this.pushStack( jQuery.map( this, function( elem, i ) {\u000a			return callback.call( elem, i, elem );\u000a		} ) );\u000a	},\u000a\u000a	slice: function() {\u000a		return this.pushStack( slice.apply( this, arguments ) );\u000a	},\u000a\u000a	first: function() {\u000a		return this.eq( 0 );\u000a	},\u000a\u000a	last: function() {\u000a		return this.eq( -1 );\u000a	},\u000a\u000a	eq: function( i ) {\u000a		var len = this.length,\u000a			j = +i + ( i < 0 ? len : 0 );\u000a		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\u000a	},\u000a\u000a	end: function() {\u000a		return this.prevObject || this.constructor();\u000a	},\u000a\u000a	// For internal use only.\u000a	// Behaves like an Array's method, not like a jQuery method.\u000a	push: push,\u000a	sort: arr.sort,\u000a	splice: arr.splice\u000a};\u000a\u000ajQuery.extend = jQuery.fn.extend = function() {\u000a	var options, name, src, copy, copyIsArray, clone,\u000a		target = arguments[ 0 ] || {},\u000a		i = 1,\u000a		length = arguments.length,\u000a		deep = false;\u000a\u000a	// Handle a deep copy situation\u000a	if ( typeof target === "boolean" ) {\u000a		deep = target;\u000a\u000a		// Skip the boolean and the target\u000a		target = arguments[ i ] || {};\u000a		i++;\u000a	}\u000a\u000a	// Handle case when target is a string or something (possible in deep copy)\u000a	if ( typeof target !== "object" && !isFunction( target ) ) {\u000a		target = {};\u000a	}\u000a\u000a	// Extend jQuery itself if only one argument is passed\u000a	if ( i === length ) {\u000a		target = this;\u000a		i--;\u000a	}\u000a\u000a	for ( ; i < length; i++ ) {\u000a\u000a		// Only deal with non-null/undefined values\u000a		if ( ( options = arguments[ i ] ) != null ) {\u000a\u000a			// Extend the base object\u000a			for ( name in options ) {\u000a				src = target[ name ];\u000a				copy = options[ name ];\u000a\u000a				// Prevent never-ending loop\u000a				if ( target === copy ) {\u000a					continue;\u000a				}\u000a\u000a				// Recurse if we're merging plain objects or arrays\u000a				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||\u000a					( copyIsArray = Array.isArray( copy ) ) ) ) {\u000a\u000a					if ( copyIsArray ) {\u000a						copyIsArray = false;\u000a						clone = src && Array.isArray( src ) ? src : [];\u000a\u000a					} else {\u000a						clone = src && jQuery.isPlainObject( src ) ? src : {};\u000a					}\u000a\u000a					// Never move original objects, clone them\u000a					target[ name ] = jQuery.extend( deep, clone, copy );\u000a\u000a				// Don't bring in undefined values\u000a				} else if ( copy !== undefined ) {\u000a					target[ name ] = copy;\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	// Return the modified object\u000a	return target;\u000a};\u000a\u000ajQuery.extend( {\u000a\u000a	// Unique for each copy of jQuery on the page\u000a	expando: "jQuery" + ( version + Math.random() ).replace( /\u005cD/g, "" ),\u000a\u000a	// Assume jQuery is ready without the ready module\u000a	isReady: true,\u000a\u000a	error: function( msg ) {\u000a		throw new Error( msg );\u000a	},\u000a\u000a	noop: function() {},\u000a\u000a	isPlainObject: function( obj ) {\u000a		var proto, Ctor;\u000a\u000a		// Detect obvious negatives\u000a		// Use toString instead of jQuery.type to catch host objects\u000a		if ( !obj || toString.call( obj ) !== "[object Object]" ) {\u000a			return false;\u000a		}\u000a\u000a		proto = getProto( obj );\u000a\u000a		// Objects with no prototype (e.g., `Object.create( null )`) are plain\u000a		if ( !proto ) {\u000a			return true;\u000a		}\u000a\u000a		// Objects with prototype are plain iff they were constructed by a global Object function\u000a		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;\u000a		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;\u000a	},\u000a\u000a	isEmptyObject: function( obj ) {\u000a\u000a		/* eslint-disable no-unused-vars */\u000a		// See https://github.com/eslint/eslint/issues/6125\u000a		var name;\u000a\u000a		for ( name in obj ) {\u000a			return false;\u000a		}\u000a		return true;\u000a	},\u000a\u000a	// Evaluates a script in a global context\u000a	globalEval: function( code ) {\u000a		DOMEval( code );\u000a	},\u000a\u000a	each: function( obj, callback ) {\u000a		var length, i = 0;\u000a\u000a		if ( isArrayLike( obj ) ) {\u000a			length = obj.length;\u000a			for ( ; i < length; i++ ) {\u000a				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\u000a					break;\u000a				}\u000a			}\u000a		} else {\u000a			for ( i in obj ) {\u000a				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\u000a					break;\u000a				}\u000a			}\u000a		}\u000a\u000a		return obj;\u000a	},\u000a\u000a	// Support: Android <=4.0 only\u000a	trim: function( text ) {\u000a		return text == null ?\u000a			"" :\u000a			( text + "" ).replace( rtrim, "" );\u000a	},\u000a\u000a	// results is for internal usage only\u000a	makeArray: function( arr, results ) {\u000a		var ret = results || [];\u000a\u000a		if ( arr != null ) {\u000a			if ( isArrayLike( Object( arr ) ) ) {\u000a				jQuery.merge( ret,\u000a					typeof arr === "string" ?\u000a					[ arr ] : arr\u000a				);\u000a			} else {\u000a				push.call( ret, arr );\u000a			}\u000a		}\u000a\u000a		return ret;\u000a	},\u000a\u000a	inArray: function( elem, arr, i ) {\u000a		return arr == null ? -1 : indexOf.call( arr, elem, i );\u000a	},\u000a\u000a	// Support: Android <=4.0 only, PhantomJS 1 only\u000a	// push.apply(_, arraylike) throws on ancient WebKit\u000a	merge: function( first, second ) {\u000a		var len = +second.length,\u000a			j = 0,\u000a			i = first.length;\u000a\u000a		for ( ; j < len; j++ ) {\u000a			first[ i++ ] = second[ j ];\u000a		}\u000a\u000a		first.length = i;\u000a\u000a		return first;\u000a	},\u000a\u000a	grep: function( elems, callback, invert ) {\u000a		var callbackInverse,\u000a			matches = [],\u000a			i = 0,\u000a			length = elems.length,\u000a			callbackExpect = !invert;\u000a\u000a		// Go through the array, only saving the items\u000a		// that pass the validator function\u000a		for ( ; i < length; i++ ) {\u000a			callbackInverse = !callback( elems[ i ], i );\u000a			if ( callbackInverse !== callbackExpect ) {\u000a				matches.push( elems[ i ] );\u000a			}\u000a		}\u000a\u000a		return matches;\u000a	},\u000a\u000a	// arg is for internal usage only\u000a	map: function( elems, callback, arg ) {\u000a		var length, value,\u000a			i = 0,\u000a			ret = [];\u000a\u000a		// Go through the array, translating each of the items to their new values\u000a		if ( isArrayLike( elems ) ) {\u000a			length = elems.length;\u000a			for ( ; i < length; i++ ) {\u000a				value = callback( elems[ i ], i, arg );\u000a\u000a				if ( value != null ) {\u000a					ret.push( value );\u000a				}\u000a			}\u000a\u000a		// Go through every key on the object,\u000a		} else {\u000a			for ( i in elems ) {\u000a				value = callback( elems[ i ], i, arg );\u000a\u000a				if ( value != null ) {\u000a					ret.push( value );\u000a				}\u000a			}\u000a		}\u000a\u000a		// Flatten any nested arrays\u000a		return concat.apply( [], ret );\u000a	},\u000a\u000a	// A global GUID counter for objects\u000a	guid: 1,\u000a\u000a	// jQuery.support is not used in Core but other projects attach their\u000a	// properties to it so it needs to exist.\u000a	support: support\u000a} );\u000a\u000aif ( typeof Symbol === "function" ) {\u000a	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\u000a}\u000a\u000a// Populate the class2type map\u000ajQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),\u000afunction( i, name ) {\u000a	class2type[ "[object " + name + "]" ] = name.toLowerCase();\u000a} );\u000a\u000afunction isArrayLike( obj ) {\u000a\u000a	// Support: real iOS 8.2 only (not reproducible in simulator)\u000a	// `in` check used to prevent JIT error (gh-2145)\u000a	// hasOwn isn't used here due to false negatives\u000a	// regarding Nodelist length in IE\u000a	var length = !!obj && "length" in obj && obj.length,\u000a		type = toType( obj );\u000a\u000a	if ( isFunction( obj ) || isWindow( obj ) ) {\u000a		return false;\u000a	}\u000a\u000a	return type === "array" || length === 0 ||\u000a		typeof length === "number" && length > 0 && ( length - 1 ) in obj;\u000a}\u000avar Sizzle =\u000a/*!\u000a * Sizzle CSS Selector Engine v2.3.3\u000a * https://sizzlejs.com/\u000a *\u000a * Copyright jQuery Foundation and other contributors\u000a * Released under the MIT license\u000a * http://jquery.org/license\u000a *\u000a * Date: 2016-08-08\u000a */\u000a(function( window ) {\u000a\u000avar i,\u000a	support,\u000a	Expr,\u000a	getText,\u000a	isXML,\u000a	tokenize,\u000a	compile,\u000a	select,\u000a	outermostContext,\u000a	sortInput,\u000a	hasDuplicate,\u000a\u000a	// Local document vars\u000a	setDocument,\u000a	document,\u000a	docElem,\u000a	documentIsHTML,\u000a	rbuggyQSA,\u000a	rbuggyMatches,\u000a	matches,\u000a	contains,\u000a\u000a	// Instance-specific data\u000a	expando = "sizzle" + 1 * new Date(),\u000a	preferredDoc = window.document,\u000a	dirruns = 0,\u000a	done = 0,\u000a	classCache = createCache(),\u000a	tokenCache = createCache(),\u000a	compilerCache = createCache(),\u000a	sortOrder = function( a, b ) {\u000a		if ( a === b ) {\u000a			hasDuplicate = true;\u000a		}\u000a		return 0;\u000a	},\u000a\u000a	// Instance methods\u000a	hasOwn = ({}).hasOwnProperty,\u000a	arr = [],\u000a	pop = arr.pop,\u000a	push_native = arr.push,\u000a	push = arr.push,\u000a	slice = arr.slice,\u000a	// Use a stripped-down indexOf as it's faster than native\u000a	// https://jsperf.com/thor-indexof-vs-for/5\u000a	indexOf = function( list, elem ) {\u000a		var i = 0,\u000a			len = list.length;\u000a		for ( ; i < len; i++ ) {\u000a			if ( list[i] === elem ) {\u000a				return i;\u000a			}\u000a		}\u000a		return -1;\u000a	},\u000a\u000a	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\u000a\u000a	// Regular expressions\u000a\u000a	// http://www.w3.org/TR/css3-selectors/#whitespace\u000a	whitespace = "[\u005c\u005cx20\u005c\u005ct\u005c\u005cr\u005c\u005cn\u005c\u005cf]",\u000a\u000a	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\u000a	identifier = "(?:\u005c\u005c\u005c\u005c.|[\u005c\u005cw-]|[^\u005c0-\u005c\u005cxa0])+",\u000a\u000a	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\u000a	attributes = "\u005c\u005c[" + whitespace + "*(" + identifier + ")(?:" + whitespace +\u000a		// Operator (capture 2)\u000a		"*([*^$|!~]?=)" + whitespace +\u000a		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\u000a		"*(?:'((?:\u005c\u005c\u005c\u005c.|[^\u005c\u005c\u005c\u005c'])*)'|\u005c"((?:\u005c\u005c\u005c\u005c.|[^\u005c\u005c\u005c\u005c\u005c"])*)\u005c"|(" + identifier + "))|)" + whitespace +\u000a		"*\u005c\u005c]",\u000a\u000a	pseudos = ":(" + identifier + ")(?:\u005c\u005c((" +\u000a		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\u000a		// 1. quoted (capture 3; capture 4 or capture 5)\u000a		"('((?:\u005c\u005c\u005c\u005c.|[^\u005c\u005c\u005c\u005c'])*)'|\u005c"((?:\u005c\u005c\u005c\u005c.|[^\u005c\u005c\u005c\u005c\u005c"])*)\u005c")|" +\u000a		// 2. simple (capture 6)\u000a		"((?:\u005c\u005c\u005c\u005c.|[^\u005c\u005c\u005c\u005c()[\u005c\u005c]]|" + attributes + ")*)|" +\u000a		// 3. anything else (capture 2)\u000a		".*" +\u000a		")\u005c\u005c)|)",\u000a\u000a	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\u000a	rwhitespace = new RegExp( whitespace + "+", "g" ),\u000a	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\u005c\u005c\u005c\u005c])(?:\u005c\u005c\u005c\u005c.)*)" + whitespace + "+$", "g" ),\u000a\u000a	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\u000a	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\u000a\u000a	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\u005c\u005c]'\u005c"]*?)" + whitespace + "*\u005c\u005c]", "g" ),\u000a\u000a	rpseudo = new RegExp( pseudos ),\u000a	ridentifier = new RegExp( "^" + identifier + "$" ),\u000a\u000a	matchExpr = {\u000a		"ID": new RegExp( "^#(" + identifier + ")" ),\u000a		"CLASS": new RegExp( "^\u005c\u005c.(" + identifier + ")" ),\u000a		"TAG": new RegExp( "^(" + identifier + "|[*])" ),\u000a		"ATTR": new RegExp( "^" + attributes ),\u000a		"PSEUDO": new RegExp( "^" + pseudos ),\u000a		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\u005c\u005c(" + whitespace +\u000a			"*(even|odd|(([+-]|)(\u005c\u005cd*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\u000a			"*(\u005c\u005cd+)|))" + whitespace + "*\u005c\u005c)|)", "i" ),\u000a		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\u000a		// For use in libraries implementing .is()\u000a		// We use this for POS matching in `select`\u000a		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\u005c\u005c(" +\u000a			whitespace + "*((?:-\u005c\u005cd)?\u005c\u005cd*)" + whitespace + "*\u005c\u005c)|)(?=[^-]|$)", "i" )\u000a	},\u000a\u000a	rinputs = /^(?:input|select|textarea|button)$/i,\u000a	rheader = /^h\u005cd$/i,\u000a\u000a	rnative = /^[^{]+\u005c{\u005cs*\u005c[native \u005cw/,\u000a\u000a	// Easily-parseable/retrievable ID or TAG or CLASS selectors\u000a	rquickExpr = /^(?:#([\u005cw-]+)|(\u005cw+)|\u005c.([\u005cw-]+))$/,\u000a\u000a	rsibling = /[+~]/,\u000a\u000a	// CSS escapes\u000a	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\u000a	runescape = new RegExp( "\u005c\u005c\u005c\u005c([\u005c\u005cda-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\u000a	funescape = function( _, escaped, escapedWhitespace ) {\u000a		var high = "0x" + escaped - 0x10000;\u000a		// NaN means non-codepoint\u000a		// Support: Firefox<24\u000a		// Workaround erroneous numeric interpretation of +"0x"\u000a		return high !== high || escapedWhitespace ?\u000a			escaped :\u000a			high < 0 ?\u000a				// BMP codepoint\u000a				String.fromCharCode( high + 0x10000 ) :\u000a				// Supplemental Plane codepoint (surrogate pair)\u000a				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\u000a	},\u000a\u000a	// CSS string/identifier serialization\u000a	// https://drafts.csswg.org/cssom/#common-serializing-idioms\u000a	rcssescape = /([\u005c0-\u005cx1f\u005cx7f]|^-?\u005cd)|^-$|[^\u005c0-\u005cx1f\u005cx7f-\u005cuFFFF\u005cw-]/g,\u000a	fcssescape = function( ch, asCodePoint ) {\u000a		if ( asCodePoint ) {\u000a\u000a			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\u000a			if ( ch === "\u005c0" ) {\u000a				return "\u005cuFFFD";\u000a			}\u000a\u000a			// Control characters and (dependent upon position) numbers get escaped as code points\u000a			return ch.slice( 0, -1 ) + "\u005c\u005c" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";\u000a		}\u000a\u000a		// Other potentially-special ASCII characters get backslash-escaped\u000a		return "\u005c\u005c" + ch;\u000a	},\u000a\u000a	// Used for iframes\u000a	// See setDocument()\u000a	// Removing the function wrapper causes a "Permission Denied"\u000a	// error in IE\u000a	unloadHandler = function() {\u000a		setDocument();\u000a	},\u000a\u000a	disabledAncestor = addCombinator(\u000a		function( elem ) {\u000a			return elem.disabled === true && ("form" in elem || "label" in elem);\u000a		},\u000a		{ dir: "parentNode", next: "legend" }\u000a	);\u000a\u000a// Optimize for push.apply( _, NodeList )\u000atry {\u000a	push.apply(\u000a		(arr = slice.call( preferredDoc.childNodes )),\u000a		preferredDoc.childNodes\u000a	);\u000a	// Support: Android<4.0\u000a	// Detect silently failing push.apply\u000a	arr[ preferredDoc.childNodes.length ].nodeType;\u000a} catch ( e ) {\u000a	push = { apply: arr.length ?\u000a\u000a		// Leverage slice if possible\u000a		function( target, els ) {\u000a			push_native.apply( target, slice.call(els) );\u000a		} :\u000a\u000a		// Support: IE<9\u000a		// Otherwise append directly\u000a		function( target, els ) {\u000a			var j = target.length,\u000a				i = 0;\u000a			// Can't trust NodeList.length\u000a			while ( (target[j++] = els[i++]) ) {}\u000a			target.length = j - 1;\u000a		}\u000a	};\u000a}\u000a\u000afunction Sizzle( selector, context, results, seed ) {\u000a	var m, i, elem, nid, match, groups, newSelector,\u000a		newContext = context && context.ownerDocument,\u000a\u000a		// nodeType defaults to 9, since context defaults to document\u000a		nodeType = context ? context.nodeType : 9;\u000a\u000a	results = results || [];\u000a\u000a	// Return early from calls with invalid selector or context\u000a	if ( typeof selector !== "string" || !selector ||\u000a		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\u000a\u000a		return results;\u000a	}\u000a\u000a	// Try to shortcut find operations (as opposed to filters) in HTML documents\u000a	if ( !seed ) {\u000a\u000a		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\u000a			setDocument( context );\u000a		}\u000a		context = context || document;\u000a\u000a		if ( documentIsHTML ) {\u000a\u000a			// If the selector is sufficiently simple, try using a "get*By*" DOM method\u000a			// (excepting DocumentFragment context, where the methods don't exist)\u000a			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\u000a\u000a				// ID selector\u000a				if ( (m = match[1]) ) {\u000a\u000a					// Document context\u000a					if ( nodeType === 9 ) {\u000a						if ( (elem = context.getElementById( m )) ) {\u000a\u000a							// Support: IE, Opera, Webkit\u000a							// TODO: identify versions\u000a							// getElementById can match elements by name instead of ID\u000a							if ( elem.id === m ) {\u000a								results.push( elem );\u000a								return results;\u000a							}\u000a						} else {\u000a							return results;\u000a						}\u000a\u000a					// Element context\u000a					} else {\u000a\u000a						// Support: IE, Opera, Webkit\u000a						// TODO: identify versions\u000a						// getElementById can match elements by name instead of ID\u000a						if ( newContext && (elem = newContext.getElementById( m )) &&\u000a							contains( context, elem ) &&\u000a							elem.id === m ) {\u000a\u000a							results.push( elem );\u000a							return results;\u000a						}\u000a					}\u000a\u000a				// Type selector\u000a				} else if ( match[2] ) {\u000a					push.apply( results, context.getElementsByTagName( selector ) );\u000a					return results;\u000a\u000a				// Class selector\u000a				} else if ( (m = match[3]) && support.getElementsByClassName &&\u000a					context.getElementsByClassName ) {\u000a\u000a					push.apply( results, context.getElementsByClassName( m ) );\u000a					return results;\u000a				}\u000a			}\u000a\u000a			// Take advantage of querySelectorAll\u000a			if ( support.qsa &&\u000a				!compilerCache[ selector + " " ] &&\u000a				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\u000a\u000a				if ( nodeType !== 1 ) {\u000a					newContext = context;\u000a					newSelector = selector;\u000a\u000a				// qSA looks outside Element context, which is not what we want\u000a				// Thanks to Andrew Dupont for this workaround technique\u000a				// Support: IE <=8\u000a				// Exclude object elements\u000a				} else if ( context.nodeName.toLowerCase() !== "object" ) {\u000a\u000a					// Capture the context ID, setting it first if necessary\u000a					if ( (nid = context.getAttribute( "id" )) ) {\u000a						nid = nid.replace( rcssescape, fcssescape );\u000a					} else {\u000a						context.setAttribute( "id", (nid = expando) );\u000a					}\u000a\u000a					// Prefix every selector in the list\u000a					groups = tokenize( selector );\u000a					i = groups.length;\u000a					while ( i-- ) {\u000a						groups[i] = "#" + nid + " " + toSelector( groups[i] );\u000a					}\u000a					newSelector = groups.join( "," );\u000a\u000a					// Expand context for sibling selectors\u000a					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\u000a						context;\u000a				}\u000a\u000a				if ( newSelector ) {\u000a					try {\u000a						push.apply( results,\u000a							newContext.querySelectorAll( newSelector )\u000a						);\u000a						return results;\u000a					} catch ( qsaError ) {\u000a					} finally {\u000a						if ( nid === expando ) {\u000a							context.removeAttribute( "id" );\u000a						}\u000a					}\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	// All others\u000a	return select( selector.replace( rtrim, "$1" ), context, results, seed );\u000a}\u000a\u000a/**\u000a * Create key-value caches of limited size\u000a * @returns {function(string, object)} Returns the Object data after storing it on itself with\u000a *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\u000a *	deleting the oldest entry\u000a */\u000afunction createCache() {\u000a	var keys = [];\u000a\u000a	function cache( key, value ) {\u000a		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\u000a		if ( keys.push( key + " " ) > Expr.cacheLength ) {\u000a			// Only keep the most recent entries\u000a			delete cache[ keys.shift() ];\u000a		}\u000a		return (cache[ key + " " ] = value);\u000a	}\u000a	return cache;\u000a}\u000a\u000a/**\u000a * Mark a function for special use by Sizzle\u000a * @param {Function} fn The function to mark\u000a */\u000afunction markFunction( fn ) {\u000a	fn[ expando ] = true;\u000a	return fn;\u000a}\u000a\u000a/**\u000a * Support testing using an element\u000a * @param {Function} fn Passed the created element and returns a boolean result\u000a */\u000afunction assert( fn ) {\u000a	var el = document.createElement("fieldset");\u000a\u000a	try {\u000a		return !!fn( el );\u000a	} catch (e) {\u000a		return false;\u000a	} finally {\u000a		// Remove from its parent by default\u000a		if ( el.parentNode ) {\u000a			el.parentNode.removeChild( el );\u000a		}\u000a		// release memory in IE\u000a		el = null;\u000a	}\u000a}\u000a\u000a/**\u000a * Adds the same handler for all of the specified attrs\u000a * @param {String} attrs Pipe-separated list of attributes\u000a * @param {Function} handler The method that will be applied\u000a */\u000afunction addHandle( attrs, handler ) {\u000a	var arr = attrs.split("|"),\u000a		i = arr.length;\u000a\u000a	while ( i-- ) {\u000a		Expr.attrHandle[ arr[i] ] = handler;\u000a	}\u000a}\u000a\u000a/**\u000a * Checks document order of two siblings\u000a * @param {Element} a\u000a * @param {Element} b\u000a * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\u000a */\u000afunction siblingCheck( a, b ) {\u000a	var cur = b && a,\u000a		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&\u000a			a.sourceIndex - b.sourceIndex;\u000a\u000a	// Use IE sourceIndex if available on both nodes\u000a	if ( diff ) {\u000a		return diff;\u000a	}\u000a\u000a	// Check if b follows a\u000a	if ( cur ) {\u000a		while ( (cur = cur.nextSibling) ) {\u000a			if ( cur === b ) {\u000a				return -1;\u000a			}\u000a		}\u000a	}\u000a\u000a	return a ? 1 : -1;\u000a}\u000a\u000a/**\u000a * Returns a function to use in pseudos for input types\u000a * @param {String} type\u000a */\u000afunction createInputPseudo( type ) {\u000a	return function( elem ) {\u000a		var name = elem.nodeName.toLowerCase();\u000a		return name === "input" && elem.type === type;\u000a	};\u000a}\u000a\u000a/**\u000a * Returns a function to use in pseudos for buttons\u000a * @param {String} type\u000a */\u000afunction createButtonPseudo( type ) {\u000a	return function( elem ) {\u000a		var name = elem.nodeName.toLowerCase();\u000a		return (name === "input" || name === "button") && elem.type === type;\u000a	};\u000a}\u000a\u000a/**\u000a * Returns a function to use in pseudos for :enabled/:disabled\u000a * @param {Boolean} disabled true for :disabled; false for :enabled\u000a */\u000afunction createDisabledPseudo( disabled ) {\u000a\u000a	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\u000a	return function( elem ) {\u000a\u000a		// Only certain elements can match :enabled or :disabled\u000a		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\u000a		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\u000a		if ( "form" in elem ) {\u000a\u000a			// Check for inherited disabledness on relevant non-disabled elements:\u000a			// * listed form-associated elements in a disabled fieldset\u000a			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\u000a			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\u000a			// * option elements in a disabled optgroup\u000a			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\u000a			// All such elements have a "form" property.\u000a			if ( elem.parentNode && elem.disabled === false ) {\u000a\u000a				// Option elements defer to a parent optgroup if present\u000a				if ( "label" in elem ) {\u000a					if ( "label" in elem.parentNode ) {\u000a						return elem.parentNode.disabled === disabled;\u000a					} else {\u000a						return elem.disabled === disabled;\u000a					}\u000a				}\u000a\u000a				// Support: IE 6 - 11\u000a				// Use the isDisabled shortcut property to check for disabled fieldset ancestors\u000a				return elem.isDisabled === disabled ||\u000a\u000a					// Where there is no isDisabled, check manually\u000a					/* jshint -W018 */\u000a					elem.isDisabled !== !disabled &&\u000a						disabledAncestor( elem ) === disabled;\u000a			}\u000a\u000a			return elem.disabled === disabled;\u000a\u000a		// Try to winnow out elements that can't be disabled before trusting the disabled property.\u000a		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\u000a		// even exist on them, let alone have a boolean value.\u000a		} else if ( "label" in elem ) {\u000a			return elem.disabled === disabled;\u000a		}\u000a\u000a		// Remaining elements are neither :enabled nor :disabled\u000a		return false;\u000a	};\u000a}\u000a\u000a/**\u000a * Returns a function to use in pseudos for positionals\u000a * @param {Function} fn\u000a */\u000afunction createPositionalPseudo( fn ) {\u000a	return markFunction(function( argument ) {\u000a		argument = +argument;\u000a		return markFunction(function( seed, matches ) {\u000a			var j,\u000a				matchIndexes = fn( [], seed.length, argument ),\u000a				i = matchIndexes.length;\u000a\u000a			// Match elements found at the specified indexes\u000a			while ( i-- ) {\u000a				if ( seed[ (j = matchIndexes[i]) ] ) {\u000a					seed[j] = !(matches[j] = seed[j]);\u000a				}\u000a			}\u000a		});\u000a	});\u000a}\u000a\u000a/**\u000a * Checks a node for validity as a Sizzle context\u000a * @param {Element|Object=} context\u000a * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\u000a */\u000afunction testContext( context ) {\u000a	return context && typeof context.getElementsByTagName !== "undefined" && context;\u000a}\u000a\u000a// Expose support vars for convenience\u000asupport = Sizzle.support = {};\u000a\u000a/**\u000a * Detects XML nodes\u000a * @param {Element|Object} elem An element or a document\u000a * @returns {Boolean} True iff elem is a non-HTML XML node\u000a */\u000aisXML = Sizzle.isXML = function( elem ) {\u000a	// documentElement is verified for cases where it doesn't yet exist\u000a	// (such as loading iframes in IE - #4833)\u000a	var documentElement = elem && (elem.ownerDocument || elem).documentElement;\u000a	return documentElement ? documentElement.nodeName !== "HTML" : false;\u000a};\u000a\u000a/**\u000a * Sets document-related variables once based on the current document\u000a * @param {Element|Object} [doc] An element or document object to use to set the document\u000a * @returns {Object} Returns the current document\u000a */\u000asetDocument = Sizzle.setDocument = function( node ) {\u000a	var hasCompare, subWindow,\u000a		doc = node ? node.ownerDocument || node : preferredDoc;\u000a\u000a	// Return early if doc is invalid or already selected\u000a	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\u000a		return document;\u000a	}\u000a\u000a	// Update global variables\u000a	document = doc;\u000a	docElem = document.documentElement;\u000a	documentIsHTML = !isXML( document );\u000a\u000a	// Support: IE 9-11, Edge\u000a	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)\u000a	if ( preferredDoc !== document &&\u000a		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\u000a\u000a		// Support: IE 11, Edge\u000a		if ( subWindow.addEventListener ) {\u000a			subWindow.addEventListener( "unload", unloadHandler, false );\u000a\u000a		// Support: IE 9 - 10 only\u000a		} else if ( subWindow.attachEvent ) {\u000a			subWindow.attachEvent( "onunload", unloadHandler );\u000a		}\u000a	}\u000a\u000a	/* Attributes\u000a	---------------------------------------------------------------------- */\u000a\u000a	// Support: IE<8\u000a	// Verify that getAttribute really returns attributes and not properties\u000a	// (excepting IE8 booleans)\u000a	support.attributes = assert(function( el ) {\u000a		el.className = "i";\u000a		return !el.getAttribute("className");\u000a	});\u000a\u000a	/* getElement(s)By*\u000a	---------------------------------------------------------------------- */\u000a\u000a	// Check if getElementsByTagName("*") returns only elements\u000a	support.getElementsByTagName = assert(function( el ) {\u000a		el.appendChild( document.createComment("") );\u000a		return !el.getElementsByTagName("*").length;\u000a	});\u000a\u000a	// Support: IE<9\u000a	support.getElementsByClassName = rnative.test( document.getElementsByClassName );\u000a\u000a	// Support: IE<10\u000a	// Check if getElementById returns elements by name\u000a	// The broken getElementById methods don't pick up programmatically-set names,\u000a	// so use a roundabout getElementsByName test\u000a	support.getById = assert(function( el ) {\u000a		docElem.appendChild( el ).id = expando;\u000a		return !document.getElementsByName || !document.getElementsByName( expando ).length;\u000a	});\u000a\u000a	// ID filter and find\u000a	if ( support.getById ) {\u000a		Expr.filter["ID"] = function( id ) {\u000a			var attrId = id.replace( runescape, funescape );\u000a			return function( elem ) {\u000a				return elem.getAttribute("id") === attrId;\u000a			};\u000a		};\u000a		Expr.find["ID"] = function( id, context ) {\u000a			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\u000a				var elem = context.getElementById( id );\u000a				return elem ? [ elem ] : [];\u000a			}\u000a		};\u000a	} else {\u000a		Expr.filter["ID"] =  function( id ) {\u000a			var attrId = id.replace( runescape, funescape );\u000a			return function( elem ) {\u000a				var node = typeof elem.getAttributeNode !== "undefined" &&\u000a					elem.getAttributeNode("id");\u000a				return node && node.value === attrId;\u000a			};\u000a		};\u000a\u000a		// Support: IE 6 - 7 only\u000a		// getElementById is not reliable as a find shortcut\u000a		Expr.find["ID"] = function( id, context ) {\u000a			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\u000a				var node, i, elems,\u000a					elem = context.getElementById( id );\u000a\u000a				if ( elem ) {\u000a\u000a					// Verify the id attribute\u000a					node = elem.getAttributeNode("id");\u000a					if ( node && node.value === id ) {\u000a						return [ elem ];\u000a					}\u000a\u000a					// Fall back on getElementsByName\u000a					elems = context.getElementsByName( id );\u000a					i = 0;\u000a					while ( (elem = elems[i++]) ) {\u000a						node = elem.getAttributeNode("id");\u000a						if ( node && node.value === id ) {\u000a							return [ elem ];\u000a						}\u000a					}\u000a				}\u000a\u000a				return [];\u000a			}\u000a		};\u000a	}\u000a\u000a	// Tag\u000a	Expr.find["TAG"] = support.getElementsByTagName ?\u000a		function( tag, context ) {\u000a			if ( typeof context.getElementsByTagName !== "undefined" ) {\u000a				return context.getElementsByTagName( tag );\u000a\u000a			// DocumentFragment nodes don't have gEBTN\u000a			} else if ( support.qsa ) {\u000a				return context.querySelectorAll( tag );\u000a			}\u000a		} :\u000a\u000a		function( tag, context ) {\u000a			var elem,\u000a				tmp = [],\u000a				i = 0,\u000a				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\u000a				results = context.getElementsByTagName( tag );\u000a\u000a			// Filter out possible comments\u000a			if ( tag === "*" ) {\u000a				while ( (elem = results[i++]) ) {\u000a					if ( elem.nodeType === 1 ) {\u000a						tmp.push( elem );\u000a					}\u000a				}\u000a\u000a				return tmp;\u000a			}\u000a			return results;\u000a		};\u000a\u000a	// Class\u000a	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\u000a		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {\u000a			return context.getElementsByClassName( className );\u000a		}\u000a	};\u000a\u000a	/* QSA/matchesSelector\u000a	---------------------------------------------------------------------- */\u000a\u000a	// QSA and matchesSelector support\u000a\u000a	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\u000a	rbuggyMatches = [];\u000a\u000a	// qSa(:focus) reports false when true (Chrome 21)\u000a	// We allow this because of a bug in IE8/9 that throws an error\u000a	// whenever `document.activeElement` is accessed on an iframe\u000a	// So, we allow :focus to pass through QSA all the time to avoid the IE error\u000a	// See https://bugs.jquery.com/ticket/13378\u000a	rbuggyQSA = [];\u000a\u000a	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\u000a		// Build QSA regex\u000a		// Regex strategy adopted from Diego Perini\u000a		assert(function( el ) {\u000a			// Select is set to empty string on purpose\u000a			// This is to test IE's treatment of not explicitly\u000a			// setting a boolean content attribute,\u000a			// since its presence should be enough\u000a			// https://bugs.jquery.com/ticket/12359\u000a			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +\u000a				"<select id='" + expando + "-\u005cr\u005c\u005c' msallowcapture=''>" +\u000a				"<option selected=''></option></select>";\u000a\u000a			// Support: IE8, Opera 11-12.16\u000a			// Nothing should be selected when empty strings follow ^= or $= or *=\u000a			// The test attribute must be unknown in Opera but "safe" for WinRT\u000a			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\u000a			if ( el.querySelectorAll("[msallowcapture^='']").length ) {\u000a				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\u005c"\u005c")" );\u000a			}\u000a\u000a			// Support: IE8\u000a			// Boolean attributes and "value" are not treated correctly\u000a			if ( !el.querySelectorAll("[selected]").length ) {\u000a				rbuggyQSA.push( "\u005c\u005c[" + whitespace + "*(?:value|" + booleans + ")" );\u000a			}\u000a\u000a			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\u000a			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {\u000a				rbuggyQSA.push("~=");\u000a			}\u000a\u000a			// Webkit/Opera - :checked should return selected option elements\u000a			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\u000a			// IE8 throws error here and will not see later tests\u000a			if ( !el.querySelectorAll(":checked").length ) {\u000a				rbuggyQSA.push(":checked");\u000a			}\u000a\u000a			// Support: Safari 8+, iOS 8+\u000a			// https://bugs.webkit.org/show_bug.cgi?id=136851\u000a			// In-page `selector#id sibling-combinator selector` fails\u000a			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {\u000a				rbuggyQSA.push(".#.+[+~]");\u000a			}\u000a		});\u000a\u000a		assert(function( el ) {\u000a			el.innerHTML = "<a href='' disabled='disabled'></a>" +\u000a				"<select disabled='disabled'><option/></select>";\u000a\u000a			// Support: Windows 8 Native Apps\u000a			// The type and name attributes are restricted during .innerHTML assignment\u000a			var input = document.createElement("input");\u000a			input.setAttribute( "type", "hidden" );\u000a			el.appendChild( input ).setAttribute( "name", "D" );\u000a\u000a			// Support: IE8\u000a			// Enforce case-sensitivity of name attribute\u000a			if ( el.querySelectorAll("[name=d]").length ) {\u000a				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\u000a			}\u000a\u000a			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\u000a			// IE8 throws error here and will not see later tests\u000a			if ( el.querySelectorAll(":enabled").length !== 2 ) {\u000a				rbuggyQSA.push( ":enabled", ":disabled" );\u000a			}\u000a\u000a			// Support: IE9-11+\u000a			// IE's :disabled selector does not pick up the children of disabled fieldsets\u000a			docElem.appendChild( el ).disabled = true;\u000a			if ( el.querySelectorAll(":disabled").length !== 2 ) {\u000a				rbuggyQSA.push( ":enabled", ":disabled" );\u000a			}\u000a\u000a			// Opera 10-11 does not throw on post-comma invalid pseudos\u000a			el.querySelectorAll("*,:x");\u000a			rbuggyQSA.push(",.*:");\u000a		});\u000a	}\u000a\u000a	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\u000a		docElem.webkitMatchesSelector ||\u000a		docElem.mozMatchesSelector ||\u000a		docElem.oMatchesSelector ||\u000a		docElem.msMatchesSelector) )) ) {\u000a\u000a		assert(function( el ) {\u000a			// Check to see if it's possible to do matchesSelector\u000a			// on a disconnected node (IE 9)\u000a			support.disconnectedMatch = matches.call( el, "*" );\u000a\u000a			// This should fail with an exception\u000a			// Gecko does not error, returns false instead\u000a			matches.call( el, "[s!='']:x" );\u000a			rbuggyMatches.push( "!=", pseudos );\u000a		});\u000a	}\u000a\u000a	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\u000a	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\u000a\u000a	/* Contains\u000a	---------------------------------------------------------------------- */\u000a	hasCompare = rnative.test( docElem.compareDocumentPosition );\u000a\u000a	// Element contains another\u000a	// Purposefully self-exclusive\u000a	// As in, an element does not contain itself\u000a	contains = hasCompare || rnative.test( docElem.contains ) ?\u000a		function( a, b ) {\u000a			var adown = a.nodeType === 9 ? a.documentElement : a,\u000a				bup = b && b.parentNode;\u000a			return a === bup || !!( bup && bup.nodeType === 1 && (\u000a				adown.contains ?\u000a					adown.contains( bup ) :\u000a					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\u000a			));\u000a		} :\u000a		function( a, b ) {\u000a			if ( b ) {\u000a				while ( (b = b.parentNode) ) {\u000a					if ( b === a ) {\u000a						return true;\u000a					}\u000a				}\u000a			}\u000a			return false;\u000a		};\u000a\u000a	/* Sorting\u000a	---------------------------------------------------------------------- */\u000a\u000a	// Document order sorting\u000a	sortOrder = hasCompare ?\u000a	function( a, b ) {\u000a\u000a		// Flag for duplicate removal\u000a		if ( a === b ) {\u000a			hasDuplicate = true;\u000a			return 0;\u000a		}\u000a\u000a		// Sort on method existence if only one input has compareDocumentPosition\u000a		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\u000a		if ( compare ) {\u000a			return compare;\u000a		}\u000a\u000a		// Calculate position if both inputs belong to the same document\u000a		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\u000a			a.compareDocumentPosition( b ) :\u000a\u000a			// Otherwise we know they are disconnected\u000a			1;\u000a\u000a		// Disconnected nodes\u000a		if ( compare & 1 ||\u000a			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\u000a\u000a			// Choose the first element that is related to our preferred document\u000a			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\u000a				return -1;\u000a			}\u000a			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\u000a				return 1;\u000a			}\u000a\u000a			// Maintain original order\u000a			return sortInput ?\u000a				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\u000a				0;\u000a		}\u000a\u000a		return compare & 4 ? -1 : 1;\u000a	} :\u000a	function( a, b ) {\u000a		// Exit early if the nodes are identical\u000a		if ( a === b ) {\u000a			hasDuplicate = true;\u000a			return 0;\u000a		}\u000a\u000a		var cur,\u000a			i = 0,\u000a			aup = a.parentNode,\u000a			bup = b.parentNode,\u000a			ap = [ a ],\u000a			bp = [ b ];\u000a\u000a		// Parentless nodes are either documents or disconnected\u000a		if ( !aup || !bup ) {\u000a			return a === document ? -1 :\u000a				b === document ? 1 :\u000a				aup ? -1 :\u000a				bup ? 1 :\u000a				sortInput ?\u000a				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\u000a				0;\u000a\u000a		// If the nodes are siblings, we can do a quick check\u000a		} else if ( aup === bup ) {\u000a			return siblingCheck( a, b );\u000a		}\u000a\u000a		// Otherwise we need full lists of their ancestors for comparison\u000a		cur = a;\u000a		while ( (cur = cur.parentNode) ) {\u000a			ap.unshift( cur );\u000a		}\u000a		cur = b;\u000a		while ( (cur = cur.parentNode) ) {\u000a			bp.unshift( cur );\u000a		}\u000a\u000a		// Walk down the tree looking for a discrepancy\u000a		while ( ap[i] === bp[i] ) {\u000a			i++;\u000a		}\u000a\u000a		return i ?\u000a			// Do a sibling check if the nodes have a common ancestor\u000a			siblingCheck( ap[i], bp[i] ) :\u000a\u000a			// Otherwise nodes in our document sort first\u000a			ap[i] === preferredDoc ? -1 :\u000a			bp[i] === preferredDoc ? 1 :\u000a			0;\u000a	};\u000a\u000a	return document;\u000a};\u000a\u000aSizzle.matches = function( expr, elements ) {\u000a	return Sizzle( expr, null, null, elements );\u000a};\u000a\u000aSizzle.matchesSelector = function( elem, expr ) {\u000a	// Set document vars if needed\u000a	if ( ( elem.ownerDocument || elem ) !== document ) {\u000a		setDocument( elem );\u000a	}\u000a\u000a	// Make sure that attribute selectors are quoted\u000a	expr = expr.replace( rattributeQuotes, "='$1']" );\u000a\u000a	if ( support.matchesSelector && documentIsHTML &&\u000a		!compilerCache[ expr + " " ] &&\u000a		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\u000a		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\u000a\u000a		try {\u000a			var ret = matches.call( elem, expr );\u000a\u000a			// IE 9's matchesSelector returns false on disconnected nodes\u000a			if ( ret || support.disconnectedMatch ||\u000a					// As well, disconnected nodes are said to be in a document\u000a					// fragment in IE 9\u000a					elem.document && elem.document.nodeType !== 11 ) {\u000a				return ret;\u000a			}\u000a		} catch (e) {}\u000a	}\u000a\u000a	return Sizzle( expr, document, null, [ elem ] ).length > 0;\u000a};\u000a\u000aSizzle.contains = function( context, elem ) {\u000a	// Set document vars if needed\u000a	if ( ( context.ownerDocument || context ) !== document ) {\u000a		setDocument( context );\u000a	}\u000a	return contains( context, elem );\u000a};\u000a\u000aSizzle.attr = function( elem, name ) {\u000a	// Set document vars if needed\u000a	if ( ( elem.ownerDocument || elem ) !== document ) {\u000a		setDocument( elem );\u000a	}\u000a\u000a	var fn = Expr.attrHandle[ name.toLowerCase() ],\u000a		// Don't get fooled by Object.prototype properties (jQuery #13807)\u000a		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\u000a			fn( elem, name, !documentIsHTML ) :\u000a			undefined;\u000a\u000a	return val !== undefined ?\u000a		val :\u000a		support.attributes || !documentIsHTML ?\u000a			elem.getAttribute( name ) :\u000a			(val = elem.getAttributeNode(name)) && val.specified ?\u000a				val.value :\u000a				null;\u000a};\u000a\u000aSizzle.escape = function( sel ) {\u000a	return (sel + "").replace( rcssescape, fcssescape );\u000a};\u000a\u000aSizzle.error = function( msg ) {\u000a	throw new Error( "Syntax error, unrecognized expression: " + msg );\u000a};\u000a\u000a/**\u000a * Document sorting and removing duplicates\u000a * @param {ArrayLike} results\u000a */\u000aSizzle.uniqueSort = function( results ) {\u000a	var elem,\u000a		duplicates = [],\u000a		j = 0,\u000a		i = 0;\u000a\u000a	// Unless we *know* we can detect duplicates, assume their presence\u000a	hasDuplicate = !support.detectDuplicates;\u000a	sortInput = !support.sortStable && results.slice( 0 );\u000a	results.sort( sortOrder );\u000a\u000a	if ( hasDuplicate ) {\u000a		while ( (elem = results[i++]) ) {\u000a			if ( elem === results[ i ] ) {\u000a				j = duplicates.push( i );\u000a			}\u000a		}\u000a		while ( j-- ) {\u000a			results.splice( duplicates[ j ], 1 );\u000a		}\u000a	}\u000a\u000a	// Clear input after sorting to release objects\u000a	// See https://github.com/jquery/sizzle/pull/225\u000a	sortInput = null;\u000a\u000a	return results;\u000a};\u000a\u000a/**\u000a * Utility function for retrieving the text value of an array of DOM nodes\u000a * @param {Array|Element} elem\u000a */\u000agetText = Sizzle.getText = function( elem ) {\u000a	var node,\u000a		ret = "",\u000a		i = 0,\u000a		nodeType = elem.nodeType;\u000a\u000a	if ( !nodeType ) {\u000a		// If no nodeType, this is expected to be an array\u000a		while ( (node = elem[i++]) ) {\u000a			// Do not traverse comment nodes\u000a			ret += getText( node );\u000a		}\u000a	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\u000a		// Use textContent for elements\u000a		// innerText usage removed for consistency of new lines (jQuery #11153)\u000a		if ( typeof elem.textContent === "string" ) {\u000a			return elem.textContent;\u000a		} else {\u000a			// Traverse its children\u000a			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\u000a				ret += getText( elem );\u000a			}\u000a		}\u000a	} else if ( nodeType === 3 || nodeType === 4 ) {\u000a		return elem.nodeValue;\u000a	}\u000a	// Do not include comment or processing instruction nodes\u000a\u000a	return ret;\u000a};\u000a\u000aExpr = Sizzle.selectors = {\u000a\u000a	// Can be adjusted by the user\u000a	cacheLength: 50,\u000a\u000a	createPseudo: markFunction,\u000a\u000a	match: matchExpr,\u000a\u000a	attrHandle: {},\u000a\u000a	find: {},\u000a\u000a	relative: {\u000a		">": { dir: "parentNode", first: true },\u000a		" ": { dir: "parentNode" },\u000a		"+": { dir: "previousSibling", first: true },\u000a		"~": { dir: "previousSibling" }\u000a	},\u000a\u000a	preFilter: {\u000a		"ATTR": function( match ) {\u000a			match[1] = match[1].replace( runescape, funescape );\u000a\u000a			// Move the given value to match[3] whether quoted or unquoted\u000a			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );\u000a\u000a			if ( match[2] === "~=" ) {\u000a				match[3] = " " + match[3] + " ";\u000a			}\u000a\u000a			return match.slice( 0, 4 );\u000a		},\u000a\u000a		"CHILD": function( match ) {\u000a			/* matches from matchExpr["CHILD"]\u000a				1 type (only|nth|...)\u000a				2 what (child|of-type)\u000a				3 argument (even|odd|\u005cd*|\u005cd*n([+-]\u005cd+)?|...)\u000a				4 xn-component of xn+y argument ([+-]?\u005cd*n|)\u000a				5 sign of xn-component\u000a				6 x of xn-component\u000a				7 sign of y-component\u000a				8 y of y-component\u000a			*/\u000a			match[1] = match[1].toLowerCase();\u000a\u000a			if ( match[1].slice( 0, 3 ) === "nth" ) {\u000a				// nth-* requires argument\u000a				if ( !match[3] ) {\u000a					Sizzle.error( match[0] );\u000a				}\u000a\u000a				// numeric x and y parameters for Expr.filter.CHILD\u000a				// remember that false/true cast respectively to 0/1\u000a				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\u000a				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\u000a\u000a			// other types prohibit arguments\u000a			} else if ( match[3] ) {\u000a				Sizzle.error( match[0] );\u000a			}\u000a\u000a			return match;\u000a		},\u000a\u000a		"PSEUDO": function( match ) {\u000a			var excess,\u000a				unquoted = !match[6] && match[2];\u000a\u000a			if ( matchExpr["CHILD"].test( match[0] ) ) {\u000a				return null;\u000a			}\u000a\u000a			// Accept quoted arguments as-is\u000a			if ( match[3] ) {\u000a				match[2] = match[4] || match[5] || "";\u000a\u000a			// Strip excess characters from unquoted arguments\u000a			} else if ( unquoted && rpseudo.test( unquoted ) &&\u000a				// Get excess from tokenize (recursively)\u000a				(excess = tokenize( unquoted, true )) &&\u000a				// advance to the next closing parenthesis\u000a				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\u000a\u000a				// excess is a negative index\u000a				match[0] = match[0].slice( 0, excess );\u000a				match[2] = unquoted.slice( 0, excess );\u000a			}\u000a\u000a			// Return only captures needed by the pseudo filter method (type and argument)\u000a			return match.slice( 0, 3 );\u000a		}\u000a	},\u000a\u000a	filter: {\u000a\u000a		"TAG": function( nodeNameSelector ) {\u000a			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\u000a			return nodeNameSelector === "*" ?\u000a				function() { return true; } :\u000a				function( elem ) {\u000a					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\u000a				};\u000a		},\u000a\u000a		"CLASS": function( className ) {\u000a			var pattern = classCache[ className + " " ];\u000a\u000a			return pattern ||\u000a				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\u000a				classCache( className, function( elem ) {\u000a					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );\u000a				});\u000a		},\u000a\u000a		"ATTR": function( name, operator, check ) {\u000a			return function( elem ) {\u000a				var result = Sizzle.attr( elem, name );\u000a\u000a				if ( result == null ) {\u000a					return operator === "!=";\u000a				}\u000a				if ( !operator ) {\u000a					return true;\u000a				}\u000a\u000a				result += "";\u000a\u000a				return operator === "=" ? result === check :\u000a					operator === "!=" ? result !== check :\u000a					operator === "^=" ? check && result.indexOf( check ) === 0 :\u000a					operator === "*=" ? check && result.indexOf( check ) > -1 :\u000a					operator === "$=" ? check && result.slice( -check.length ) === check :\u000a					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :\u000a					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\u000a					false;\u000a			};\u000a		},\u000a\u000a		"CHILD": function( type, what, argument, first, last ) {\u000a			var simple = type.slice( 0, 3 ) !== "nth",\u000a				forward = type.slice( -4 ) !== "last",\u000a				ofType = what === "of-type";\u000a\u000a			return first === 1 && last === 0 ?\u000a\u000a				// Shortcut for :nth-*(n)\u000a				function( elem ) {\u000a					return !!elem.parentNode;\u000a				} :\u000a\u000a				function( elem, context, xml ) {\u000a					var cache, uniqueCache, outerCache, node, nodeIndex, start,\u000a						dir = simple !== forward ? "nextSibling" : "previousSibling",\u000a						parent = elem.parentNode,\u000a						name = ofType && elem.nodeName.toLowerCase(),\u000a						useCache = !xml && !ofType,\u000a						diff = false;\u000a\u000a					if ( parent ) {\u000a\u000a						// :(first|last|only)-(child|of-type)\u000a						if ( simple ) {\u000a							while ( dir ) {\u000a								node = elem;\u000a								while ( (node = node[ dir ]) ) {\u000a									if ( ofType ?\u000a										node.nodeName.toLowerCase() === name :\u000a										node.nodeType === 1 ) {\u000a\u000a										return false;\u000a									}\u000a								}\u000a								// Reverse direction for :only-* (if we haven't yet done so)\u000a								start = dir = type === "only" && !start && "nextSibling";\u000a							}\u000a							return true;\u000a						}\u000a\u000a						start = [ forward ? parent.firstChild : parent.lastChild ];\u000a\u000a						// non-xml :nth-child(...) stores cache data on `parent`\u000a						if ( forward && useCache ) {\u000a\u000a							// Seek `elem` from a previously-cached index\u000a\u000a							// ...in a gzip-friendly way\u000a							node = parent;\u000a							outerCache = node[ expando ] || (node[ expando ] = {});\u000a\u000a							// Support: IE <9 only\u000a							// Defend against cloned attroperties (jQuery gh-1709)\u000a							uniqueCache = outerCache[ node.uniqueID ] ||\u000a								(outerCache[ node.uniqueID ] = {});\u000a\u000a							cache = uniqueCache[ type ] || [];\u000a							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\u000a							diff = nodeIndex && cache[ 2 ];\u000a							node = nodeIndex && parent.childNodes[ nodeIndex ];\u000a\u000a							while ( (node = ++nodeIndex && node && node[ dir ] ||\u000a\u000a								// Fallback to seeking `elem` from the start\u000a								(diff = nodeIndex = 0) || start.pop()) ) {\u000a\u000a								// When found, cache indexes on `parent` and break\u000a								if ( node.nodeType === 1 && ++diff && node === elem ) {\u000a									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\u000a									break;\u000a								}\u000a							}\u000a\u000a						} else {\u000a							// Use previously-cached element index if available\u000a							if ( useCache ) {\u000a								// ...in a gzip-friendly way\u000a								node = elem;\u000a								outerCache = node[ expando ] || (node[ expando ] = {});\u000a\u000a								// Support: IE <9 only\u000a								// Defend against cloned attroperties (jQuery gh-1709)\u000a								uniqueCache = outerCache[ node.uniqueID ] ||\u000a									(outerCache[ node.uniqueID ] = {});\u000a\u000a								cache = uniqueCache[ type ] || [];\u000a								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\u000a								diff = nodeIndex;\u000a							}\u000a\u000a							// xml :nth-child(...)\u000a							// or :nth-last-child(...) or :nth(-last)?-of-type(...)\u000a							if ( diff === false ) {\u000a								// Use the same loop as above to seek `elem` from the start\u000a								while ( (node = ++nodeIndex && node && node[ dir ] ||\u000a									(diff = nodeIndex = 0) || start.pop()) ) {\u000a\u000a									if ( ( ofType ?\u000a										node.nodeName.toLowerCase() === name :\u000a										node.nodeType === 1 ) &&\u000a										++diff ) {\u000a\u000a										// Cache the index of each encountered element\u000a										if ( useCache ) {\u000a											outerCache = node[ expando ] || (node[ expando ] = {});\u000a\u000a											// Support: IE <9 only\u000a											// Defend against cloned attroperties (jQuery gh-1709)\u000a											uniqueCache = outerCache[ node.uniqueID ] ||\u000a												(outerCache[ node.uniqueID ] = {});\u000a\u000a											uniqueCache[ type ] = [ dirruns, diff ];\u000a										}\u000a\u000a										if ( node === elem ) {\u000a											break;\u000a										}\u000a									}\u000a								}\u000a							}\u000a						}\u000a\u000a						// Incorporate the offset, then check against cycle size\u000a						diff -= last;\u000a						return diff === first || ( diff % first === 0 && diff / first >= 0 );\u000a					}\u000a				};\u000a		},\u000a\u000a		"PSEUDO": function( pseudo, argument ) {\u000a			// pseudo-class names are case-insensitive\u000a			// http://www.w3.org/TR/selectors/#pseudo-classes\u000a			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\u000a			// Remember that setFilters inherits from pseudos\u000a			var args,\u000a				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\u000a					Sizzle.error( "unsupported pseudo: " + pseudo );\u000a\u000a			// The user may use createPseudo to indicate that\u000a			// arguments are needed to create the filter function\u000a			// just as Sizzle does\u000a			if ( fn[ expando ] ) {\u000a				return fn( argument );\u000a			}\u000a\u000a			// But maintain support for old signatures\u000a			if ( fn.length > 1 ) {\u000a				args = [ pseudo, pseudo, "", argument ];\u000a				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\u000a					markFunction(function( seed, matches ) {\u000a						var idx,\u000a							matched = fn( seed, argument ),\u000a							i = matched.length;\u000a						while ( i-- ) {\u000a							idx = indexOf( seed, matched[i] );\u000a							seed[ idx ] = !( matches[ idx ] = matched[i] );\u000a						}\u000a					}) :\u000a					function( elem ) {\u000a						return fn( elem, 0, args );\u000a					};\u000a			}\u000a\u000a			return fn;\u000a		}\u000a	},\u000a\u000a	pseudos: {\u000a		// Potentially complex pseudos\u000a		"not": markFunction(function( selector ) {\u000a			// Trim the selector passed to compile\u000a			// to avoid treating leading and trailing\u000a			// spaces as combinators\u000a			var input = [],\u000a				results = [],\u000a				matcher = compile( selector.replace( rtrim, "$1" ) );\u000a\u000a			return matcher[ expando ] ?\u000a				markFunction(function( seed, matches, context, xml ) {\u000a					var elem,\u000a						unmatched = matcher( seed, null, xml, [] ),\u000a						i = seed.length;\u000a\u000a					// Match elements unmatched by `matcher`\u000a					while ( i-- ) {\u000a						if ( (elem = unmatched[i]) ) {\u000a							seed[i] = !(matches[i] = elem);\u000a						}\u000a					}\u000a				}) :\u000a				function( elem, context, xml ) {\u000a					input[0] = elem;\u000a					matcher( input, null, xml, results );\u000a					// Don't keep the element (issue #299)\u000a					input[0] = null;\u000a					return !results.pop();\u000a				};\u000a		}),\u000a\u000a		"has": markFunction(function( selector ) {\u000a			return function( elem ) {\u000a				return Sizzle( selector, elem ).length > 0;\u000a			};\u000a		}),\u000a\u000a		"contains": markFunction(function( text ) {\u000a			text = text.replace( runescape, funescape );\u000a			return function( elem ) {\u000a				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\u000a			};\u000a		}),\u000a\u000a		// "Whether an element is represented by a :lang() selector\u000a		// is based solely on the element's language value\u000a		// being equal to the identifier C,\u000a		// or beginning with the identifier C immediately followed by "-".\u000a		// The matching of C against the element's language value is performed case-insensitively.\u000a		// The identifier C does not have to be a valid language name."\u000a		// http://www.w3.org/TR/selectors/#lang-pseudo\u000a		"lang": markFunction( function( lang ) {\u000a			// lang value must be a valid identifier\u000a			if ( !ridentifier.test(lang || "") ) {\u000a				Sizzle.error( "unsupported lang: " + lang );\u000a			}\u000a			lang = lang.replace( runescape, funescape ).toLowerCase();\u000a			return function( elem ) {\u000a				var elemLang;\u000a				do {\u000a					if ( (elemLang = documentIsHTML ?\u000a						elem.lang :\u000a						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\u000a\u000a						elemLang = elemLang.toLowerCase();\u000a						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\u000a					}\u000a				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\u000a				return false;\u000a			};\u000a		}),\u000a\u000a		// Miscellaneous\u000a		"target": function( elem ) {\u000a			var hash = window.location && window.location.hash;\u000a			return hash && hash.slice( 1 ) === elem.id;\u000a		},\u000a\u000a		"root": function( elem ) {\u000a			return elem === docElem;\u000a		},\u000a\u000a		"focus": function( elem ) {\u000a			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\u000a		},\u000a\u000a		// Boolean properties\u000a		"enabled": createDisabledPseudo( false ),\u000a		"disabled": createDisabledPseudo( true ),\u000a\u000a		"checked": function( elem ) {\u000a			// In CSS3, :checked should return both checked and selected elements\u000a			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\u000a			var nodeName = elem.nodeName.toLowerCase();\u000a			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\u000a		},\u000a\u000a		"selected": function( elem ) {\u000a			// Accessing this property makes selected-by-default\u000a			// options in Safari work properly\u000a			if ( elem.parentNode ) {\u000a				elem.parentNode.selectedIndex;\u000a			}\u000a\u000a			return elem.selected === true;\u000a		},\u000a\u000a		// Contents\u000a		"empty": function( elem ) {\u000a			// http://www.w3.org/TR/selectors/#empty-pseudo\u000a			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\u000a			//   but not by others (comment: 8; processing instruction: 7; etc.)\u000a			// nodeType < 6 works because attributes (2) do not appear as children\u000a			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\u000a				if ( elem.nodeType < 6 ) {\u000a					return false;\u000a				}\u000a			}\u000a			return true;\u000a		},\u000a\u000a		"parent": function( elem ) {\u000a			return !Expr.pseudos["empty"]( elem );\u000a		},\u000a\u000a		// Element/input types\u000a		"header": function( elem ) {\u000a			return rheader.test( elem.nodeName );\u000a		},\u000a\u000a		"input": function( elem ) {\u000a			return rinputs.test( elem.nodeName );\u000a		},\u000a\u000a		"button": function( elem ) {\u000a			var name = elem.nodeName.toLowerCase();\u000a			return name === "input" && elem.type === "button" || name === "button";\u000a		},\u000a\u000a		"text": function( elem ) {\u000a			var attr;\u000a			return elem.nodeName.toLowerCase() === "input" &&\u000a				elem.type === "text" &&\u000a\u000a				// Support: IE<8\u000a				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\u000a				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );\u000a		},\u000a\u000a		// Position-in-collection\u000a		"first": createPositionalPseudo(function() {\u000a			return [ 0 ];\u000a		}),\u000a\u000a		"last": createPositionalPseudo(function( matchIndexes, length ) {\u000a			return [ length - 1 ];\u000a		}),\u000a\u000a		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\u000a			return [ argument < 0 ? argument + length : argument ];\u000a		}),\u000a\u000a		"even": createPositionalPseudo(function( matchIndexes, length ) {\u000a			var i = 0;\u000a			for ( ; i < length; i += 2 ) {\u000a				matchIndexes.push( i );\u000a			}\u000a			return matchIndexes;\u000a		}),\u000a\u000a		"odd": createPositionalPseudo(function( matchIndexes, length ) {\u000a			var i = 1;\u000a			for ( ; i < length; i += 2 ) {\u000a				matchIndexes.push( i );\u000a			}\u000a			return matchIndexes;\u000a		}),\u000a\u000a		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\u000a			var i = argument < 0 ? argument + length : argument;\u000a			for ( ; --i >= 0; ) {\u000a				matchIndexes.push( i );\u000a			}\u000a			return matchIndexes;\u000a		}),\u000a\u000a		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\u000a			var i = argument < 0 ? argument + length : argument;\u000a			for ( ; ++i < length; ) {\u000a				matchIndexes.push( i );\u000a			}\u000a			return matchIndexes;\u000a		})\u000a	}\u000a};\u000a\u000aExpr.pseudos["nth"] = Expr.pseudos["eq"];\u000a\u000a// Add button/input type pseudos\u000afor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\u000a	Expr.pseudos[ i ] = createInputPseudo( i );\u000a}\u000afor ( i in { submit: true, reset: true } ) {\u000a	Expr.pseudos[ i ] = createButtonPseudo( i );\u000a}\u000a\u000a// Easy API for creating new setFilters\u000afunction setFilters() {}\u000asetFilters.prototype = Expr.filters = Expr.pseudos;\u000aExpr.setFilters = new setFilters();\u000a\u000atokenize = Sizzle.tokenize = function( selector, parseOnly ) {\u000a	var matched, match, tokens, type,\u000a		soFar, groups, preFilters,\u000a		cached = tokenCache[ selector + " " ];\u000a\u000a	if ( cached ) {\u000a		return parseOnly ? 0 : cached.slice( 0 );\u000a	}\u000a\u000a	soFar = selector;\u000a	groups = [];\u000a	preFilters = Expr.preFilter;\u000a\u000a	while ( soFar ) {\u000a\u000a		// Comma and first run\u000a		if ( !matched || (match = rcomma.exec( soFar )) ) {\u000a			if ( match ) {\u000a				// Don't consume trailing commas as valid\u000a				soFar = soFar.slice( match[0].length ) || soFar;\u000a			}\u000a			groups.push( (tokens = []) );\u000a		}\u000a\u000a		matched = false;\u000a\u000a		// Combinators\u000a		if ( (match = rcombinators.exec( soFar )) ) {\u000a			matched = match.shift();\u000a			tokens.push({\u000a				value: matched,\u000a				// Cast descendant combinators to space\u000a				type: match[0].replace( rtrim, " " )\u000a			});\u000a			soFar = soFar.slice( matched.length );\u000a		}\u000a\u000a		// Filters\u000a		for ( type in Expr.filter ) {\u000a			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\u000a				(match = preFilters[ type ]( match ))) ) {\u000a				matched = match.shift();\u000a				tokens.push({\u000a					value: matched,\u000a					type: type,\u000a					matches: match\u000a				});\u000a				soFar = soFar.slice( matched.length );\u000a			}\u000a		}\u000a\u000a		if ( !matched ) {\u000a			break;\u000a		}\u000a	}\u000a\u000a	// Return the length of the invalid excess\u000a	// if we're just parsing\u000a	// Otherwise, throw an error or return tokens\u000a	return parseOnly ?\u000a		soFar.length :\u000a		soFar ?\u000a			Sizzle.error( selector ) :\u000a			// Cache the tokens\u000a			tokenCache( selector, groups ).slice( 0 );\u000a};\u000a\u000afunction toSelector( tokens ) {\u000a	var i = 0,\u000a		len = tokens.length,\u000a		selector = "";\u000a	for ( ; i < len; i++ ) {\u000a		selector += tokens[i].value;\u000a	}\u000a	return selector;\u000a}\u000a\u000afunction addCombinator( matcher, combinator, base ) {\u000a	var dir = combinator.dir,\u000a		skip = combinator.next,\u000a		key = skip || dir,\u000a		checkNonElements = base && key === "parentNode",\u000a		doneName = done++;\u000a\u000a	return combinator.first ?\u000a		// Check against closest ancestor/preceding element\u000a		function( elem, context, xml ) {\u000a			while ( (elem = elem[ dir ]) ) {\u000a				if ( elem.nodeType === 1 || checkNonElements ) {\u000a					return matcher( elem, context, xml );\u000a				}\u000a			}\u000a			return false;\u000a		} :\u000a\u000a		// Check against all ancestor/preceding elements\u000a		function( elem, context, xml ) {\u000a			var oldCache, uniqueCache, outerCache,\u000a				newCache = [ dirruns, doneName ];\u000a\u000a			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\u000a			if ( xml ) {\u000a				while ( (elem = elem[ dir ]) ) {\u000a					if ( elem.nodeType === 1 || checkNonElements ) {\u000a						if ( matcher( elem, context, xml ) ) {\u000a							return true;\u000a						}\u000a					}\u000a				}\u000a			} else {\u000a				while ( (elem = elem[ dir ]) ) {\u000a					if ( elem.nodeType === 1 || checkNonElements ) {\u000a						outerCache = elem[ expando ] || (elem[ expando ] = {});\u000a\u000a						// Support: IE <9 only\u000a						// Defend against cloned attroperties (jQuery gh-1709)\u000a						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\u000a\u000a						if ( skip && skip === elem.nodeName.toLowerCase() ) {\u000a							elem = elem[ dir ] || elem;\u000a						} else if ( (oldCache = uniqueCache[ key ]) &&\u000a							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\u000a\u000a							// Assign to newCache so results back-propagate to previous elements\u000a							return (newCache[ 2 ] = oldCache[ 2 ]);\u000a						} else {\u000a							// Reuse newcache so results back-propagate to previous elements\u000a							uniqueCache[ key ] = newCache;\u000a\u000a							// A match means we're done; a fail means we have to keep checking\u000a							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\u000a								return true;\u000a							}\u000a						}\u000a					}\u000a				}\u000a			}\u000a			return false;\u000a		};\u000a}\u000a\u000afunction elementMatcher( matchers ) {\u000a	return matchers.length > 1 ?\u000a		function( elem, context, xml ) {\u000a			var i = matchers.length;\u000a			while ( i-- ) {\u000a				if ( !matchers[i]( elem, context, xml ) ) {\u000a					return false;\u000a				}\u000a			}\u000a			return true;\u000a		} :\u000a		matchers[0];\u000a}\u000a\u000afunction multipleContexts( selector, contexts, results ) {\u000a	var i = 0,\u000a		len = contexts.length;\u000a	for ( ; i < len; i++ ) {\u000a		Sizzle( selector, contexts[i], results );\u000a	}\u000a	return results;\u000a}\u000a\u000afunction condense( unmatched, map, filter, context, xml ) {\u000a	var elem,\u000a		newUnmatched = [],\u000a		i = 0,\u000a		len = unmatched.length,\u000a		mapped = map != null;\u000a\u000a	for ( ; i < len; i++ ) {\u000a		if ( (elem = unmatched[i]) ) {\u000a			if ( !filter || filter( elem, context, xml ) ) {\u000a				newUnmatched.push( elem );\u000a				if ( mapped ) {\u000a					map.push( i );\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	return newUnmatched;\u000a}\u000a\u000afunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\u000a	if ( postFilter && !postFilter[ expando ] ) {\u000a		postFilter = setMatcher( postFilter );\u000a	}\u000a	if ( postFinder && !postFinder[ expando ] ) {\u000a		postFinder = setMatcher( postFinder, postSelector );\u000a	}\u000a	return markFunction(function( seed, results, context, xml ) {\u000a		var temp, i, elem,\u000a			preMap = [],\u000a			postMap = [],\u000a			preexisting = results.length,\u000a\u000a			// Get initial elements from seed or context\u000a			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\u000a\u000a			// Prefilter to get matcher input, preserving a map for seed-results synchronization\u000a			matcherIn = preFilter && ( seed || !selector ) ?\u000a				condense( elems, preMap, preFilter, context, xml ) :\u000a				elems,\u000a\u000a			matcherOut = matcher ?\u000a				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\u000a				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?\u000a\u000a					// ...intermediate processing is necessary\u000a					[] :\u000a\u000a					// ...otherwise use results directly\u000a					results :\u000a				matcherIn;\u000a\u000a		// Find primary matches\u000a		if ( matcher ) {\u000a			matcher( matcherIn, matcherOut, context, xml );\u000a		}\u000a\u000a		// Apply postFilter\u000a		if ( postFilter ) {\u000a			temp = condense( matcherOut, postMap );\u000a			postFilter( temp, [], context, xml );\u000a\u000a			// Un-match failing elements by moving them back to matcherIn\u000a			i = temp.length;\u000a			while ( i-- ) {\u000a				if ( (elem = temp[i]) ) {\u000a					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\u000a				}\u000a			}\u000a		}\u000a\u000a		if ( seed ) {\u000a			if ( postFinder || preFilter ) {\u000a				if ( postFinder ) {\u000a					// Get the final matcherOut by condensing this intermediate into postFinder contexts\u000a					temp = [];\u000a					i = matcherOut.length;\u000a					while ( i-- ) {\u000a						if ( (elem = matcherOut[i]) ) {\u000a							// Restore matcherIn since elem is not yet a final match\u000a							temp.push( (matcherIn[i] = elem) );\u000a						}\u000a					}\u000a					postFinder( null, (matcherOut = []), temp, xml );\u000a				}\u000a\u000a				// Move matched elements from seed to results to keep them synchronized\u000a				i = matcherOut.length;\u000a				while ( i-- ) {\u000a					if ( (elem = matcherOut[i]) &&\u000a						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\u000a\u000a						seed[temp] = !(results[temp] = elem);\u000a					}\u000a				}\u000a			}\u000a\u000a		// Add elements to results, through postFinder if defined\u000a		} else {\u000a			matcherOut = condense(\u000a				matcherOut === results ?\u000a					matcherOut.splice( preexisting, matcherOut.length ) :\u000a					matcherOut\u000a			);\u000a			if ( postFinder ) {\u000a				postFinder( null, results, matcherOut, xml );\u000a			} else {\u000a				push.apply( results, matcherOut );\u000a			}\u000a		}\u000a	});\u000a}\u000a\u000afunction matcherFromTokens( tokens ) {\u000a	var checkContext, matcher, j,\u000a		len = tokens.length,\u000a		leadingRelative = Expr.relative[ tokens[0].type ],\u000a		implicitRelative = leadingRelative || Expr.relative[" "],\u000a		i = leadingRelative ? 1 : 0,\u000a\u000a		// The foundational matcher ensures that elements are reachable from top-level context(s)\u000a		matchContext = addCombinator( function( elem ) {\u000a			return elem === checkContext;\u000a		}, implicitRelative, true ),\u000a		matchAnyContext = addCombinator( function( elem ) {\u000a			return indexOf( checkContext, elem ) > -1;\u000a		}, implicitRelative, true ),\u000a		matchers = [ function( elem, context, xml ) {\u000a			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\u000a				(checkContext = context).nodeType ?\u000a					matchContext( elem, context, xml ) :\u000a					matchAnyContext( elem, context, xml ) );\u000a			// Avoid hanging onto element (issue #299)\u000a			checkContext = null;\u000a			return ret;\u000a		} ];\u000a\u000a	for ( ; i < len; i++ ) {\u000a		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {\u000a			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\u000a		} else {\u000a			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\u000a\u000a			// Return special upon seeing a positional matcher\u000a			if ( matcher[ expando ] ) {\u000a				// Find the next relative operator (if any) for proper handling\u000a				j = ++i;\u000a				for ( ; j < len; j++ ) {\u000a					if ( Expr.relative[ tokens[j].type ] ) {\u000a						break;\u000a					}\u000a				}\u000a				return setMatcher(\u000a					i > 1 && elementMatcher( matchers ),\u000a					i > 1 && toSelector(\u000a						// If the preceding token was a descendant combinator, insert an implicit any-element `*`\u000a						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\u000a					).replace( rtrim, "$1" ),\u000a					matcher,\u000a					i < j && matcherFromTokens( tokens.slice( i, j ) ),\u000a					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\u000a					j < len && toSelector( tokens )\u000a				);\u000a			}\u000a			matchers.push( matcher );\u000a		}\u000a	}\u000a\u000a	return elementMatcher( matchers );\u000a}\u000a\u000afunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\u000a	var bySet = setMatchers.length > 0,\u000a		byElement = elementMatchers.length > 0,\u000a		superMatcher = function( seed, context, xml, results, outermost ) {\u000a			var elem, j, matcher,\u000a				matchedCount = 0,\u000a				i = "0",\u000a				unmatched = seed && [],\u000a				setMatched = [],\u000a				contextBackup = outermostContext,\u000a				// We must always have either seed elements or outermost context\u000a				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),\u000a				// Use integer dirruns iff this is the outermost matcher\u000a				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\u000a				len = elems.length;\u000a\u000a			if ( outermost ) {\u000a				outermostContext = context === document || context || outermost;\u000a			}\u000a\u000a			// Add elements passing elementMatchers directly to results\u000a			// Support: IE<9, Safari\u000a			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\u000a			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {\u000a				if ( byElement && elem ) {\u000a					j = 0;\u000a					if ( !context && elem.ownerDocument !== document ) {\u000a						setDocument( elem );\u000a						xml = !documentIsHTML;\u000a					}\u000a					while ( (matcher = elementMatchers[j++]) ) {\u000a						if ( matcher( elem, context || document, xml) ) {\u000a							results.push( elem );\u000a							break;\u000a						}\u000a					}\u000a					if ( outermost ) {\u000a						dirruns = dirrunsUnique;\u000a					}\u000a				}\u000a\u000a				// Track unmatched elements for set filters\u000a				if ( bySet ) {\u000a					// They will have gone through all possible matchers\u000a					if ( (elem = !matcher && elem) ) {\u000a						matchedCount--;\u000a					}\u000a\u000a					// Lengthen the array for every element, matched or not\u000a					if ( seed ) {\u000a						unmatched.push( elem );\u000a					}\u000a				}\u000a			}\u000a\u000a			// `i` is now the count of elements visited above, and adding it to `matchedCount`\u000a			// makes the latter nonnegative.\u000a			matchedCount += i;\u000a\u000a			// Apply set filters to unmatched elements\u000a			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\u000a			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\u000a			// no element matchers and no seed.\u000a			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that\u000a			// case, which will result in a "00" `matchedCount` that differs from `i` but is also\u000a			// numerically zero.\u000a			if ( bySet && i !== matchedCount ) {\u000a				j = 0;\u000a				while ( (matcher = setMatchers[j++]) ) {\u000a					matcher( unmatched, setMatched, context, xml );\u000a				}\u000a\u000a				if ( seed ) {\u000a					// Reintegrate element matches to eliminate the need for sorting\u000a					if ( matchedCount > 0 ) {\u000a						while ( i-- ) {\u000a							if ( !(unmatched[i] || setMatched[i]) ) {\u000a								setMatched[i] = pop.call( results );\u000a							}\u000a						}\u000a					}\u000a\u000a					// Discard index placeholder values to get only actual matches\u000a					setMatched = condense( setMatched );\u000a				}\u000a\u000a				// Add matches to results\u000a				push.apply( results, setMatched );\u000a\u000a				// Seedless set matches succeeding multiple successful matchers stipulate sorting\u000a				if ( outermost && !seed && setMatched.length > 0 &&\u000a					( matchedCount + setMatchers.length ) > 1 ) {\u000a\u000a					Sizzle.uniqueSort( results );\u000a				}\u000a			}\u000a\u000a			// Override manipulation of globals by nested matchers\u000a			if ( outermost ) {\u000a				dirruns = dirrunsUnique;\u000a				outermostContext = contextBackup;\u000a			}\u000a\u000a			return unmatched;\u000a		};\u000a\u000a	return bySet ?\u000a		markFunction( superMatcher ) :\u000a		superMatcher;\u000a}\u000a\u000acompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\u000a	var i,\u000a		setMatchers = [],\u000a		elementMatchers = [],\u000a		cached = compilerCache[ selector + " " ];\u000a\u000a	if ( !cached ) {\u000a		// Generate a function of recursive functions that can be used to check each element\u000a		if ( !match ) {\u000a			match = tokenize( selector );\u000a		}\u000a		i = match.length;\u000a		while ( i-- ) {\u000a			cached = matcherFromTokens( match[i] );\u000a			if ( cached[ expando ] ) {\u000a				setMatchers.push( cached );\u000a			} else {\u000a				elementMatchers.push( cached );\u000a			}\u000a		}\u000a\u000a		// Cache the compiled function\u000a		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\u000a\u000a		// Save selector and tokenization\u000a		cached.selector = selector;\u000a	}\u000a	return cached;\u000a};\u000a\u000a/**\u000a * A low-level selection function that works with Sizzle's compiled\u000a *  selector functions\u000a * @param {String|Function} selector A selector or a pre-compiled\u000a *  selector function built with Sizzle.compile\u000a * @param {Element} context\u000a * @param {Array} [results]\u000a * @param {Array} [seed] A set of elements to match against\u000a */\u000aselect = Sizzle.select = function( selector, context, results, seed ) {\u000a	var i, tokens, token, type, find,\u000a		compiled = typeof selector === "function" && selector,\u000a		match = !seed && tokenize( (selector = compiled.selector || selector) );\u000a\u000a	results = results || [];\u000a\u000a	// Try to minimize operations if there is only one selector in the list and no seed\u000a	// (the latter of which guarantees us context)\u000a	if ( match.length === 1 ) {\u000a\u000a		// Reduce context if the leading compound selector is an ID\u000a		tokens = match[0] = match[0].slice( 0 );\u000a		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\u000a				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\u000a\u000a			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\u000a			if ( !context ) {\u000a				return results;\u000a\u000a			// Precompiled matchers will still verify ancestry, so step up a level\u000a			} else if ( compiled ) {\u000a				context = context.parentNode;\u000a			}\u000a\u000a			selector = selector.slice( tokens.shift().value.length );\u000a		}\u000a\u000a		// Fetch a seed set for right-to-left matching\u000a		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\u000a		while ( i-- ) {\u000a			token = tokens[i];\u000a\u000a			// Abort if we hit a combinator\u000a			if ( Expr.relative[ (type = token.type) ] ) {\u000a				break;\u000a			}\u000a			if ( (find = Expr.find[ type ]) ) {\u000a				// Search, expanding context for leading sibling combinators\u000a				if ( (seed = find(\u000a					token.matches[0].replace( runescape, funescape ),\u000a					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\u000a				)) ) {\u000a\u000a					// If seed is empty or no tokens remain, we can return early\u000a					tokens.splice( i, 1 );\u000a					selector = seed.length && toSelector( tokens );\u000a					if ( !selector ) {\u000a						push.apply( results, seed );\u000a						return results;\u000a					}\u000a\u000a					break;\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	// Compile and execute a filtering function if one is not provided\u000a	// Provide `match` to avoid retokenization if we modified the selector above\u000a	( compiled || compile( selector, match ) )(\u000a		seed,\u000a		context,\u000a		!documentIsHTML,\u000a		results,\u000a		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\u000a	);\u000a	return results;\u000a};\u000a\u000a// One-time assignments\u000a\u000a// Sort stability\u000asupport.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\u000a\u000a// Support: Chrome 14-35+\u000a// Always assume duplicates if they aren't passed to the comparison function\u000asupport.detectDuplicates = !!hasDuplicate;\u000a\u000a// Initialize against the default document\u000asetDocument();\u000a\u000a// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\u000a// Detached nodes confoundingly follow *each other*\u000asupport.sortDetached = assert(function( el ) {\u000a	// Should return 1, but returns 4 (following)\u000a	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;\u000a});\u000a\u000a// Support: IE<8\u000a// Prevent attribute/property "interpolation"\u000a// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\u000aif ( !assert(function( el ) {\u000a	el.innerHTML = "<a href='#'></a>";\u000a	return el.firstChild.getAttribute("href") === "#" ;\u000a}) ) {\u000a	addHandle( "type|href|height|width", function( elem, name, isXML ) {\u000a		if ( !isXML ) {\u000a			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\u000a		}\u000a	});\u000a}\u000a\u000a// Support: IE<9\u000a// Use defaultValue in place of getAttribute("value")\u000aif ( !support.attributes || !assert(function( el ) {\u000a	el.innerHTML = "<input/>";\u000a	el.firstChild.setAttribute( "value", "" );\u000a	return el.firstChild.getAttribute( "value" ) === "";\u000a}) ) {\u000a	addHandle( "value", function( elem, name, isXML ) {\u000a		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\u000a			return elem.defaultValue;\u000a		}\u000a	});\u000a}\u000a\u000a// Support: IE<9\u000a// Use getAttributeNode to fetch booleans when getAttribute lies\u000aif ( !assert(function( el ) {\u000a	return el.getAttribute("disabled") == null;\u000a}) ) {\u000a	addHandle( booleans, function( elem, name, isXML ) {\u000a		var val;\u000a		if ( !isXML ) {\u000a			return elem[ name ] === true ? name.toLowerCase() :\u000a					(val = elem.getAttributeNode( name )) && val.specified ?\u000a					val.value :\u000a				null;\u000a		}\u000a	});\u000a}\u000a\u000areturn Sizzle;\u000a\u000a})( window );\u000a\u000a\u000a\u000ajQuery.find = Sizzle;\u000ajQuery.expr = Sizzle.selectors;\u000a\u000a// Deprecated\u000ajQuery.expr[ ":" ] = jQuery.expr.pseudos;\u000ajQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\u000ajQuery.text = Sizzle.getText;\u000ajQuery.isXMLDoc = Sizzle.isXML;\u000ajQuery.contains = Sizzle.contains;\u000ajQuery.escapeSelector = Sizzle.escape;\u000a\u000a\u000a\u000a\u000avar dir = function( elem, dir, until ) {\u000a	var matched = [],\u000a		truncate = until !== undefined;\u000a\u000a	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\u000a		if ( elem.nodeType === 1 ) {\u000a			if ( truncate && jQuery( elem ).is( until ) ) {\u000a				break;\u000a			}\u000a			matched.push( elem );\u000a		}\u000a	}\u000a	return matched;\u000a};\u000a\u000a\u000avar siblings = function( n, elem ) {\u000a	var matched = [];\u000a\u000a	for ( ; n; n = n.nextSibling ) {\u000a		if ( n.nodeType === 1 && n !== elem ) {\u000a			matched.push( n );\u000a		}\u000a	}\u000a\u000a	return matched;\u000a};\u000a\u000a\u000avar rneedsContext = jQuery.expr.match.needsContext;\u000a\u000a\u000a\u000afunction nodeName( elem, name ) {\u000a\u000a  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\u000a\u000a};\u000avar rsingleTag = ( /^<([a-z][^\u005c/\u005c0>:\u005cx20\u005ct\u005cr\u005cn\u005cf]*)[\u005cx20\u005ct\u005cr\u005cn\u005cf]*\u005c/?>(?:<\u005c/\u005c1>|)$/i );\u000a\u000a\u000a\u000a// Implement the identical functionality for filter and not\u000afunction winnow( elements, qualifier, not ) {\u000a	if ( isFunction( qualifier ) ) {\u000a		return jQuery.grep( elements, function( elem, i ) {\u000a			return !!qualifier.call( elem, i, elem ) !== not;\u000a		} );\u000a	}\u000a\u000a	// Single element\u000a	if ( qualifier.nodeType ) {\u000a		return jQuery.grep( elements, function( elem ) {\u000a			return ( elem === qualifier ) !== not;\u000a		} );\u000a	}\u000a\u000a	// Arraylike of elements (jQuery, arguments, Array)\u000a	if ( typeof qualifier !== "string" ) {\u000a		return jQuery.grep( elements, function( elem ) {\u000a			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;\u000a		} );\u000a	}\u000a\u000a	// Filtered directly for both simple and complex selectors\u000a	return jQuery.filter( qualifier, elements, not );\u000a}\u000a\u000ajQuery.filter = function( expr, elems, not ) {\u000a	var elem = elems[ 0 ];\u000a\u000a	if ( not ) {\u000a		expr = ":not(" + expr + ")";\u000a	}\u000a\u000a	if ( elems.length === 1 && elem.nodeType === 1 ) {\u000a		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\u000a	}\u000a\u000a	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\u000a		return elem.nodeType === 1;\u000a	} ) );\u000a};\u000a\u000ajQuery.fn.extend( {\u000a	find: function( selector ) {\u000a		var i, ret,\u000a			len = this.length,\u000a			self = this;\u000a\u000a		if ( typeof selector !== "string" ) {\u000a			return this.pushStack( jQuery( selector ).filter( function() {\u000a				for ( i = 0; i < len; i++ ) {\u000a					if ( jQuery.contains( self[ i ], this ) ) {\u000a						return true;\u000a					}\u000a				}\u000a			} ) );\u000a		}\u000a\u000a		ret = this.pushStack( [] );\u000a\u000a		for ( i = 0; i < len; i++ ) {\u000a			jQuery.find( selector, self[ i ], ret );\u000a		}\u000a\u000a		return len > 1 ? jQuery.uniqueSort( ret ) : ret;\u000a	},\u000a	filter: function( selector ) {\u000a		return this.pushStack( winnow( this, selector || [], false ) );\u000a	},\u000a	not: function( selector ) {\u000a		return this.pushStack( winnow( this, selector || [], true ) );\u000a	},\u000a	is: function( selector ) {\u000a		return !!winnow(\u000a			this,\u000a\u000a			// If this is a positional/relative selector, check membership in the returned set\u000a			// so $("p:first").is("p:last") won't return true for a doc with two "p".\u000a			typeof selector === "string" && rneedsContext.test( selector ) ?\u000a				jQuery( selector ) :\u000a				selector || [],\u000a			false\u000a		).length;\u000a	}\u000a} );\u000a\u000a\u000a// Initialize a jQuery object\u000a\u000a\u000a// A central reference to the root jQuery(document)\u000avar rootjQuery,\u000a\u000a	// A simple way to check for HTML strings\u000a	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\u000a	// Strict HTML recognition (#11290: must start with <)\u000a	// Shortcut simple #id case for speed\u000a	rquickExpr = /^(?:\u005cs*(<[\u005cw\u005cW]+>)[^>]*|#([\u005cw-]+))$/,\u000a\u000a	init = jQuery.fn.init = function( selector, context, root ) {\u000a		var match, elem;\u000a\u000a		// HANDLE: $(""), $(null), $(undefined), $(false)\u000a		if ( !selector ) {\u000a			return this;\u000a		}\u000a\u000a		// Method init() accepts an alternate rootjQuery\u000a		// so migrate can support jQuery.sub (gh-2101)\u000a		root = root || rootjQuery;\u000a\u000a		// Handle HTML strings\u000a		if ( typeof selector === "string" ) {\u000a			if ( selector[ 0 ] === "<" &&\u000a				selector[ selector.length - 1 ] === ">" &&\u000a				selector.length >= 3 ) {\u000a\u000a				// Assume that strings that start and end with <> are HTML and skip the regex check\u000a				match = [ null, selector, null ];\u000a\u000a			} else {\u000a				match = rquickExpr.exec( selector );\u000a			}\u000a\u000a			// Match html or make sure no context is specified for #id\u000a			if ( match && ( match[ 1 ] || !context ) ) {\u000a\u000a				// HANDLE: $(html) -> $(array)\u000a				if ( match[ 1 ] ) {\u000a					context = context instanceof jQuery ? context[ 0 ] : context;\u000a\u000a					// Option to run scripts is true for back-compat\u000a					// Intentionally let the error be thrown if parseHTML is not present\u000a					jQuery.merge( this, jQuery.parseHTML(\u000a						match[ 1 ],\u000a						context && context.nodeType ? context.ownerDocument || context : document,\u000a						true\u000a					) );\u000a\u000a					// HANDLE: $(html, props)\u000a					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\u000a						for ( match in context ) {\u000a\u000a							// Properties of context are called as methods if possible\u000a							if ( isFunction( this[ match ] ) ) {\u000a								this[ match ]( context[ match ] );\u000a\u000a							// ...and otherwise set as attributes\u000a							} else {\u000a								this.attr( match, context[ match ] );\u000a							}\u000a						}\u000a					}\u000a\u000a					return this;\u000a\u000a				// HANDLE: $(#id)\u000a				} else {\u000a					elem = document.getElementById( match[ 2 ] );\u000a\u000a					if ( elem ) {\u000a\u000a						// Inject the element directly into the jQuery object\u000a						this[ 0 ] = elem;\u000a						this.length = 1;\u000a					}\u000a					return this;\u000a				}\u000a\u000a			// HANDLE: $(expr, $(...))\u000a			} else if ( !context || context.jquery ) {\u000a				return ( context || root ).find( selector );\u000a\u000a			// HANDLE: $(expr, context)\u000a			// (which is just equivalent to: $(context).find(expr)\u000a			} else {\u000a				return this.constructor( context ).find( selector );\u000a			}\u000a\u000a		// HANDLE: $(DOMElement)\u000a		} else if ( selector.nodeType ) {\u000a			this[ 0 ] = selector;\u000a			this.length = 1;\u000a			return this;\u000a\u000a		// HANDLE: $(function)\u000a		// Shortcut for document ready\u000a		} else if ( isFunction( selector ) ) {\u000a			return root.ready !== undefined ?\u000a				root.ready( selector ) :\u000a\u000a				// Execute immediately if ready is not present\u000a				selector( jQuery );\u000a		}\u000a\u000a		return jQuery.makeArray( selector, this );\u000a	};\u000a\u000a// Give the init function the jQuery prototype for later instantiation\u000ainit.prototype = jQuery.fn;\u000a\u000a// Initialize central reference\u000arootjQuery = jQuery( document );\u000a\u000a\u000avar rparentsprev = /^(?:parents|prev(?:Until|All))/,\u000a\u000a	// Methods guaranteed to produce a unique set when starting from a unique set\u000a	guaranteedUnique = {\u000a		children: true,\u000a		contents: true,\u000a		next: true,\u000a		prev: true\u000a	};\u000a\u000ajQuery.fn.extend( {\u000a	has: function( target ) {\u000a		var targets = jQuery( target, this ),\u000a			l = targets.length;\u000a\u000a		return this.filter( function() {\u000a			var i = 0;\u000a			for ( ; i < l; i++ ) {\u000a				if ( jQuery.contains( this, targets[ i ] ) ) {\u000a					return true;\u000a				}\u000a			}\u000a		} );\u000a	},\u000a\u000a	closest: function( selectors, context ) {\u000a		var cur,\u000a			i = 0,\u000a			l = this.length,\u000a			matched = [],\u000a			targets = typeof selectors !== "string" && jQuery( selectors );\u000a\u000a		// Positional selectors never match, since there's no _selection_ context\u000a		if ( !rneedsContext.test( selectors ) ) {\u000a			for ( ; i < l; i++ ) {\u000a				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\u000a\u000a					// Always skip document fragments\u000a					if ( cur.nodeType < 11 && ( targets ?\u000a						targets.index( cur ) > -1 :\u000a\u000a						// Don't pass non-elements to Sizzle\u000a						cur.nodeType === 1 &&\u000a							jQuery.find.matchesSelector( cur, selectors ) ) ) {\u000a\u000a						matched.push( cur );\u000a						break;\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\u000a	},\u000a\u000a	// Determine the position of an element within the set\u000a	index: function( elem ) {\u000a\u000a		// No argument, return index in parent\u000a		if ( !elem ) {\u000a			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\u000a		}\u000a\u000a		// Index in selector\u000a		if ( typeof elem === "string" ) {\u000a			return indexOf.call( jQuery( elem ), this[ 0 ] );\u000a		}\u000a\u000a		// Locate the position of the desired element\u000a		return indexOf.call( this,\u000a\u000a			// If it receives a jQuery object, the first element is used\u000a			elem.jquery ? elem[ 0 ] : elem\u000a		);\u000a	},\u000a\u000a	add: function( selector, context ) {\u000a		return this.pushStack(\u000a			jQuery.uniqueSort(\u000a				jQuery.merge( this.get(), jQuery( selector, context ) )\u000a			)\u000a		);\u000a	},\u000a\u000a	addBack: function( selector ) {\u000a		return this.add( selector == null ?\u000a			this.prevObject : this.prevObject.filter( selector )\u000a		);\u000a	}\u000a} );\u000a\u000afunction sibling( cur, dir ) {\u000a	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\u000a	return cur;\u000a}\u000a\u000ajQuery.each( {\u000a	parent: function( elem ) {\u000a		var parent = elem.parentNode;\u000a		return parent && parent.nodeType !== 11 ? parent : null;\u000a	},\u000a	parents: function( elem ) {\u000a		return dir( elem, "parentNode" );\u000a	},\u000a	parentsUntil: function( elem, i, until ) {\u000a		return dir( elem, "parentNode", until );\u000a	},\u000a	next: function( elem ) {\u000a		return sibling( elem, "nextSibling" );\u000a	},\u000a	prev: function( elem ) {\u000a		return sibling( elem, "previousSibling" );\u000a	},\u000a	nextAll: function( elem ) {\u000a		return dir( elem, "nextSibling" );\u000a	},\u000a	prevAll: function( elem ) {\u000a		return dir( elem, "previousSibling" );\u000a	},\u000a	nextUntil: function( elem, i, until ) {\u000a		return dir( elem, "nextSibling", until );\u000a	},\u000a	prevUntil: function( elem, i, until ) {\u000a		return dir( elem, "previousSibling", until );\u000a	},\u000a	siblings: function( elem ) {\u000a		return siblings( ( elem.parentNode || {} ).firstChild, elem );\u000a	},\u000a	children: function( elem ) {\u000a		return siblings( elem.firstChild );\u000a	},\u000a	contents: function( elem ) {\u000a        if ( nodeName( elem, "iframe" ) ) {\u000a            return elem.contentDocument;\u000a        }\u000a\u000a        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\u000a        // Treat the template element as a regular one in browsers that\u000a        // don't support it.\u000a        if ( nodeName( elem, "template" ) ) {\u000a            elem = elem.content || elem;\u000a        }\u000a\u000a        return jQuery.merge( [], elem.childNodes );\u000a	}\u000a}, function( name, fn ) {\u000a	jQuery.fn[ name ] = function( until, selector ) {\u000a		var matched = jQuery.map( this, fn, until );\u000a\u000a		if ( name.slice( -5 ) !== "Until" ) {\u000a			selector = until;\u000a		}\u000a\u000a		if ( selector && typeof selector === "string" ) {\u000a			matched = jQuery.filter( selector, matched );\u000a		}\u000a\u000a		if ( this.length > 1 ) {\u000a\u000a			// Remove duplicates\u000a			if ( !guaranteedUnique[ name ] ) {\u000a				jQuery.uniqueSort( matched );\u000a			}\u000a\u000a			// Reverse order for parents* and prev-derivatives\u000a			if ( rparentsprev.test( name ) ) {\u000a				matched.reverse();\u000a			}\u000a		}\u000a\u000a		return this.pushStack( matched );\u000a	};\u000a} );\u000avar rnothtmlwhite = ( /[^\u005cx20\u005ct\u005cr\u005cn\u005cf]+/g );\u000a\u000a\u000a\u000a// Convert String-formatted options into Object-formatted ones\u000afunction createOptions( options ) {\u000a	var object = {};\u000a	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\u000a		object[ flag ] = true;\u000a	} );\u000a	return object;\u000a}\u000a\u000a/*\u000a * Create a callback list using the following parameters:\u000a *\u000a *	options: an optional list of space-separated options that will change how\u000a *			the callback list behaves or a more traditional option object\u000a *\u000a * By default a callback list will act like an event callback list and can be\u000a * "fired" multiple times.\u000a *\u000a * Possible options:\u000a *\u000a *	once:			will ensure the callback list can only be fired once (like a Deferred)\u000a *\u000a *	memory:			will keep track of previous values and will call any callback added\u000a *					after the list has been fired right away with the latest "memorized"\u000a *					values (like a Deferred)\u000a *\u000a *	unique:			will ensure a callback can only be added once (no duplicate in the list)\u000a *\u000a *	stopOnFalse:	interrupt callings when a callback returns false\u000a *\u000a */\u000ajQuery.Callbacks = function( options ) {\u000a\u000a	// Convert options from String-formatted to Object-formatted if needed\u000a	// (we check in cache first)\u000a	options = typeof options === "string" ?\u000a		createOptions( options ) :\u000a		jQuery.extend( {}, options );\u000a\u000a	var // Flag to know if list is currently firing\u000a		firing,\u000a\u000a		// Last fire value for non-forgettable lists\u000a		memory,\u000a\u000a		// Flag to know if list was already fired\u000a		fired,\u000a\u000a		// Flag to prevent firing\u000a		locked,\u000a\u000a		// Actual callback list\u000a		list = [],\u000a\u000a		// Queue of execution data for repeatable lists\u000a		queue = [],\u000a\u000a		// Index of currently firing callback (modified by add/remove as needed)\u000a		firingIndex = -1,\u000a\u000a		// Fire callbacks\u000a		fire = function() {\u000a\u000a			// Enforce single-firing\u000a			locked = locked || options.once;\u000a\u000a			// Execute callbacks for all pending executions,\u000a			// respecting firingIndex overrides and runtime changes\u000a			fired = firing = true;\u000a			for ( ; queue.length; firingIndex = -1 ) {\u000a				memory = queue.shift();\u000a				while ( ++firingIndex < list.length ) {\u000a\u000a					// Run callback and check for early termination\u000a					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\u000a						options.stopOnFalse ) {\u000a\u000a						// Jump to end and forget the data so .add doesn't re-fire\u000a						firingIndex = list.length;\u000a						memory = false;\u000a					}\u000a				}\u000a			}\u000a\u000a			// Forget the data if we're done with it\u000a			if ( !options.memory ) {\u000a				memory = false;\u000a			}\u000a\u000a			firing = false;\u000a\u000a			// Clean up if we're done firing for good\u000a			if ( locked ) {\u000a\u000a				// Keep an empty list if we have data for future add calls\u000a				if ( memory ) {\u000a					list = [];\u000a\u000a				// Otherwise, this object is spent\u000a				} else {\u000a					list = "";\u000a				}\u000a			}\u000a		},\u000a\u000a		// Actual Callbacks object\u000a		self = {\u000a\u000a			// Add a callback or a collection of callbacks to the list\u000a			add: function() {\u000a				if ( list ) {\u000a\u000a					// If we have memory from a past run, we should fire after adding\u000a					if ( memory && !firing ) {\u000a						firingIndex = list.length - 1;\u000a						queue.push( memory );\u000a					}\u000a\u000a					( function add( args ) {\u000a						jQuery.each( args, function( _, arg ) {\u000a							if ( isFunction( arg ) ) {\u000a								if ( !options.unique || !self.has( arg ) ) {\u000a									list.push( arg );\u000a								}\u000a							} else if ( arg && arg.length && toType( arg ) !== "string" ) {\u000a\u000a								// Inspect recursively\u000a								add( arg );\u000a							}\u000a						} );\u000a					} )( arguments );\u000a\u000a					if ( memory && !firing ) {\u000a						fire();\u000a					}\u000a				}\u000a				return this;\u000a			},\u000a\u000a			// Remove a callback from the list\u000a			remove: function() {\u000a				jQuery.each( arguments, function( _, arg ) {\u000a					var index;\u000a					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\u000a						list.splice( index, 1 );\u000a\u000a						// Handle firing indexes\u000a						if ( index <= firingIndex ) {\u000a							firingIndex--;\u000a						}\u000a					}\u000a				} );\u000a				return this;\u000a			},\u000a\u000a			// Check if a given callback is in the list.\u000a			// If no argument is given, return whether or not list has callbacks attached.\u000a			has: function( fn ) {\u000a				return fn ?\u000a					jQuery.inArray( fn, list ) > -1 :\u000a					list.length > 0;\u000a			},\u000a\u000a			// Remove all callbacks from the list\u000a			empty: function() {\u000a				if ( list ) {\u000a					list = [];\u000a				}\u000a				return this;\u000a			},\u000a\u000a			// Disable .fire and .add\u000a			// Abort any current/pending executions\u000a			// Clear all callbacks and values\u000a			disable: function() {\u000a				locked = queue = [];\u000a				list = memory = "";\u000a				return this;\u000a			},\u000a			disabled: function() {\u000a				return !list;\u000a			},\u000a\u000a			// Disable .fire\u000a			// Also disable .add unless we have memory (since it would have no effect)\u000a			// Abort any pending executions\u000a			lock: function() {\u000a				locked = queue = [];\u000a				if ( !memory && !firing ) {\u000a					list = memory = "";\u000a				}\u000a				return this;\u000a			},\u000a			locked: function() {\u000a				return !!locked;\u000a			},\u000a\u000a			// Call all callbacks with the given context and arguments\u000a			fireWith: function( context, args ) {\u000a				if ( !locked ) {\u000a					args = args || [];\u000a					args = [ context, args.slice ? args.slice() : args ];\u000a					queue.push( args );\u000a					if ( !firing ) {\u000a						fire();\u000a					}\u000a				}\u000a				return this;\u000a			},\u000a\u000a			// Call all the callbacks with the given arguments\u000a			fire: function() {\u000a				self.fireWith( this, arguments );\u000a				return this;\u000a			},\u000a\u000a			// To know if the callbacks have already been called at least once\u000a			fired: function() {\u000a				return !!fired;\u000a			}\u000a		};\u000a\u000a	return self;\u000a};\u000a\u000a\u000afunction Identity( v ) {\u000a	return v;\u000a}\u000afunction Thrower( ex ) {\u000a	throw ex;\u000a}\u000a\u000afunction adoptValue( value, resolve, reject, noValue ) {\u000a	var method;\u000a\u000a	try {\u000a\u000a		// Check for promise aspect first to privilege synchronous behavior\u000a		if ( value && isFunction( ( method = value.promise ) ) ) {\u000a			method.call( value ).done( resolve ).fail( reject );\u000a\u000a		// Other thenables\u000a		} else if ( value && isFunction( ( method = value.then ) ) ) {\u000a			method.call( value, resolve, reject );\u000a\u000a		// Other non-thenables\u000a		} else {\u000a\u000a			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\u000a			// * false: [ value ].slice( 0 ) => resolve( value )\u000a			// * true: [ value ].slice( 1 ) => resolve()\u000a			resolve.apply( undefined, [ value ].slice( noValue ) );\u000a		}\u000a\u000a	// For Promises/A+, convert exceptions into rejections\u000a	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\u000a	// Deferred#then to conditionally suppress rejection.\u000a	} catch ( value ) {\u000a\u000a		// Support: Android 4.0 only\u000a		// Strict mode functions invoked without .call/.apply get global-object context\u000a		reject.apply( undefined, [ value ] );\u000a	}\u000a}\u000a\u000ajQuery.extend( {\u000a\u000a	Deferred: function( func ) {\u000a		var tuples = [\u000a\u000a				// action, add listener, callbacks,\u000a				// ... .then handlers, argument index, [final state]\u000a				[ "notify", "progress", jQuery.Callbacks( "memory" ),\u000a					jQuery.Callbacks( "memory" ), 2 ],\u000a				[ "resolve", "done", jQuery.Callbacks( "once memory" ),\u000a					jQuery.Callbacks( "once memory" ), 0, "resolved" ],\u000a				[ "reject", "fail", jQuery.Callbacks( "once memory" ),\u000a					jQuery.Callbacks( "once memory" ), 1, "rejected" ]\u000a			],\u000a			state = "pending",\u000a			promise = {\u000a				state: function() {\u000a					return state;\u000a				},\u000a				always: function() {\u000a					deferred.done( arguments ).fail( arguments );\u000a					return this;\u000a				},\u000a				"catch": function( fn ) {\u000a					return promise.then( null, fn );\u000a				},\u000a\u000a				// Keep pipe for back-compat\u000a				pipe: function( /* fnDone, fnFail, fnProgress */ ) {\u000a					var fns = arguments;\u000a\u000a					return jQuery.Deferred( function( newDefer ) {\u000a						jQuery.each( tuples, function( i, tuple ) {\u000a\u000a							// Map tuples (progress, done, fail) to arguments (done, fail, progress)\u000a							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\u000a\u000a							// deferred.progress(function() { bind to newDefer or newDefer.notify })\u000a							// deferred.done(function() { bind to newDefer or newDefer.resolve })\u000a							// deferred.fail(function() { bind to newDefer or newDefer.reject })\u000a							deferred[ tuple[ 1 ] ]( function() {\u000a								var returned = fn && fn.apply( this, arguments );\u000a								if ( returned && isFunction( returned.promise ) ) {\u000a									returned.promise()\u000a										.progress( newDefer.notify )\u000a										.done( newDefer.resolve )\u000a										.fail( newDefer.reject );\u000a								} else {\u000a									newDefer[ tuple[ 0 ] + "With" ](\u000a										this,\u000a										fn ? [ returned ] : arguments\u000a									);\u000a								}\u000a							} );\u000a						} );\u000a						fns = null;\u000a					} ).promise();\u000a				},\u000a				then: function( onFulfilled, onRejected, onProgress ) {\u000a					var maxDepth = 0;\u000a					function resolve( depth, deferred, handler, special ) {\u000a						return function() {\u000a							var that = this,\u000a								args = arguments,\u000a								mightThrow = function() {\u000a									var returned, then;\u000a\u000a									// Support: Promises/A+ section 2.3.3.3.3\u000a									// https://promisesaplus.com/#point-59\u000a									// Ignore double-resolution attempts\u000a									if ( depth < maxDepth ) {\u000a										return;\u000a									}\u000a\u000a									returned = handler.apply( that, args );\u000a\u000a									// Support: Promises/A+ section 2.3.1\u000a									// https://promisesaplus.com/#point-48\u000a									if ( returned === deferred.promise() ) {\u000a										throw new TypeError( "Thenable self-resolution" );\u000a									}\u000a\u000a									// Support: Promises/A+ sections 2.3.3.1, 3.5\u000a									// https://promisesaplus.com/#point-54\u000a									// https://promisesaplus.com/#point-75\u000a									// Retrieve `then` only once\u000a									then = returned &&\u000a\u000a										// Support: Promises/A+ section 2.3.4\u000a										// https://promisesaplus.com/#point-64\u000a										// Only check objects and functions for thenability\u000a										( typeof returned === "object" ||\u000a											typeof returned === "function" ) &&\u000a										returned.then;\u000a\u000a									// Handle a returned thenable\u000a									if ( isFunction( then ) ) {\u000a\u000a										// Special processors (notify) just wait for resolution\u000a										if ( special ) {\u000a											then.call(\u000a												returned,\u000a												resolve( maxDepth, deferred, Identity, special ),\u000a												resolve( maxDepth, deferred, Thrower, special )\u000a											);\u000a\u000a										// Normal processors (resolve) also hook into progress\u000a										} else {\u000a\u000a											// ...and disregard older resolution values\u000a											maxDepth++;\u000a\u000a											then.call(\u000a												returned,\u000a												resolve( maxDepth, deferred, Identity, special ),\u000a												resolve( maxDepth, deferred, Thrower, special ),\u000a												resolve( maxDepth, deferred, Identity,\u000a													deferred.notifyWith )\u000a											);\u000a										}\u000a\u000a									// Handle all other returned values\u000a									} else {\u000a\u000a										// Only substitute handlers pass on context\u000a										// and multiple values (non-spec behavior)\u000a										if ( handler !== Identity ) {\u000a											that = undefined;\u000a											args = [ returned ];\u000a										}\u000a\u000a										// Process the value(s)\u000a										// Default process is resolve\u000a										( special || deferred.resolveWith )( that, args );\u000a									}\u000a								},\u000a\u000a								// Only normal processors (resolve) catch and reject exceptions\u000a								process = special ?\u000a									mightThrow :\u000a									function() {\u000a										try {\u000a											mightThrow();\u000a										} catch ( e ) {\u000a\u000a											if ( jQuery.Deferred.exceptionHook ) {\u000a												jQuery.Deferred.exceptionHook( e,\u000a													process.stackTrace );\u000a											}\u000a\u000a											// Support: Promises/A+ section 2.3.3.3.4.1\u000a											// https://promisesaplus.com/#point-61\u000a											// Ignore post-resolution exceptions\u000a											if ( depth + 1 >= maxDepth ) {\u000a\u000a												// Only substitute handlers pass on context\u000a												// and multiple values (non-spec behavior)\u000a												if ( handler !== Thrower ) {\u000a													that = undefined;\u000a													args = [ e ];\u000a												}\u000a\u000a												deferred.rejectWith( that, args );\u000a											}\u000a										}\u000a									};\u000a\u000a							// Support: Promises/A+ section 2.3.3.3.1\u000a							// https://promisesaplus.com/#point-57\u000a							// Re-resolve promises immediately to dodge false rejection from\u000a							// subsequent errors\u000a							if ( depth ) {\u000a								process();\u000a							} else {\u000a\u000a								// Call an optional hook to record the stack, in case of exception\u000a								// since it's otherwise lost when execution goes async\u000a								if ( jQuery.Deferred.getStackHook ) {\u000a									process.stackTrace = jQuery.Deferred.getStackHook();\u000a								}\u000a								window.setTimeout( process );\u000a							}\u000a						};\u000a					}\u000a\u000a					return jQuery.Deferred( function( newDefer ) {\u000a\u000a						// progress_handlers.add( ... )\u000a						tuples[ 0 ][ 3 ].add(\u000a							resolve(\u000a								0,\u000a								newDefer,\u000a								isFunction( onProgress ) ?\u000a									onProgress :\u000a									Identity,\u000a								newDefer.notifyWith\u000a							)\u000a						);\u000a\u000a						// fulfilled_handlers.add( ... )\u000a						tuples[ 1 ][ 3 ].add(\u000a							resolve(\u000a								0,\u000a								newDefer,\u000a								isFunction( onFulfilled ) ?\u000a									onFulfilled :\u000a									Identity\u000a							)\u000a						);\u000a\u000a						// rejected_handlers.add( ... )\u000a						tuples[ 2 ][ 3 ].add(\u000a							resolve(\u000a								0,\u000a								newDefer,\u000a								isFunction( onRejected ) ?\u000a									onRejected :\u000a									Thrower\u000a							)\u000a						);\u000a					} ).promise();\u000a				},\u000a\u000a				// Get a promise for this deferred\u000a				// If obj is provided, the promise aspect is added to the object\u000a				promise: function( obj ) {\u000a					return obj != null ? jQuery.extend( obj, promise ) : promise;\u000a				}\u000a			},\u000a			deferred = {};\u000a\u000a		// Add list-specific methods\u000a		jQuery.each( tuples, function( i, tuple ) {\u000a			var list = tuple[ 2 ],\u000a				stateString = tuple[ 5 ];\u000a\u000a			// promise.progress = list.add\u000a			// promise.done = list.add\u000a			// promise.fail = list.add\u000a			promise[ tuple[ 1 ] ] = list.add;\u000a\u000a			// Handle state\u000a			if ( stateString ) {\u000a				list.add(\u000a					function() {\u000a\u000a						// state = "resolved" (i.e., fulfilled)\u000a						// state = "rejected"\u000a						state = stateString;\u000a					},\u000a\u000a					// rejected_callbacks.disable\u000a					// fulfilled_callbacks.disable\u000a					tuples[ 3 - i ][ 2 ].disable,\u000a\u000a					// rejected_handlers.disable\u000a					// fulfilled_handlers.disable\u000a					tuples[ 3 - i ][ 3 ].disable,\u000a\u000a					// progress_callbacks.lock\u000a					tuples[ 0 ][ 2 ].lock,\u000a\u000a					// progress_handlers.lock\u000a					tuples[ 0 ][ 3 ].lock\u000a				);\u000a			}\u000a\u000a			// progress_handlers.fire\u000a			// fulfilled_handlers.fire\u000a			// rejected_handlers.fire\u000a			list.add( tuple[ 3 ].fire );\u000a\u000a			// deferred.notify = function() { deferred.notifyWith(...) }\u000a			// deferred.resolve = function() { deferred.resolveWith(...) }\u000a			// deferred.reject = function() { deferred.rejectWith(...) }\u000a			deferred[ tuple[ 0 ] ] = function() {\u000a				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );\u000a				return this;\u000a			};\u000a\u000a			// deferred.notifyWith = list.fireWith\u000a			// deferred.resolveWith = list.fireWith\u000a			// deferred.rejectWith = list.fireWith\u000a			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;\u000a		} );\u000a\u000a		// Make the deferred a promise\u000a		promise.promise( deferred );\u000a\u000a		// Call given func if any\u000a		if ( func ) {\u000a			func.call( deferred, deferred );\u000a		}\u000a\u000a		// All done!\u000a		return deferred;\u000a	},\u000a\u000a	// Deferred helper\u000a	when: function( singleValue ) {\u000a		var\u000a\u000a			// count of uncompleted subordinates\u000a			remaining = arguments.length,\u000a\u000a			// count of unprocessed arguments\u000a			i = remaining,\u000a\u000a			// subordinate fulfillment data\u000a			resolveContexts = Array( i ),\u000a			resolveValues = slice.call( arguments ),\u000a\u000a			// the master Deferred\u000a			master = jQuery.Deferred(),\u000a\u000a			// subordinate callback factory\u000a			updateFunc = function( i ) {\u000a				return function( value ) {\u000a					resolveContexts[ i ] = this;\u000a					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\u000a					if ( !( --remaining ) ) {\u000a						master.resolveWith( resolveContexts, resolveValues );\u000a					}\u000a				};\u000a			};\u000a\u000a		// Single- and empty arguments are adopted like Promise.resolve\u000a		if ( remaining <= 1 ) {\u000a			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\u000a				!remaining );\u000a\u000a			// Use .then() to unwrap secondary thenables (cf. gh-3000)\u000a			if ( master.state() === "pending" ||\u000a				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\u000a\u000a				return master.then();\u000a			}\u000a		}\u000a\u000a		// Multiple arguments are aggregated like Promise.all array elements\u000a		while ( i-- ) {\u000a			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\u000a		}\u000a\u000a		return master.promise();\u000a	}\u000a} );\u000a\u000a\u000a// These usually indicate a programmer mistake during development,\u000a// warn about them ASAP rather than swallowing them by default.\u000avar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\u000a\u000ajQuery.Deferred.exceptionHook = function( error, stack ) {\u000a\u000a	// Support: IE 8 - 9 only\u000a	// Console exists when dev tools are open, which can happen at any time\u000a	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\u000a		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );\u000a	}\u000a};\u000a\u000a\u000a\u000a\u000ajQuery.readyException = function( error ) {\u000a	window.setTimeout( function() {\u000a		throw error;\u000a	} );\u000a};\u000a\u000a\u000a\u000a\u000a// The deferred used on DOM ready\u000avar readyList = jQuery.Deferred();\u000a\u000ajQuery.fn.ready = function( fn ) {\u000a\u000a	readyList\u000a		.then( fn )\u000a\u000a		// Wrap jQuery.readyException in a function so that the lookup\u000a		// happens at the time of error handling instead of callback\u000a		// registration.\u000a		.catch( function( error ) {\u000a			jQuery.readyException( error );\u000a		} );\u000a\u000a	return this;\u000a};\u000a\u000ajQuery.extend( {\u000a\u000a	// Is the DOM ready to be used? Set to true once it occurs.\u000a	isReady: false,\u000a\u000a	// A counter to track how many items to wait for before\u000a	// the ready event fires. See #6781\u000a	readyWait: 1,\u000a\u000a	// Handle when the DOM is ready\u000a	ready: function( wait ) {\u000a\u000a		// Abort if there are pending holds or we're already ready\u000a		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\u000a			return;\u000a		}\u000a\u000a		// Remember that the DOM is ready\u000a		jQuery.isReady = true;\u000a\u000a		// If a normal DOM Ready event fired, decrement, and wait if need be\u000a		if ( wait !== true && --jQuery.readyWait > 0 ) {\u000a			return;\u000a		}\u000a\u000a		// If there are functions bound, to execute\u000a		readyList.resolveWith( document, [ jQuery ] );\u000a	}\u000a} );\u000a\u000ajQuery.ready.then = readyList.then;\u000a\u000a// The ready event handler and self cleanup method\u000afunction completed() {\u000a	document.removeEventListener( "DOMContentLoaded", completed );\u000a	window.removeEventListener( "load", completed );\u000a	jQuery.ready();\u000a}\u000a\u000a// Catch cases where $(document).ready() is called\u000a// after the browser event has already occurred.\u000a// Support: IE <=9 - 10 only\u000a// Older IE sometimes signals "interactive" too soon\u000aif ( document.readyState === "complete" ||\u000a	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {\u000a\u000a	// Handle it asynchronously to allow scripts the opportunity to delay ready\u000a	window.setTimeout( jQuery.ready );\u000a\u000a} else {\u000a\u000a	// Use the handy event callback\u000a	document.addEventListener( "DOMContentLoaded", completed );\u000a\u000a	// A fallback to window.onload, that will always work\u000a	window.addEventListener( "load", completed );\u000a}\u000a\u000a\u000a\u000a\u000a// Multifunctional method to get and set values of a collection\u000a// The value/s can optionally be executed if it's a function\u000avar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\u000a	var i = 0,\u000a		len = elems.length,\u000a		bulk = key == null;\u000a\u000a	// Sets many values\u000a	if ( toType( key ) === "object" ) {\u000a		chainable = true;\u000a		for ( i in key ) {\u000a			access( elems, fn, i, key[ i ], true, emptyGet, raw );\u000a		}\u000a\u000a	// Sets one value\u000a	} else if ( value !== undefined ) {\u000a		chainable = true;\u000a\u000a		if ( !isFunction( value ) ) {\u000a			raw = true;\u000a		}\u000a\u000a		if ( bulk ) {\u000a\u000a			// Bulk operations run against the entire set\u000a			if ( raw ) {\u000a				fn.call( elems, value );\u000a				fn = null;\u000a\u000a			// ...except when executing function values\u000a			} else {\u000a				bulk = fn;\u000a				fn = function( elem, key, value ) {\u000a					return bulk.call( jQuery( elem ), value );\u000a				};\u000a			}\u000a		}\u000a\u000a		if ( fn ) {\u000a			for ( ; i < len; i++ ) {\u000a				fn(\u000a					elems[ i ], key, raw ?\u000a					value :\u000a					value.call( elems[ i ], i, fn( elems[ i ], key ) )\u000a				);\u000a			}\u000a		}\u000a	}\u000a\u000a	if ( chainable ) {\u000a		return elems;\u000a	}\u000a\u000a	// Gets\u000a	if ( bulk ) {\u000a		return fn.call( elems );\u000a	}\u000a\u000a	return len ? fn( elems[ 0 ], key ) : emptyGet;\u000a};\u000a\u000a\u000a// Matches dashed string for camelizing\u000avar rmsPrefix = /^-ms-/,\u000a	rdashAlpha = /-([a-z])/g;\u000a\u000a// Used by camelCase as callback to replace()\u000afunction fcamelCase( all, letter ) {\u000a	return letter.toUpperCase();\u000a}\u000a\u000a// Convert dashed to camelCase; used by the css and data modules\u000a// Support: IE <=9 - 11, Edge 12 - 15\u000a// Microsoft forgot to hump their vendor prefix (#9572)\u000afunction camelCase( string ) {\u000a	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\u000a}\u000avar acceptData = function( owner ) {\u000a\u000a	// Accepts only:\u000a	//  - Node\u000a	//    - Node.ELEMENT_NODE\u000a	//    - Node.DOCUMENT_NODE\u000a	//  - Object\u000a	//    - Any\u000a	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\u000a};\u000a\u000a\u000a\u000a\u000afunction Data() {\u000a	this.expando = jQuery.expando + Data.uid++;\u000a}\u000a\u000aData.uid = 1;\u000a\u000aData.prototype = {\u000a\u000a	cache: function( owner ) {\u000a\u000a		// Check if the owner object already has a cache\u000a		var value = owner[ this.expando ];\u000a\u000a		// If not, create one\u000a		if ( !value ) {\u000a			value = {};\u000a\u000a			// We can accept data for non-element nodes in modern browsers,\u000a			// but we should not, see #8335.\u000a			// Always return an empty object.\u000a			if ( acceptData( owner ) ) {\u000a\u000a				// If it is a node unlikely to be stringify-ed or looped over\u000a				// use plain assignment\u000a				if ( owner.nodeType ) {\u000a					owner[ this.expando ] = value;\u000a\u000a				// Otherwise secure it in a non-enumerable property\u000a				// configurable must be true to allow the property to be\u000a				// deleted when data is removed\u000a				} else {\u000a					Object.defineProperty( owner, this.expando, {\u000a						value: value,\u000a						configurable: true\u000a					} );\u000a				}\u000a			}\u000a		}\u000a\u000a		return value;\u000a	},\u000a	set: function( owner, data, value ) {\u000a		var prop,\u000a			cache = this.cache( owner );\u000a\u000a		// Handle: [ owner, key, value ] args\u000a		// Always use camelCase key (gh-2257)\u000a		if ( typeof data === "string" ) {\u000a			cache[ camelCase( data ) ] = value;\u000a\u000a		// Handle: [ owner, { properties } ] args\u000a		} else {\u000a\u000a			// Copy the properties one-by-one to the cache object\u000a			for ( prop in data ) {\u000a				cache[ camelCase( prop ) ] = data[ prop ];\u000a			}\u000a		}\u000a		return cache;\u000a	},\u000a	get: function( owner, key ) {\u000a		return key === undefined ?\u000a			this.cache( owner ) :\u000a\u000a			// Always use camelCase key (gh-2257)\u000a			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\u000a	},\u000a	access: function( owner, key, value ) {\u000a\u000a		// In cases where either:\u000a		//\u000a		//   1. No key was specified\u000a		//   2. A string key was specified, but no value provided\u000a		//\u000a		// Take the "read" path and allow the get method to determine\u000a		// which value to return, respectively either:\u000a		//\u000a		//   1. The entire cache object\u000a		//   2. The data stored at the key\u000a		//\u000a		if ( key === undefined ||\u000a				( ( key && typeof key === "string" ) && value === undefined ) ) {\u000a\u000a			return this.get( owner, key );\u000a		}\u000a\u000a		// When the key is not a string, or both a key and value\u000a		// are specified, set or extend (existing objects) with either:\u000a		//\u000a		//   1. An object of properties\u000a		//   2. A key and value\u000a		//\u000a		this.set( owner, key, value );\u000a\u000a		// Since the "set" path can have two possible entry points\u000a		// return the expected data based on which path was taken[*]\u000a		return value !== undefined ? value : key;\u000a	},\u000a	remove: function( owner, key ) {\u000a		var i,\u000a			cache = owner[ this.expando ];\u000a\u000a		if ( cache === undefined ) {\u000a			return;\u000a		}\u000a\u000a		if ( key !== undefined ) {\u000a\u000a			// Support array or space separated string of keys\u000a			if ( Array.isArray( key ) ) {\u000a\u000a				// If key is an array of keys...\u000a				// We always set camelCase keys, so remove that.\u000a				key = key.map( camelCase );\u000a			} else {\u000a				key = camelCase( key );\u000a\u000a				// If a key with the spaces exists, use it.\u000a				// Otherwise, create an array by matching non-whitespace\u000a				key = key in cache ?\u000a					[ key ] :\u000a					( key.match( rnothtmlwhite ) || [] );\u000a			}\u000a\u000a			i = key.length;\u000a\u000a			while ( i-- ) {\u000a				delete cache[ key[ i ] ];\u000a			}\u000a		}\u000a\u000a		// Remove the expando if there's no more data\u000a		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {\u000a\u000a			// Support: Chrome <=35 - 45\u000a			// Webkit & Blink performance suffers when deleting properties\u000a			// from DOM nodes, so set to undefined instead\u000a			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\u000a			if ( owner.nodeType ) {\u000a				owner[ this.expando ] = undefined;\u000a			} else {\u000a				delete owner[ this.expando ];\u000a			}\u000a		}\u000a	},\u000a	hasData: function( owner ) {\u000a		var cache = owner[ this.expando ];\u000a		return cache !== undefined && !jQuery.isEmptyObject( cache );\u000a	}\u000a};\u000avar dataPriv = new Data();\u000a\u000avar dataUser = new Data();\u000a\u000a\u000a\u000a//	Implementation Summary\u000a//\u000a//	1. Enforce API surface and semantic compatibility with 1.9.x branch\u000a//	2. Improve the module's maintainability by reducing the storage\u000a//		paths to a single mechanism.\u000a//	3. Use the same single mechanism to support "private" and "user" data.\u000a//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)\u000a//	5. Avoid exposing implementation details on user objects (eg. expando properties)\u000a//	6. Provide a clear path for implementation upgrade to WeakMap in 2014\u000a\u000avar rbrace = /^(?:\u005c{[\u005cw\u005cW]*\u005c}|\u005c[[\u005cw\u005cW]*\u005c])$/,\u000a	rmultiDash = /[A-Z]/g;\u000a\u000afunction getData( data ) {\u000a	if ( data === "true" ) {\u000a		return true;\u000a	}\u000a\u000a	if ( data === "false" ) {\u000a		return false;\u000a	}\u000a\u000a	if ( data === "null" ) {\u000a		return null;\u000a	}\u000a\u000a	// Only convert to a number if it doesn't change the string\u000a	if ( data === +data + "" ) {\u000a		return +data;\u000a	}\u000a\u000a	if ( rbrace.test( data ) ) {\u000a		return JSON.parse( data );\u000a	}\u000a\u000a	return data;\u000a}\u000a\u000afunction dataAttr( elem, key, data ) {\u000a	var name;\u000a\u000a	// If nothing was found internally, try to fetch any\u000a	// data from the HTML5 data-* attribute\u000a	if ( data === undefined && elem.nodeType === 1 ) {\u000a		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();\u000a		data = elem.getAttribute( name );\u000a\u000a		if ( typeof data === "string" ) {\u000a			try {\u000a				data = getData( data );\u000a			} catch ( e ) {}\u000a\u000a			// Make sure we set the data so it isn't changed later\u000a			dataUser.set( elem, key, data );\u000a		} else {\u000a			data = undefined;\u000a		}\u000a	}\u000a	return data;\u000a}\u000a\u000ajQuery.extend( {\u000a	hasData: function( elem ) {\u000a		return dataUser.hasData( elem ) || dataPriv.hasData( elem );\u000a	},\u000a\u000a	data: function( elem, name, data ) {\u000a		return dataUser.access( elem, name, data );\u000a	},\u000a\u000a	removeData: function( elem, name ) {\u000a		dataUser.remove( elem, name );\u000a	},\u000a\u000a	// TODO: Now that all calls to _data and _removeData have been replaced\u000a	// with direct calls to dataPriv methods, these can be deprecated.\u000a	_data: function( elem, name, data ) {\u000a		return dataPriv.access( elem, name, data );\u000a	},\u000a\u000a	_removeData: function( elem, name ) {\u000a		dataPriv.remove( elem, name );\u000a	}\u000a} );\u000a\u000ajQuery.fn.extend( {\u000a	data: function( key, value ) {\u000a		var i, name, data,\u000a			elem = this[ 0 ],\u000a			attrs = elem && elem.attributes;\u000a\u000a		// Gets all values\u000a		if ( key === undefined ) {\u000a			if ( this.length ) {\u000a				data = dataUser.get( elem );\u000a\u000a				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {\u000a					i = attrs.length;\u000a					while ( i-- ) {\u000a\u000a						// Support: IE 11 only\u000a						// The attrs elements can be null (#14894)\u000a						if ( attrs[ i ] ) {\u000a							name = attrs[ i ].name;\u000a							if ( name.indexOf( "data-" ) === 0 ) {\u000a								name = camelCase( name.slice( 5 ) );\u000a								dataAttr( elem, name, data[ name ] );\u000a							}\u000a						}\u000a					}\u000a					dataPriv.set( elem, "hasDataAttrs", true );\u000a				}\u000a			}\u000a\u000a			return data;\u000a		}\u000a\u000a		// Sets multiple values\u000a		if ( typeof key === "object" ) {\u000a			return this.each( function() {\u000a				dataUser.set( this, key );\u000a			} );\u000a		}\u000a\u000a		return access( this, function( value ) {\u000a			var data;\u000a\u000a			// The calling jQuery object (element matches) is not empty\u000a			// (and therefore has an element appears at this[ 0 ]) and the\u000a			// `value` parameter was not undefined. An empty jQuery object\u000a			// will result in `undefined` for elem = this[ 0 ] which will\u000a			// throw an exception if an attempt to read a data cache is made.\u000a			if ( elem && value === undefined ) {\u000a\u000a				// Attempt to get data from the cache\u000a				// The key will always be camelCased in Data\u000a				data = dataUser.get( elem, key );\u000a				if ( data !== undefined ) {\u000a					return data;\u000a				}\u000a\u000a				// Attempt to "discover" the data in\u000a				// HTML5 custom data-* attrs\u000a				data = dataAttr( elem, key );\u000a				if ( data !== undefined ) {\u000a					return data;\u000a				}\u000a\u000a				// We tried really hard, but the data doesn't exist.\u000a				return;\u000a			}\u000a\u000a			// Set the data...\u000a			this.each( function() {\u000a\u000a				// We always store the camelCased key\u000a				dataUser.set( this, key, value );\u000a			} );\u000a		}, null, value, arguments.length > 1, null, true );\u000a	},\u000a\u000a	removeData: function( key ) {\u000a		return this.each( function() {\u000a			dataUser.remove( this, key );\u000a		} );\u000a	}\u000a} );\u000a\u000a\u000ajQuery.extend( {\u000a	queue: function( elem, type, data ) {\u000a		var queue;\u000a\u000a		if ( elem ) {\u000a			type = ( type || "fx" ) + "queue";\u000a			queue = dataPriv.get( elem, type );\u000a\u000a			// Speed up dequeue by getting out quickly if this is just a lookup\u000a			if ( data ) {\u000a				if ( !queue || Array.isArray( data ) ) {\u000a					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\u000a				} else {\u000a					queue.push( data );\u000a				}\u000a			}\u000a			return queue || [];\u000a		}\u000a	},\u000a\u000a	dequeue: function( elem, type ) {\u000a		type = type || "fx";\u000a\u000a		var queue = jQuery.queue( elem, type ),\u000a			startLength = queue.length,\u000a			fn = queue.shift(),\u000a			hooks = jQuery._queueHooks( elem, type ),\u000a			next = function() {\u000a				jQuery.dequeue( elem, type );\u000a			};\u000a\u000a		// If the fx queue is dequeued, always remove the progress sentinel\u000a		if ( fn === "inprogress" ) {\u000a			fn = queue.shift();\u000a			startLength--;\u000a		}\u000a\u000a		if ( fn ) {\u000a\u000a			// Add a progress sentinel to prevent the fx queue from being\u000a			// automatically dequeued\u000a			if ( type === "fx" ) {\u000a				queue.unshift( "inprogress" );\u000a			}\u000a\u000a			// Clear up the last queue stop function\u000a			delete hooks.stop;\u000a			fn.call( elem, next, hooks );\u000a		}\u000a\u000a		if ( !startLength && hooks ) {\u000a			hooks.empty.fire();\u000a		}\u000a	},\u000a\u000a	// Not public - generate a queueHooks object, or return the current one\u000a	_queueHooks: function( elem, type ) {\u000a		var key = type + "queueHooks";\u000a		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\u000a			empty: jQuery.Callbacks( "once memory" ).add( function() {\u000a				dataPriv.remove( elem, [ type + "queue", key ] );\u000a			} )\u000a		} );\u000a	}\u000a} );\u000a\u000ajQuery.fn.extend( {\u000a	queue: function( type, data ) {\u000a		var setter = 2;\u000a\u000a		if ( typeof type !== "string" ) {\u000a			data = type;\u000a			type = "fx";\u000a			setter--;\u000a		}\u000a\u000a		if ( arguments.length < setter ) {\u000a			return jQuery.queue( this[ 0 ], type );\u000a		}\u000a\u000a		return data === undefined ?\u000a			this :\u000a			this.each( function() {\u000a				var queue = jQuery.queue( this, type, data );\u000a\u000a				// Ensure a hooks for this queue\u000a				jQuery._queueHooks( this, type );\u000a\u000a				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {\u000a					jQuery.dequeue( this, type );\u000a				}\u000a			} );\u000a	},\u000a	dequeue: function( type ) {\u000a		return this.each( function() {\u000a			jQuery.dequeue( this, type );\u000a		} );\u000a	},\u000a	clearQueue: function( type ) {\u000a		return this.queue( type || "fx", [] );\u000a	},\u000a\u000a	// Get a promise resolved when queues of a certain type\u000a	// are emptied (fx is the type by default)\u000a	promise: function( type, obj ) {\u000a		var tmp,\u000a			count = 1,\u000a			defer = jQuery.Deferred(),\u000a			elements = this,\u000a			i = this.length,\u000a			resolve = function() {\u000a				if ( !( --count ) ) {\u000a					defer.resolveWith( elements, [ elements ] );\u000a				}\u000a			};\u000a\u000a		if ( typeof type !== "string" ) {\u000a			obj = type;\u000a			type = undefined;\u000a		}\u000a		type = type || "fx";\u000a\u000a		while ( i-- ) {\u000a			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );\u000a			if ( tmp && tmp.empty ) {\u000a				count++;\u000a				tmp.empty.add( resolve );\u000a			}\u000a		}\u000a		resolve();\u000a		return defer.promise( obj );\u000a	}\u000a} );\u000avar pnum = ( /[+-]?(?:\u005cd*\u005c.|)\u005cd+(?:[eE][+-]?\u005cd+|)/ ).source;\u000a\u000avar rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );\u000a\u000a\u000avar cssExpand = [ "Top", "Right", "Bottom", "Left" ];\u000a\u000avar isHiddenWithinTree = function( elem, el ) {\u000a\u000a		// isHiddenWithinTree might be called from jQuery#filter function;\u000a		// in that case, element will be second argument\u000a		elem = el || elem;\u000a\u000a		// Inline style trumps all\u000a		return elem.style.display === "none" ||\u000a			elem.style.display === "" &&\u000a\u000a			// Otherwise, check computed style\u000a			// Support: Firefox <=43 - 45\u000a			// Disconnected elements can have computed display: none, so first confirm that elem is\u000a			// in the document.\u000a			jQuery.contains( elem.ownerDocument, elem ) &&\u000a\u000a			jQuery.css( elem, "display" ) === "none";\u000a	};\u000a\u000avar swap = function( elem, options, callback, args ) {\u000a	var ret, name,\u000a		old = {};\u000a\u000a	// Remember the old values, and insert the new ones\u000a	for ( name in options ) {\u000a		old[ name ] = elem.style[ name ];\u000a		elem.style[ name ] = options[ name ];\u000a	}\u000a\u000a	ret = callback.apply( elem, args || [] );\u000a\u000a	// Revert the old values\u000a	for ( name in options ) {\u000a		elem.style[ name ] = old[ name ];\u000a	}\u000a\u000a	return ret;\u000a};\u000a\u000a\u000a\u000a\u000afunction adjustCSS( elem, prop, valueParts, tween ) {\u000a	var adjusted, scale,\u000a		maxIterations = 20,\u000a		currentValue = tween ?\u000a			function() {\u000a				return tween.cur();\u000a			} :\u000a			function() {\u000a				return jQuery.css( elem, prop, "" );\u000a			},\u000a		initial = currentValue(),\u000a		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\u000a\u000a		// Starting value computation is required for potential unit mismatches\u000a		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&\u000a			rcssNum.exec( jQuery.css( elem, prop ) );\u000a\u000a	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\u000a\u000a		// Support: Firefox <=54\u000a		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\u000a		initial = initial / 2;\u000a\u000a		// Trust units reported by jQuery.css\u000a		unit = unit || initialInUnit[ 3 ];\u000a\u000a		// Iteratively approximate from a nonzero starting point\u000a		initialInUnit = +initial || 1;\u000a\u000a		while ( maxIterations-- ) {\u000a\u000a			// Evaluate and update our best guess (doubling guesses that zero out).\u000a			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\u000a			jQuery.style( elem, prop, initialInUnit + unit );\u000a			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\u000a				maxIterations = 0;\u000a			}\u000a			initialInUnit = initialInUnit / scale;\u000a\u000a		}\u000a\u000a		initialInUnit = initialInUnit * 2;\u000a		jQuery.style( elem, prop, initialInUnit + unit );\u000a\u000a		// Make sure we update the tween properties later on\u000a		valueParts = valueParts || [];\u000a	}\u000a\u000a	if ( valueParts ) {\u000a		initialInUnit = +initialInUnit || +initial || 0;\u000a\u000a		// Apply relative offset (+=/-=) if specified\u000a		adjusted = valueParts[ 1 ] ?\u000a			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\u000a			+valueParts[ 2 ];\u000a		if ( tween ) {\u000a			tween.unit = unit;\u000a			tween.start = initialInUnit;\u000a			tween.end = adjusted;\u000a		}\u000a	}\u000a	return adjusted;\u000a}\u000a\u000a\u000avar defaultDisplayMap = {};\u000a\u000afunction getDefaultDisplay( elem ) {\u000a	var temp,\u000a		doc = elem.ownerDocument,\u000a		nodeName = elem.nodeName,\u000a		display = defaultDisplayMap[ nodeName ];\u000a\u000a	if ( display ) {\u000a		return display;\u000a	}\u000a\u000a	temp = doc.body.appendChild( doc.createElement( nodeName ) );\u000a	display = jQuery.css( temp, "display" );\u000a\u000a	temp.parentNode.removeChild( temp );\u000a\u000a	if ( display === "none" ) {\u000a		display = "block";\u000a	}\u000a	defaultDisplayMap[ nodeName ] = display;\u000a\u000a	return display;\u000a}\u000a\u000afunction showHide( elements, show ) {\u000a	var display, elem,\u000a		values = [],\u000a		index = 0,\u000a		length = elements.length;\u000a\u000a	// Determine new display value for elements that need to change\u000a	for ( ; index < length; index++ ) {\u000a		elem = elements[ index ];\u000a		if ( !elem.style ) {\u000a			continue;\u000a		}\u000a\u000a		display = elem.style.display;\u000a		if ( show ) {\u000a\u000a			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\u000a			// check is required in this first loop unless we have a nonempty display value (either\u000a			// inline or about-to-be-restored)\u000a			if ( display === "none" ) {\u000a				values[ index ] = dataPriv.get( elem, "display" ) || null;\u000a				if ( !values[ index ] ) {\u000a					elem.style.display = "";\u000a				}\u000a			}\u000a			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {\u000a				values[ index ] = getDefaultDisplay( elem );\u000a			}\u000a		} else {\u000a			if ( display !== "none" ) {\u000a				values[ index ] = "none";\u000a\u000a				// Remember what we're overwriting\u000a				dataPriv.set( elem, "display", display );\u000a			}\u000a		}\u000a	}\u000a\u000a	// Set the display of the elements in a second loop to avoid constant reflow\u000a	for ( index = 0; index < length; index++ ) {\u000a		if ( values[ index ] != null ) {\u000a			elements[ index ].style.display = values[ index ];\u000a		}\u000a	}\u000a\u000a	return elements;\u000a}\u000a\u000ajQuery.fn.extend( {\u000a	show: function() {\u000a		return showHide( this, true );\u000a	},\u000a	hide: function() {\u000a		return showHide( this );\u000a	},\u000a	toggle: function( state ) {\u000a		if ( typeof state === "boolean" ) {\u000a			return state ? this.show() : this.hide();\u000a		}\u000a\u000a		return this.each( function() {\u000a			if ( isHiddenWithinTree( this ) ) {\u000a				jQuery( this ).show();\u000a			} else {\u000a				jQuery( this ).hide();\u000a			}\u000a		} );\u000a	}\u000a} );\u000avar rcheckableType = ( /^(?:checkbox|radio)$/i );\u000a\u000avar rtagName = ( /<([a-z][^\u005c/\u005c0>\u005cx20\u005ct\u005cr\u005cn\u005cf]+)/i );\u000a\u000avar rscriptType = ( /^$|^module$|\u005c/(?:java|ecma)script/i );\u000a\u000a\u000a\u000a// We have to close these tags to support XHTML (#13200)\u000avar wrapMap = {\u000a\u000a	// Support: IE <=9 only\u000a	option: [ 1, "<select multiple='multiple'>", "</select>" ],\u000a\u000a	// XHTML parsers do not magically insert elements in the\u000a	// same way that tag soup parsers do. So we cannot shorten\u000a	// this by omitting <tbody> or other required elements.\u000a	thead: [ 1, "<table>", "</table>" ],\u000a	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],\u000a	tr: [ 2, "<table><tbody>", "</tbody></table>" ],\u000a	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\u000a\u000a	_default: [ 0, "", "" ]\u000a};\u000a\u000a// Support: IE <=9 only\u000awrapMap.optgroup = wrapMap.option;\u000a\u000awrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\u000awrapMap.th = wrapMap.td;\u000a\u000a\u000afunction getAll( context, tag ) {\u000a\u000a	// Support: IE <=9 - 11 only\u000a	// Use typeof to avoid zero-argument method invocation on host objects (#15151)\u000a	var ret;\u000a\u000a	if ( typeof context.getElementsByTagName !== "undefined" ) {\u000a		ret = context.getElementsByTagName( tag || "*" );\u000a\u000a	} else if ( typeof context.querySelectorAll !== "undefined" ) {\u000a		ret = context.querySelectorAll( tag || "*" );\u000a\u000a	} else {\u000a		ret = [];\u000a	}\u000a\u000a	if ( tag === undefined || tag && nodeName( context, tag ) ) {\u000a		return jQuery.merge( [ context ], ret );\u000a	}\u000a\u000a	return ret;\u000a}\u000a\u000a\u000a// Mark scripts as having already been evaluated\u000afunction setGlobalEval( elems, refElements ) {\u000a	var i = 0,\u000a		l = elems.length;\u000a\u000a	for ( ; i < l; i++ ) {\u000a		dataPriv.set(\u000a			elems[ i ],\u000a			"globalEval",\u000a			!refElements || dataPriv.get( refElements[ i ], "globalEval" )\u000a		);\u000a	}\u000a}\u000a\u000a\u000avar rhtml = /<|&#?\u005cw+;/;\u000a\u000afunction buildFragment( elems, context, scripts, selection, ignored ) {\u000a	var elem, tmp, tag, wrap, contains, j,\u000a		fragment = context.createDocumentFragment(),\u000a		nodes = [],\u000a		i = 0,\u000a		l = elems.length;\u000a\u000a	for ( ; i < l; i++ ) {\u000a		elem = elems[ i ];\u000a\u000a		if ( elem || elem === 0 ) {\u000a\u000a			// Add nodes directly\u000a			if ( toType( elem ) === "object" ) {\u000a\u000a				// Support: Android <=4.0 only, PhantomJS 1 only\u000a				// push.apply(_, arraylike) throws on ancient WebKit\u000a				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\u000a\u000a			// Convert non-html into a text node\u000a			} else if ( !rhtml.test( elem ) ) {\u000a				nodes.push( context.createTextNode( elem ) );\u000a\u000a			// Convert html into DOM nodes\u000a			} else {\u000a				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );\u000a\u000a				// Deserialize a standard representation\u000a				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();\u000a				wrap = wrapMap[ tag ] || wrapMap._default;\u000a				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\u000a\u000a				// Descend through wrappers to the right content\u000a				j = wrap[ 0 ];\u000a				while ( j-- ) {\u000a					tmp = tmp.lastChild;\u000a				}\u000a\u000a				// Support: Android <=4.0 only, PhantomJS 1 only\u000a				// push.apply(_, arraylike) throws on ancient WebKit\u000a				jQuery.merge( nodes, tmp.childNodes );\u000a\u000a				// Remember the top-level container\u000a				tmp = fragment.firstChild;\u000a\u000a				// Ensure the created nodes are orphaned (#12392)\u000a				tmp.textContent = "";\u000a			}\u000a		}\u000a	}\u000a\u000a	// Remove wrapper from fragment\u000a	fragment.textContent = "";\u000a\u000a	i = 0;\u000a	while ( ( elem = nodes[ i++ ] ) ) {\u000a\u000a		// Skip elements already in the context collection (trac-4087)\u000a		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {\u000a			if ( ignored ) {\u000a				ignored.push( elem );\u000a			}\u000a			continue;\u000a		}\u000a\u000a		contains = jQuery.contains( elem.ownerDocument, elem );\u000a\u000a		// Append to fragment\u000a		tmp = getAll( fragment.appendChild( elem ), "script" );\u000a\u000a		// Preserve script evaluation history\u000a		if ( contains ) {\u000a			setGlobalEval( tmp );\u000a		}\u000a\u000a		// Capture executables\u000a		if ( scripts ) {\u000a			j = 0;\u000a			while ( ( elem = tmp[ j++ ] ) ) {\u000a				if ( rscriptType.test( elem.type || "" ) ) {\u000a					scripts.push( elem );\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	return fragment;\u000a}\u000a\u000a\u000a( function() {\u000a	var fragment = document.createDocumentFragment(),\u000a		div = fragment.appendChild( document.createElement( "div" ) ),\u000a		input = document.createElement( "input" );\u000a\u000a	// Support: Android 4.0 - 4.3 only\u000a	// Check state lost if the name is set (#11217)\u000a	// Support: Windows Web Apps (WWA)\u000a	// `name` and `type` must use .setAttribute for WWA (#14901)\u000a	input.setAttribute( "type", "radio" );\u000a	input.setAttribute( "checked", "checked" );\u000a	input.setAttribute( "name", "t" );\u000a\u000a	div.appendChild( input );\u000a\u000a	// Support: Android <=4.1 only\u000a	// Older WebKit doesn't clone checked state correctly in fragments\u000a	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\u000a\u000a	// Support: IE <=11 only\u000a	// Make sure textarea (and checkbox) defaultValue is properly cloned\u000a	div.innerHTML = "<textarea>x</textarea>";\u000a	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\u000a} )();\u000avar documentElement = document.documentElement;\u000a\u000a\u000a\u000avar\u000a	rkeyEvent = /^key/,\u000a	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\u000a	rtypenamespace = /^([^.]*)(?:\u005c.(.+)|)/;\u000a\u000afunction returnTrue() {\u000a	return true;\u000a}\u000a\u000afunction returnFalse() {\u000a	return false;\u000a}\u000a\u000a// Support: IE <=9 only\u000a// See #13393 for more info\u000afunction safeActiveElement() {\u000a	try {\u000a		return document.activeElement;\u000a	} catch ( err ) { }\u000a}\u000a\u000afunction on( elem, types, selector, data, fn, one ) {\u000a	var origFn, type;\u000a\u000a	// Types can be a map of types/handlers\u000a	if ( typeof types === "object" ) {\u000a\u000a		// ( types-Object, selector, data )\u000a		if ( typeof selector !== "string" ) {\u000a\u000a			// ( types-Object, data )\u000a			data = data || selector;\u000a			selector = undefined;\u000a		}\u000a		for ( type in types ) {\u000a			on( elem, type, selector, data, types[ type ], one );\u000a		}\u000a		return elem;\u000a	}\u000a\u000a	if ( data == null && fn == null ) {\u000a\u000a		// ( types, fn )\u000a		fn = selector;\u000a		data = selector = undefined;\u000a	} else if ( fn == null ) {\u000a		if ( typeof selector === "string" ) {\u000a\u000a			// ( types, selector, fn )\u000a			fn = data;\u000a			data = undefined;\u000a		} else {\u000a\u000a			// ( types, data, fn )\u000a			fn = data;\u000a			data = selector;\u000a			selector = undefined;\u000a		}\u000a	}\u000a	if ( fn === false ) {\u000a		fn = returnFalse;\u000a	} else if ( !fn ) {\u000a		return elem;\u000a	}\u000a\u000a	if ( one === 1 ) {\u000a		origFn = fn;\u000a		fn = function( event ) {\u000a\u000a			// Can use an empty set, since event contains the info\u000a			jQuery().off( event );\u000a			return origFn.apply( this, arguments );\u000a		};\u000a\u000a		// Use same guid so caller can remove using origFn\u000a		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\u000a	}\u000a	return elem.each( function() {\u000a		jQuery.event.add( this, types, fn, data, selector );\u000a	} );\u000a}\u000a\u000a/*\u000a * Helper functions for managing events -- not part of the public interface.\u000a * Props to Dean Edwards' addEvent library for many of the ideas.\u000a */\u000ajQuery.event = {\u000a\u000a	global: {},\u000a\u000a	add: function( elem, types, handler, data, selector ) {\u000a\u000a		var handleObjIn, eventHandle, tmp,\u000a			events, t, handleObj,\u000a			special, handlers, type, namespaces, origType,\u000a			elemData = dataPriv.get( elem );\u000a\u000a		// Don't attach events to noData or text/comment nodes (but allow plain objects)\u000a		if ( !elemData ) {\u000a			return;\u000a		}\u000a\u000a		// Caller can pass in an object of custom data in lieu of the handler\u000a		if ( handler.handler ) {\u000a			handleObjIn = handler;\u000a			handler = handleObjIn.handler;\u000a			selector = handleObjIn.selector;\u000a		}\u000a\u000a		// Ensure that invalid selectors throw exceptions at attach time\u000a		// Evaluate against documentElement in case elem is a non-element node (e.g., document)\u000a		if ( selector ) {\u000a			jQuery.find.matchesSelector( documentElement, selector );\u000a		}\u000a\u000a		// Make sure that the handler has a unique ID, used to find/remove it later\u000a		if ( !handler.guid ) {\u000a			handler.guid = jQuery.guid++;\u000a		}\u000a\u000a		// Init the element's event structure and main handler, if this is the first\u000a		if ( !( events = elemData.events ) ) {\u000a			events = elemData.events = {};\u000a		}\u000a		if ( !( eventHandle = elemData.handle ) ) {\u000a			eventHandle = elemData.handle = function( e ) {\u000a\u000a				// Discard the second event of a jQuery.event.trigger() and\u000a				// when an event is called after a page has unloaded\u000a				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?\u000a					jQuery.event.dispatch.apply( elem, arguments ) : undefined;\u000a			};\u000a		}\u000a\u000a		// Handle multiple events separated by a space\u000a		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\u000a		t = types.length;\u000a		while ( t-- ) {\u000a			tmp = rtypenamespace.exec( types[ t ] ) || [];\u000a			type = origType = tmp[ 1 ];\u000a			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\u000a\u000a			// There *must* be a type, no attaching namespace-only handlers\u000a			if ( !type ) {\u000a				continue;\u000a			}\u000a\u000a			// If event changes its type, use the special event handlers for the changed type\u000a			special = jQuery.event.special[ type ] || {};\u000a\u000a			// If selector defined, determine special event api type, otherwise given type\u000a			type = ( selector ? special.delegateType : special.bindType ) || type;\u000a\u000a			// Update special based on newly reset type\u000a			special = jQuery.event.special[ type ] || {};\u000a\u000a			// handleObj is passed to all event handlers\u000a			handleObj = jQuery.extend( {\u000a				type: type,\u000a				origType: origType,\u000a				data: data,\u000a				handler: handler,\u000a				guid: handler.guid,\u000a				selector: selector,\u000a				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),\u000a				namespace: namespaces.join( "." )\u000a			}, handleObjIn );\u000a\u000a			// Init the event handler queue if we're the first\u000a			if ( !( handlers = events[ type ] ) ) {\u000a				handlers = events[ type ] = [];\u000a				handlers.delegateCount = 0;\u000a\u000a				// Only use addEventListener if the special events handler returns false\u000a				if ( !special.setup ||\u000a					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\u000a\u000a					if ( elem.addEventListener ) {\u000a						elem.addEventListener( type, eventHandle );\u000a					}\u000a				}\u000a			}\u000a\u000a			if ( special.add ) {\u000a				special.add.call( elem, handleObj );\u000a\u000a				if ( !handleObj.handler.guid ) {\u000a					handleObj.handler.guid = handler.guid;\u000a				}\u000a			}\u000a\u000a			// Add to the element's handler list, delegates in front\u000a			if ( selector ) {\u000a				handlers.splice( handlers.delegateCount++, 0, handleObj );\u000a			} else {\u000a				handlers.push( handleObj );\u000a			}\u000a\u000a			// Keep track of which events have ever been used, for event optimization\u000a			jQuery.event.global[ type ] = true;\u000a		}\u000a\u000a	},\u000a\u000a	// Detach an event or set of events from an element\u000a	remove: function( elem, types, handler, selector, mappedTypes ) {\u000a\u000a		var j, origCount, tmp,\u000a			events, t, handleObj,\u000a			special, handlers, type, namespaces, origType,\u000a			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\u000a\u000a		if ( !elemData || !( events = elemData.events ) ) {\u000a			return;\u000a		}\u000a\u000a		// Once for each type.namespace in types; type may be omitted\u000a		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\u000a		t = types.length;\u000a		while ( t-- ) {\u000a			tmp = rtypenamespace.exec( types[ t ] ) || [];\u000a			type = origType = tmp[ 1 ];\u000a			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\u000a\u000a			// Unbind all events (on this namespace, if provided) for the element\u000a			if ( !type ) {\u000a				for ( type in events ) {\u000a					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );\u000a				}\u000a				continue;\u000a			}\u000a\u000a			special = jQuery.event.special[ type ] || {};\u000a			type = ( selector ? special.delegateType : special.bindType ) || type;\u000a			handlers = events[ type ] || [];\u000a			tmp = tmp[ 2 ] &&\u000a				new RegExp( "(^|\u005c\u005c.)" + namespaces.join( "\u005c\u005c.(?:.*\u005c\u005c.|)" ) + "(\u005c\u005c.|$)" );\u000a\u000a			// Remove matching events\u000a			origCount = j = handlers.length;\u000a			while ( j-- ) {\u000a				handleObj = handlers[ j ];\u000a\u000a				if ( ( mappedTypes || origType === handleObj.origType ) &&\u000a					( !handler || handler.guid === handleObj.guid ) &&\u000a					( !tmp || tmp.test( handleObj.namespace ) ) &&\u000a					( !selector || selector === handleObj.selector ||\u000a						selector === "**" && handleObj.selector ) ) {\u000a					handlers.splice( j, 1 );\u000a\u000a					if ( handleObj.selector ) {\u000a						handlers.delegateCount--;\u000a					}\u000a					if ( special.remove ) {\u000a						special.remove.call( elem, handleObj );\u000a					}\u000a				}\u000a			}\u000a\u000a			// Remove generic event handler if we removed something and no more handlers exist\u000a			// (avoids potential for endless recursion during removal of special event handlers)\u000a			if ( origCount && !handlers.length ) {\u000a				if ( !special.teardown ||\u000a					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\u000a\u000a					jQuery.removeEvent( elem, type, elemData.handle );\u000a				}\u000a\u000a				delete events[ type ];\u000a			}\u000a		}\u000a\u000a		// Remove data and the expando if it's no longer used\u000a		if ( jQuery.isEmptyObject( events ) ) {\u000a			dataPriv.remove( elem, "handle events" );\u000a		}\u000a	},\u000a\u000a	dispatch: function( nativeEvent ) {\u000a\u000a		// Make a writable jQuery.Event from the native event object\u000a		var event = jQuery.event.fix( nativeEvent );\u000a\u000a		var i, j, ret, matched, handleObj, handlerQueue,\u000a			args = new Array( arguments.length ),\u000a			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],\u000a			special = jQuery.event.special[ event.type ] || {};\u000a\u000a		// Use the fix-ed jQuery.Event rather than the (read-only) native event\u000a		args[ 0 ] = event;\u000a\u000a		for ( i = 1; i < arguments.length; i++ ) {\u000a			args[ i ] = arguments[ i ];\u000a		}\u000a\u000a		event.delegateTarget = this;\u000a\u000a		// Call the preDispatch hook for the mapped type, and let it bail if desired\u000a		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\u000a			return;\u000a		}\u000a\u000a		// Determine handlers\u000a		handlerQueue = jQuery.event.handlers.call( this, event, handlers );\u000a\u000a		// Run delegates first; they may want to stop propagation beneath us\u000a		i = 0;\u000a		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\u000a			event.currentTarget = matched.elem;\u000a\u000a			j = 0;\u000a			while ( ( handleObj = matched.handlers[ j++ ] ) &&\u000a				!event.isImmediatePropagationStopped() ) {\u000a\u000a				// Triggered event must either 1) have no namespace, or 2) have namespace(s)\u000a				// a subset or equal to those in the bound event (both can have no namespace).\u000a				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\u000a\u000a					event.handleObj = handleObj;\u000a					event.data = handleObj.data;\u000a\u000a					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\u000a						handleObj.handler ).apply( matched.elem, args );\u000a\u000a					if ( ret !== undefined ) {\u000a						if ( ( event.result = ret ) === false ) {\u000a							event.preventDefault();\u000a							event.stopPropagation();\u000a						}\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		// Call the postDispatch hook for the mapped type\u000a		if ( special.postDispatch ) {\u000a			special.postDispatch.call( this, event );\u000a		}\u000a\u000a		return event.result;\u000a	},\u000a\u000a	handlers: function( event, handlers ) {\u000a		var i, handleObj, sel, matchedHandlers, matchedSelectors,\u000a			handlerQueue = [],\u000a			delegateCount = handlers.delegateCount,\u000a			cur = event.target;\u000a\u000a		// Find delegate handlers\u000a		if ( delegateCount &&\u000a\u000a			// Support: IE <=9\u000a			// Black-hole SVG <use> instance trees (trac-13180)\u000a			cur.nodeType &&\u000a\u000a			// Support: Firefox <=42\u000a			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\u000a			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\u000a			// Support: IE 11 only\u000a			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)\u000a			!( event.type === "click" && event.button >= 1 ) ) {\u000a\u000a			for ( ; cur !== this; cur = cur.parentNode || this ) {\u000a\u000a				// Don't check non-elements (#13208)\u000a				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\u000a				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {\u000a					matchedHandlers = [];\u000a					matchedSelectors = {};\u000a					for ( i = 0; i < delegateCount; i++ ) {\u000a						handleObj = handlers[ i ];\u000a\u000a						// Don't conflict with Object.prototype properties (#13203)\u000a						sel = handleObj.selector + " ";\u000a\u000a						if ( matchedSelectors[ sel ] === undefined ) {\u000a							matchedSelectors[ sel ] = handleObj.needsContext ?\u000a								jQuery( sel, this ).index( cur ) > -1 :\u000a								jQuery.find( sel, this, null, [ cur ] ).length;\u000a						}\u000a						if ( matchedSelectors[ sel ] ) {\u000a							matchedHandlers.push( handleObj );\u000a						}\u000a					}\u000a					if ( matchedHandlers.length ) {\u000a						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		// Add the remaining (directly-bound) handlers\u000a		cur = this;\u000a		if ( delegateCount < handlers.length ) {\u000a			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\u000a		}\u000a\u000a		return handlerQueue;\u000a	},\u000a\u000a	addProp: function( name, hook ) {\u000a		Object.defineProperty( jQuery.Event.prototype, name, {\u000a			enumerable: true,\u000a			configurable: true,\u000a\u000a			get: isFunction( hook ) ?\u000a				function() {\u000a					if ( this.originalEvent ) {\u000a							return hook( this.originalEvent );\u000a					}\u000a				} :\u000a				function() {\u000a					if ( this.originalEvent ) {\u000a							return this.originalEvent[ name ];\u000a					}\u000a				},\u000a\u000a			set: function( value ) {\u000a				Object.defineProperty( this, name, {\u000a					enumerable: true,\u000a					configurable: true,\u000a					writable: true,\u000a					value: value\u000a				} );\u000a			}\u000a		} );\u000a	},\u000a\u000a	fix: function( originalEvent ) {\u000a		return originalEvent[ jQuery.expando ] ?\u000a			originalEvent :\u000a			new jQuery.Event( originalEvent );\u000a	},\u000a\u000a	special: {\u000a		load: {\u000a\u000a			// Prevent triggered image.load events from bubbling to window.load\u000a			noBubble: true\u000a		},\u000a		focus: {\u000a\u000a			// Fire native event if possible so blur/focus sequence is correct\u000a			trigger: function() {\u000a				if ( this !== safeActiveElement() && this.focus ) {\u000a					this.focus();\u000a					return false;\u000a				}\u000a			},\u000a			delegateType: "focusin"\u000a		},\u000a		blur: {\u000a			trigger: function() {\u000a				if ( this === safeActiveElement() && this.blur ) {\u000a					this.blur();\u000a					return false;\u000a				}\u000a			},\u000a			delegateType: "focusout"\u000a		},\u000a		click: {\u000a\u000a			// For checkbox, fire native event so checked state will be right\u000a			trigger: function() {\u000a				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {\u000a					this.click();\u000a					return false;\u000a				}\u000a			},\u000a\u000a			// For cross-browser consistency, don't fire native .click() on links\u000a			_default: function( event ) {\u000a				return nodeName( event.target, "a" );\u000a			}\u000a		},\u000a\u000a		beforeunload: {\u000a			postDispatch: function( event ) {\u000a\u000a				// Support: Firefox 20+\u000a				// Firefox doesn't alert if the returnValue field is not set.\u000a				if ( event.result !== undefined && event.originalEvent ) {\u000a					event.originalEvent.returnValue = event.result;\u000a				}\u000a			}\u000a		}\u000a	}\u000a};\u000a\u000ajQuery.removeEvent = function( elem, type, handle ) {\u000a\u000a	// This "if" is needed for plain objects\u000a	if ( elem.removeEventListener ) {\u000a		elem.removeEventListener( type, handle );\u000a	}\u000a};\u000a\u000ajQuery.Event = function( src, props ) {\u000a\u000a	// Allow instantiation without the 'new' keyword\u000a	if ( !( this instanceof jQuery.Event ) ) {\u000a		return new jQuery.Event( src, props );\u000a	}\u000a\u000a	// Event object\u000a	if ( src && src.type ) {\u000a		this.originalEvent = src;\u000a		this.type = src.type;\u000a\u000a		// Events bubbling up the document may have been marked as prevented\u000a		// by a handler lower down the tree; reflect the correct value.\u000a		this.isDefaultPrevented = src.defaultPrevented ||\u000a				src.defaultPrevented === undefined &&\u000a\u000a				// Support: Android <=2.3 only\u000a				src.returnValue === false ?\u000a			returnTrue :\u000a			returnFalse;\u000a\u000a		// Create target properties\u000a		// Support: Safari <=6 - 7 only\u000a		// Target should not be a text node (#504, #13143)\u000a		this.target = ( src.target && src.target.nodeType === 3 ) ?\u000a			src.target.parentNode :\u000a			src.target;\u000a\u000a		this.currentTarget = src.currentTarget;\u000a		this.relatedTarget = src.relatedTarget;\u000a\u000a	// Event type\u000a	} else {\u000a		this.type = src;\u000a	}\u000a\u000a	// Put explicitly provided properties onto the event object\u000a	if ( props ) {\u000a		jQuery.extend( this, props );\u000a	}\u000a\u000a	// Create a timestamp if incoming event doesn't have one\u000a	this.timeStamp = src && src.timeStamp || Date.now();\u000a\u000a	// Mark it as fixed\u000a	this[ jQuery.expando ] = true;\u000a};\u000a\u000a// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\u000a// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\u000ajQuery.Event.prototype = {\u000a	constructor: jQuery.Event,\u000a	isDefaultPrevented: returnFalse,\u000a	isPropagationStopped: returnFalse,\u000a	isImmediatePropagationStopped: returnFalse,\u000a	isSimulated: false,\u000a\u000a	preventDefault: function() {\u000a		var e = this.originalEvent;\u000a\u000a		this.isDefaultPrevented = returnTrue;\u000a\u000a		if ( e && !this.isSimulated ) {\u000a			e.preventDefault();\u000a		}\u000a	},\u000a	stopPropagation: function() {\u000a		var e = this.originalEvent;\u000a\u000a		this.isPropagationStopped = returnTrue;\u000a\u000a		if ( e && !this.isSimulated ) {\u000a			e.stopPropagation();\u000a		}\u000a	},\u000a	stopImmediatePropagation: function() {\u000a		var e = this.originalEvent;\u000a\u000a		this.isImmediatePropagationStopped = returnTrue;\u000a\u000a		if ( e && !this.isSimulated ) {\u000a			e.stopImmediatePropagation();\u000a		}\u000a\u000a		this.stopPropagation();\u000a	}\u000a};\u000a\u000a// Includes all common event props including KeyEvent and MouseEvent specific props\u000ajQuery.each( {\u000a	altKey: true,\u000a	bubbles: true,\u000a	cancelable: true,\u000a	changedTouches: true,\u000a	ctrlKey: true,\u000a	detail: true,\u000a	eventPhase: true,\u000a	metaKey: true,\u000a	pageX: true,\u000a	pageY: true,\u000a	shiftKey: true,\u000a	view: true,\u000a	"char": true,\u000a	charCode: true,\u000a	key: true,\u000a	keyCode: true,\u000a	button: true,\u000a	buttons: true,\u000a	clientX: true,\u000a	clientY: true,\u000a	offsetX: true,\u000a	offsetY: true,\u000a	pointerId: true,\u000a	pointerType: true,\u000a	screenX: true,\u000a	screenY: true,\u000a	targetTouches: true,\u000a	toElement: true,\u000a	touches: true,\u000a\u000a	which: function( event ) {\u000a		var button = event.button;\u000a\u000a		// Add which for key events\u000a		if ( event.which == null && rkeyEvent.test( event.type ) ) {\u000a			return event.charCode != null ? event.charCode : event.keyCode;\u000a		}\u000a\u000a		// Add which for click: 1 === left; 2 === middle; 3 === right\u000a		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\u000a			if ( button & 1 ) {\u000a				return 1;\u000a			}\u000a\u000a			if ( button & 2 ) {\u000a				return 3;\u000a			}\u000a\u000a			if ( button & 4 ) {\u000a				return 2;\u000a			}\u000a\u000a			return 0;\u000a		}\u000a\u000a		return event.which;\u000a	}\u000a}, jQuery.event.addProp );\u000a\u000a// Create mouseenter/leave events using mouseover/out and event-time checks\u000a// so that event delegation works in jQuery.\u000a// Do the same for pointerenter/pointerleave and pointerover/pointerout\u000a//\u000a// Support: Safari 7 only\u000a// Safari sends mouseenter too often; see:\u000a// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\u000a// for the description of the bug (it existed in older Chrome versions as well).\u000ajQuery.each( {\u000a	mouseenter: "mouseover",\u000a	mouseleave: "mouseout",\u000a	pointerenter: "pointerover",\u000a	pointerleave: "pointerout"\u000a}, function( orig, fix ) {\u000a	jQuery.event.special[ orig ] = {\u000a		delegateType: fix,\u000a		bindType: fix,\u000a\u000a		handle: function( event ) {\u000a			var ret,\u000a				target = this,\u000a				related = event.relatedTarget,\u000a				handleObj = event.handleObj;\u000a\u000a			// For mouseenter/leave call the handler if related is outside the target.\u000a			// NB: No relatedTarget if the mouse left/entered the browser window\u000a			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\u000a				event.type = handleObj.origType;\u000a				ret = handleObj.handler.apply( this, arguments );\u000a				event.type = fix;\u000a			}\u000a			return ret;\u000a		}\u000a	};\u000a} );\u000a\u000ajQuery.fn.extend( {\u000a\u000a	on: function( types, selector, data, fn ) {\u000a		return on( this, types, selector, data, fn );\u000a	},\u000a	one: function( types, selector, data, fn ) {\u000a		return on( this, types, selector, data, fn, 1 );\u000a	},\u000a	off: function( types, selector, fn ) {\u000a		var handleObj, type;\u000a		if ( types && types.preventDefault && types.handleObj ) {\u000a\u000a			// ( event )  dispatched jQuery.Event\u000a			handleObj = types.handleObj;\u000a			jQuery( types.delegateTarget ).off(\u000a				handleObj.namespace ?\u000a					handleObj.origType + "." + handleObj.namespace :\u000a					handleObj.origType,\u000a				handleObj.selector,\u000a				handleObj.handler\u000a			);\u000a			return this;\u000a		}\u000a		if ( typeof types === "object" ) {\u000a\u000a			// ( types-object [, selector] )\u000a			for ( type in types ) {\u000a				this.off( type, selector, types[ type ] );\u000a			}\u000a			return this;\u000a		}\u000a		if ( selector === false || typeof selector === "function" ) {\u000a\u000a			// ( types [, fn] )\u000a			fn = selector;\u000a			selector = undefined;\u000a		}\u000a		if ( fn === false ) {\u000a			fn = returnFalse;\u000a		}\u000a		return this.each( function() {\u000a			jQuery.event.remove( this, types, fn, selector );\u000a		} );\u000a	}\u000a} );\u000a\u000a\u000avar\u000a\u000a	/* eslint-disable max-len */\u000a\u000a	// See https://github.com/eslint/eslint/issues/3229\u000a	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\u005c/\u005c0>\u005cx20\u005ct\u005cr\u005cn\u005cf]*)[^>]*)\u005c/>/gi,\u000a\u000a	/* eslint-enable */\u000a\u000a	// Support: IE <=10 - 11, Edge 12 - 13 only\u000a	// In IE/Edge using regex groups here causes severe slowdowns.\u000a	// See https://connect.microsoft.com/IE/feedback/details/1736512/\u000a	rnoInnerhtml = /<script|<style|<link/i,\u000a\u000a	// checked="checked" or checked\u000a	rchecked = /checked\u005cs*(?:[^=]|=\u005cs*.checked.)/i,\u000a	rcleanScript = /^\u005cs*<!(?:\u005c[CDATA\u005c[|--)|(?:\u005c]\u005c]|--)>\u005cs*$/g;\u000a\u000a// Prefer a tbody over its parent table for containing new rows\u000afunction manipulationTarget( elem, content ) {\u000a	if ( nodeName( elem, "table" ) &&\u000a		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {\u000a\u000a		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;\u000a	}\u000a\u000a	return elem;\u000a}\u000a\u000a// Replace/restore the type attribute of script elements for safe DOM manipulation\u000afunction disableScript( elem ) {\u000a	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;\u000a	return elem;\u000a}\u000afunction restoreScript( elem ) {\u000a	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {\u000a		elem.type = elem.type.slice( 5 );\u000a	} else {\u000a		elem.removeAttribute( "type" );\u000a	}\u000a\u000a	return elem;\u000a}\u000a\u000afunction cloneCopyEvent( src, dest ) {\u000a	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\u000a\u000a	if ( dest.nodeType !== 1 ) {\u000a		return;\u000a	}\u000a\u000a	// 1. Copy private data: events, handlers, etc.\u000a	if ( dataPriv.hasData( src ) ) {\u000a		pdataOld = dataPriv.access( src );\u000a		pdataCur = dataPriv.set( dest, pdataOld );\u000a		events = pdataOld.events;\u000a\u000a		if ( events ) {\u000a			delete pdataCur.handle;\u000a			pdataCur.events = {};\u000a\u000a			for ( type in events ) {\u000a				for ( i = 0, l = events[ type ].length; i < l; i++ ) {\u000a					jQuery.event.add( dest, type, events[ type ][ i ] );\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	// 2. Copy user data\u000a	if ( dataUser.hasData( src ) ) {\u000a		udataOld = dataUser.access( src );\u000a		udataCur = jQuery.extend( {}, udataOld );\u000a\u000a		dataUser.set( dest, udataCur );\u000a	}\u000a}\u000a\u000a// Fix IE bugs, see support tests\u000afunction fixInput( src, dest ) {\u000a	var nodeName = dest.nodeName.toLowerCase();\u000a\u000a	// Fails to persist the checked state of a cloned checkbox or radio button.\u000a	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {\u000a		dest.checked = src.checked;\u000a\u000a	// Fails to return the selected option to the default selected state when cloning options\u000a	} else if ( nodeName === "input" || nodeName === "textarea" ) {\u000a		dest.defaultValue = src.defaultValue;\u000a	}\u000a}\u000a\u000afunction domManip( collection, args, callback, ignored ) {\u000a\u000a	// Flatten any nested arrays\u000a	args = concat.apply( [], args );\u000a\u000a	var fragment, first, scripts, hasScripts, node, doc,\u000a		i = 0,\u000a		l = collection.length,\u000a		iNoClone = l - 1,\u000a		value = args[ 0 ],\u000a		valueIsFunction = isFunction( value );\u000a\u000a	// We can't cloneNode fragments that contain checked, in WebKit\u000a	if ( valueIsFunction ||\u000a			( l > 1 && typeof value === "string" &&\u000a				!support.checkClone && rchecked.test( value ) ) ) {\u000a		return collection.each( function( index ) {\u000a			var self = collection.eq( index );\u000a			if ( valueIsFunction ) {\u000a				args[ 0 ] = value.call( this, index, self.html() );\u000a			}\u000a			domManip( self, args, callback, ignored );\u000a		} );\u000a	}\u000a\u000a	if ( l ) {\u000a		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\u000a		first = fragment.firstChild;\u000a\u000a		if ( fragment.childNodes.length === 1 ) {\u000a			fragment = first;\u000a		}\u000a\u000a		// Require either new content or an interest in ignored elements to invoke the callback\u000a		if ( first || ignored ) {\u000a			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );\u000a			hasScripts = scripts.length;\u000a\u000a			// Use the original fragment for the last item\u000a			// instead of the first because it can end up\u000a			// being emptied incorrectly in certain situations (#8070).\u000a			for ( ; i < l; i++ ) {\u000a				node = fragment;\u000a\u000a				if ( i !== iNoClone ) {\u000a					node = jQuery.clone( node, true, true );\u000a\u000a					// Keep references to cloned scripts for later restoration\u000a					if ( hasScripts ) {\u000a\u000a						// Support: Android <=4.0 only, PhantomJS 1 only\u000a						// push.apply(_, arraylike) throws on ancient WebKit\u000a						jQuery.merge( scripts, getAll( node, "script" ) );\u000a					}\u000a				}\u000a\u000a				callback.call( collection[ i ], node, i );\u000a			}\u000a\u000a			if ( hasScripts ) {\u000a				doc = scripts[ scripts.length - 1 ].ownerDocument;\u000a\u000a				// Reenable scripts\u000a				jQuery.map( scripts, restoreScript );\u000a\u000a				// Evaluate executable scripts on first document insertion\u000a				for ( i = 0; i < hasScripts; i++ ) {\u000a					node = scripts[ i ];\u000a					if ( rscriptType.test( node.type || "" ) &&\u000a						!dataPriv.access( node, "globalEval" ) &&\u000a						jQuery.contains( doc, node ) ) {\u000a\u000a						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {\u000a\u000a							// Optional AJAX dependency, but won't run scripts if not present\u000a							if ( jQuery._evalUrl ) {\u000a								jQuery._evalUrl( node.src );\u000a							}\u000a						} else {\u000a							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );\u000a						}\u000a					}\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	return collection;\u000a}\u000a\u000afunction remove( elem, selector, keepData ) {\u000a	var node,\u000a		nodes = selector ? jQuery.filter( selector, elem ) : elem,\u000a		i = 0;\u000a\u000a	for ( ; ( node = nodes[ i ] ) != null; i++ ) {\u000a		if ( !keepData && node.nodeType === 1 ) {\u000a			jQuery.cleanData( getAll( node ) );\u000a		}\u000a\u000a		if ( node.parentNode ) {\u000a			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\u000a				setGlobalEval( getAll( node, "script" ) );\u000a			}\u000a			node.parentNode.removeChild( node );\u000a		}\u000a	}\u000a\u000a	return elem;\u000a}\u000a\u000ajQuery.extend( {\u000a	htmlPrefilter: function( html ) {\u000a		return html.replace( rxhtmlTag, "<$1></$2>" );\u000a	},\u000a\u000a	clone: function( elem, dataAndEvents, deepDataAndEvents ) {\u000a		var i, l, srcElements, destElements,\u000a			clone = elem.cloneNode( true ),\u000a			inPage = jQuery.contains( elem.ownerDocument, elem );\u000a\u000a		// Fix IE cloning issues\u000a		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\u000a				!jQuery.isXMLDoc( elem ) ) {\u000a\u000a			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\u000a			destElements = getAll( clone );\u000a			srcElements = getAll( elem );\u000a\u000a			for ( i = 0, l = srcElements.length; i < l; i++ ) {\u000a				fixInput( srcElements[ i ], destElements[ i ] );\u000a			}\u000a		}\u000a\u000a		// Copy the events from the original to the clone\u000a		if ( dataAndEvents ) {\u000a			if ( deepDataAndEvents ) {\u000a				srcElements = srcElements || getAll( elem );\u000a				destElements = destElements || getAll( clone );\u000a\u000a				for ( i = 0, l = srcElements.length; i < l; i++ ) {\u000a					cloneCopyEvent( srcElements[ i ], destElements[ i ] );\u000a				}\u000a			} else {\u000a				cloneCopyEvent( elem, clone );\u000a			}\u000a		}\u000a\u000a		// Preserve script evaluation history\u000a		destElements = getAll( clone, "script" );\u000a		if ( destElements.length > 0 ) {\u000a			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\u000a		}\u000a\u000a		// Return the cloned set\u000a		return clone;\u000a	},\u000a\u000a	cleanData: function( elems ) {\u000a		var data, elem, type,\u000a			special = jQuery.event.special,\u000a			i = 0;\u000a\u000a		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\u000a			if ( acceptData( elem ) ) {\u000a				if ( ( data = elem[ dataPriv.expando ] ) ) {\u000a					if ( data.events ) {\u000a						for ( type in data.events ) {\u000a							if ( special[ type ] ) {\u000a								jQuery.event.remove( elem, type );\u000a\u000a							// This is a shortcut to avoid jQuery.event.remove's overhead\u000a							} else {\u000a								jQuery.removeEvent( elem, type, data.handle );\u000a							}\u000a						}\u000a					}\u000a\u000a					// Support: Chrome <=35 - 45+\u000a					// Assign undefined instead of using delete, see Data#remove\u000a					elem[ dataPriv.expando ] = undefined;\u000a				}\u000a				if ( elem[ dataUser.expando ] ) {\u000a\u000a					// Support: Chrome <=35 - 45+\u000a					// Assign undefined instead of using delete, see Data#remove\u000a					elem[ dataUser.expando ] = undefined;\u000a				}\u000a			}\u000a		}\u000a	}\u000a} );\u000a\u000ajQuery.fn.extend( {\u000a	detach: function( selector ) {\u000a		return remove( this, selector, true );\u000a	},\u000a\u000a	remove: function( selector ) {\u000a		return remove( this, selector );\u000a	},\u000a\u000a	text: function( value ) {\u000a		return access( this, function( value ) {\u000a			return value === undefined ?\u000a				jQuery.text( this ) :\u000a				this.empty().each( function() {\u000a					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\u000a						this.textContent = value;\u000a					}\u000a				} );\u000a		}, null, value, arguments.length );\u000a	},\u000a\u000a	append: function() {\u000a		return domManip( this, arguments, function( elem ) {\u000a			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\u000a				var target = manipulationTarget( this, elem );\u000a				target.appendChild( elem );\u000a			}\u000a		} );\u000a	},\u000a\u000a	prepend: function() {\u000a		return domManip( this, arguments, function( elem ) {\u000a			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\u000a				var target = manipulationTarget( this, elem );\u000a				target.insertBefore( elem, target.firstChild );\u000a			}\u000a		} );\u000a	},\u000a\u000a	before: function() {\u000a		return domManip( this, arguments, function( elem ) {\u000a			if ( this.parentNode ) {\u000a				this.parentNode.insertBefore( elem, this );\u000a			}\u000a		} );\u000a	},\u000a\u000a	after: function() {\u000a		return domManip( this, arguments, function( elem ) {\u000a			if ( this.parentNode ) {\u000a				this.parentNode.insertBefore( elem, this.nextSibling );\u000a			}\u000a		} );\u000a	},\u000a\u000a	empty: function() {\u000a		var elem,\u000a			i = 0;\u000a\u000a		for ( ; ( elem = this[ i ] ) != null; i++ ) {\u000a			if ( elem.nodeType === 1 ) {\u000a\u000a				// Prevent memory leaks\u000a				jQuery.cleanData( getAll( elem, false ) );\u000a\u000a				// Remove any remaining nodes\u000a				elem.textContent = "";\u000a			}\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	clone: function( dataAndEvents, deepDataAndEvents ) {\u000a		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\u000a		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\u000a\u000a		return this.map( function() {\u000a			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );\u000a		} );\u000a	},\u000a\u000a	html: function( value ) {\u000a		return access( this, function( value ) {\u000a			var elem = this[ 0 ] || {},\u000a				i = 0,\u000a				l = this.length;\u000a\u000a			if ( value === undefined && elem.nodeType === 1 ) {\u000a				return elem.innerHTML;\u000a			}\u000a\u000a			// See if we can take a shortcut and just use innerHTML\u000a			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\u000a				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {\u000a\u000a				value = jQuery.htmlPrefilter( value );\u000a\u000a				try {\u000a					for ( ; i < l; i++ ) {\u000a						elem = this[ i ] || {};\u000a\u000a						// Remove element nodes and prevent memory leaks\u000a						if ( elem.nodeType === 1 ) {\u000a							jQuery.cleanData( getAll( elem, false ) );\u000a							elem.innerHTML = value;\u000a						}\u000a					}\u000a\u000a					elem = 0;\u000a\u000a				// If using innerHTML throws an exception, use the fallback method\u000a				} catch ( e ) {}\u000a			}\u000a\u000a			if ( elem ) {\u000a				this.empty().append( value );\u000a			}\u000a		}, null, value, arguments.length );\u000a	},\u000a\u000a	replaceWith: function() {\u000a		var ignored = [];\u000a\u000a		// Make the changes, replacing each non-ignored context element with the new content\u000a		return domManip( this, arguments, function( elem ) {\u000a			var parent = this.parentNode;\u000a\u000a			if ( jQuery.inArray( this, ignored ) < 0 ) {\u000a				jQuery.cleanData( getAll( this ) );\u000a				if ( parent ) {\u000a					parent.replaceChild( elem, this );\u000a				}\u000a			}\u000a\u000a		// Force callback invocation\u000a		}, ignored );\u000a	}\u000a} );\u000a\u000ajQuery.each( {\u000a	appendTo: "append",\u000a	prependTo: "prepend",\u000a	insertBefore: "before",\u000a	insertAfter: "after",\u000a	replaceAll: "replaceWith"\u000a}, function( name, original ) {\u000a	jQuery.fn[ name ] = function( selector ) {\u000a		var elems,\u000a			ret = [],\u000a			insert = jQuery( selector ),\u000a			last = insert.length - 1,\u000a			i = 0;\u000a\u000a		for ( ; i <= last; i++ ) {\u000a			elems = i === last ? this : this.clone( true );\u000a			jQuery( insert[ i ] )[ original ]( elems );\u000a\u000a			// Support: Android <=4.0 only, PhantomJS 1 only\u000a			// .get() because push.apply(_, arraylike) throws on ancient WebKit\u000a			push.apply( ret, elems.get() );\u000a		}\u000a\u000a		return this.pushStack( ret );\u000a	};\u000a} );\u000avar rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );\u000a\u000avar getStyles = function( elem ) {\u000a\u000a		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\u000a		// IE throws on elements created in popups\u000a		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\u000a		var view = elem.ownerDocument.defaultView;\u000a\u000a		if ( !view || !view.opener ) {\u000a			view = window;\u000a		}\u000a\u000a		return view.getComputedStyle( elem );\u000a	};\u000a\u000avar rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );\u000a\u000a\u000a\u000a( function() {\u000a\u000a	// Executing both pixelPosition & boxSizingReliable tests require only one layout\u000a	// so they're executed at the same time to save the second computation.\u000a	function computeStyleTests() {\u000a\u000a		// This is a singleton, we need to execute it only once\u000a		if ( !div ) {\u000a			return;\u000a		}\u000a\u000a		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +\u000a			"margin-top:1px;padding:0;border:0";\u000a		div.style.cssText =\u000a			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +\u000a			"margin:auto;border:1px;padding:1px;" +\u000a			"width:60%;top:1%";\u000a		documentElement.appendChild( container ).appendChild( div );\u000a\u000a		var divStyle = window.getComputedStyle( div );\u000a		pixelPositionVal = divStyle.top !== "1%";\u000a\u000a		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\u000a		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\u000a\u000a		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\u000a		// Some styles come back with percentage values, even though they shouldn't\u000a		div.style.right = "60%";\u000a		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\u000a\u000a		// Support: IE 9 - 11 only\u000a		// Detect misreporting of content dimensions for box-sizing:border-box elements\u000a		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\u000a\u000a		// Support: IE 9 only\u000a		// Detect overflow:scroll screwiness (gh-3699)\u000a		div.style.position = "absolute";\u000a		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";\u000a\u000a		documentElement.removeChild( container );\u000a\u000a		// Nullify the div so it wouldn't be stored in the memory and\u000a		// it will also be a sign that checks already performed\u000a		div = null;\u000a	}\u000a\u000a	function roundPixelMeasures( measure ) {\u000a		return Math.round( parseFloat( measure ) );\u000a	}\u000a\u000a	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\u000a		reliableMarginLeftVal,\u000a		container = document.createElement( "div" ),\u000a		div = document.createElement( "div" );\u000a\u000a	// Finish early in limited (non-browser) environments\u000a	if ( !div.style ) {\u000a		return;\u000a	}\u000a\u000a	// Support: IE <=9 - 11 only\u000a	// Style of cloned element affects source element cloned (#8908)\u000a	div.style.backgroundClip = "content-box";\u000a	div.cloneNode( true ).style.backgroundClip = "";\u000a	support.clearCloneStyle = div.style.backgroundClip === "content-box";\u000a\u000a	jQuery.extend( support, {\u000a		boxSizingReliable: function() {\u000a			computeStyleTests();\u000a			return boxSizingReliableVal;\u000a		},\u000a		pixelBoxStyles: function() {\u000a			computeStyleTests();\u000a			return pixelBoxStylesVal;\u000a		},\u000a		pixelPosition: function() {\u000a			computeStyleTests();\u000a			return pixelPositionVal;\u000a		},\u000a		reliableMarginLeft: function() {\u000a			computeStyleTests();\u000a			return reliableMarginLeftVal;\u000a		},\u000a		scrollboxSize: function() {\u000a			computeStyleTests();\u000a			return scrollboxSizeVal;\u000a		}\u000a	} );\u000a} )();\u000a\u000a\u000afunction curCSS( elem, name, computed ) {\u000a	var width, minWidth, maxWidth, ret,\u000a\u000a		// Support: Firefox 51+\u000a		// Retrieving style before computed somehow\u000a		// fixes an issue with getting wrong values\u000a		// on detached elements\u000a		style = elem.style;\u000a\u000a	computed = computed || getStyles( elem );\u000a\u000a	// getPropertyValue is needed for:\u000a	//   .css('filter') (IE 9 only, #12537)\u000a	//   .css('--customProperty) (#3144)\u000a	if ( computed ) {\u000a		ret = computed.getPropertyValue( name ) || computed[ name ];\u000a\u000a		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {\u000a			ret = jQuery.style( elem, name );\u000a		}\u000a\u000a		// A tribute to the "awesome hack by Dean Edwards"\u000a		// Android Browser returns percentage for some values,\u000a		// but width seems to be reliably pixels.\u000a		// This is against the CSSOM draft spec:\u000a		// https://drafts.csswg.org/cssom/#resolved-values\u000a		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\u000a\u000a			// Remember the original values\u000a			width = style.width;\u000a			minWidth = style.minWidth;\u000a			maxWidth = style.maxWidth;\u000a\u000a			// Put in the new values to get a computed value out\u000a			style.minWidth = style.maxWidth = style.width = ret;\u000a			ret = computed.width;\u000a\u000a			// Revert the changed values\u000a			style.width = width;\u000a			style.minWidth = minWidth;\u000a			style.maxWidth = maxWidth;\u000a		}\u000a	}\u000a\u000a	return ret !== undefined ?\u000a\u000a		// Support: IE <=9 - 11 only\u000a		// IE returns zIndex value as an integer.\u000a		ret + "" :\u000a		ret;\u000a}\u000a\u000a\u000afunction addGetHookIf( conditionFn, hookFn ) {\u000a\u000a	// Define the hook, we'll check on the first run if it's really needed.\u000a	return {\u000a		get: function() {\u000a			if ( conditionFn() ) {\u000a\u000a				// Hook not needed (or it's not possible to use it due\u000a				// to missing dependency), remove it.\u000a				delete this.get;\u000a				return;\u000a			}\u000a\u000a			// Hook needed; redefine it so that the support test is not executed again.\u000a			return ( this.get = hookFn ).apply( this, arguments );\u000a		}\u000a	};\u000a}\u000a\u000a\u000avar\u000a\u000a	// Swappable if display is none or starts with table\u000a	// except "table", "table-cell", or "table-caption"\u000a	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\u000a	rdisplayswap = /^(none|table(?!-c[ea]).+)/,\u000a	rcustomProp = /^--/,\u000a	cssShow = { position: "absolute", visibility: "hidden", display: "block" },\u000a	cssNormalTransform = {\u000a		letterSpacing: "0",\u000a		fontWeight: "400"\u000a	},\u000a\u000a	cssPrefixes = [ "Webkit", "Moz", "ms" ],\u000a	emptyStyle = document.createElement( "div" ).style;\u000a\u000a// Return a css property mapped to a potentially vendor prefixed property\u000afunction vendorPropName( name ) {\u000a\u000a	// Shortcut for names that are not vendor prefixed\u000a	if ( name in emptyStyle ) {\u000a		return name;\u000a	}\u000a\u000a	// Check for vendor prefixed names\u000a	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\u000a		i = cssPrefixes.length;\u000a\u000a	while ( i-- ) {\u000a		name = cssPrefixes[ i ] + capName;\u000a		if ( name in emptyStyle ) {\u000a			return name;\u000a		}\u000a	}\u000a}\u000a\u000a// Return a property mapped along what jQuery.cssProps suggests or to\u000a// a vendor prefixed property.\u000afunction finalPropName( name ) {\u000a	var ret = jQuery.cssProps[ name ];\u000a	if ( !ret ) {\u000a		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\u000a	}\u000a	return ret;\u000a}\u000a\u000afunction setPositiveNumber( elem, value, subtract ) {\u000a\u000a	// Any relative (+/-) values have already been\u000a	// normalized at this point\u000a	var matches = rcssNum.exec( value );\u000a	return matches ?\u000a\u000a		// Guard against undefined "subtract", e.g., when used as in cssHooks\u000a		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :\u000a		value;\u000a}\u000a\u000afunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\u000a	var i = dimension === "width" ? 1 : 0,\u000a		extra = 0,\u000a		delta = 0;\u000a\u000a	// Adjustment may not be necessary\u000a	if ( box === ( isBorderBox ? "border" : "content" ) ) {\u000a		return 0;\u000a	}\u000a\u000a	for ( ; i < 4; i += 2 ) {\u000a\u000a		// Both box models exclude margin\u000a		if ( box === "margin" ) {\u000a			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\u000a		}\u000a\u000a		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"\u000a		if ( !isBorderBox ) {\u000a\u000a			// Add padding\u000a			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\u000a\u000a			// For "border" or "margin", add border\u000a			if ( box !== "padding" ) {\u000a				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\u000a\u000a			// But still keep track of it otherwise\u000a			} else {\u000a				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\u000a			}\u000a\u000a		// If we get here with a border-box (content + padding + border), we're seeking "content" or\u000a		// "padding" or "margin"\u000a		} else {\u000a\u000a			// For "content", subtract padding\u000a			if ( box === "content" ) {\u000a				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\u000a			}\u000a\u000a			// For "content" or "padding", subtract border\u000a			if ( box !== "margin" ) {\u000a				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\u000a			}\u000a		}\u000a	}\u000a\u000a	// Account for positive content-box scroll gutter when requested by providing computedVal\u000a	if ( !isBorderBox && computedVal >= 0 ) {\u000a\u000a		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\u000a		// Assuming integer scroll gutter, subtract the rest and round down\u000a		delta += Math.max( 0, Math.ceil(\u000a			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\u000a			computedVal -\u000a			delta -\u000a			extra -\u000a			0.5\u000a		) );\u000a	}\u000a\u000a	return delta;\u000a}\u000a\u000afunction getWidthOrHeight( elem, dimension, extra ) {\u000a\u000a	// Start with computed style\u000a	var styles = getStyles( elem ),\u000a		val = curCSS( elem, dimension, styles ),\u000a		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",\u000a		valueIsBorderBox = isBorderBox;\u000a\u000a	// Support: Firefox <=54\u000a	// Return a confounding non-pixel value or feign ignorance, as appropriate.\u000a	if ( rnumnonpx.test( val ) ) {\u000a		if ( !extra ) {\u000a			return val;\u000a		}\u000a		val = "auto";\u000a	}\u000a\u000a	// Check for style in case a browser which returns unreliable values\u000a	// for getComputedStyle silently falls back to the reliable elem.style\u000a	valueIsBorderBox = valueIsBorderBox &&\u000a		( support.boxSizingReliable() || val === elem.style[ dimension ] );\u000a\u000a	// Fall back to offsetWidth/offsetHeight when value is "auto"\u000a	// This happens for inline elements with no explicit setting (gh-3571)\u000a	// Support: Android <=4.1 - 4.3 only\u000a	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\u000a	if ( val === "auto" ||\u000a		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {\u000a\u000a		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];\u000a\u000a		// offsetWidth/offsetHeight provide border-box values\u000a		valueIsBorderBox = true;\u000a	}\u000a\u000a	// Normalize "" and auto\u000a	val = parseFloat( val ) || 0;\u000a\u000a	// Adjust for the element's box model\u000a	return ( val +\u000a		boxModelAdjustment(\u000a			elem,\u000a			dimension,\u000a			extra || ( isBorderBox ? "border" : "content" ),\u000a			valueIsBorderBox,\u000a			styles,\u000a\u000a			// Provide the current computed size to request scroll gutter calculation (gh-3589)\u000a			val\u000a		)\u000a	) + "px";\u000a}\u000a\u000ajQuery.extend( {\u000a\u000a	// Add in style property hooks for overriding the default\u000a	// behavior of getting and setting a style property\u000a	cssHooks: {\u000a		opacity: {\u000a			get: function( elem, computed ) {\u000a				if ( computed ) {\u000a\u000a					// We should always get a number back from opacity\u000a					var ret = curCSS( elem, "opacity" );\u000a					return ret === "" ? "1" : ret;\u000a				}\u000a			}\u000a		}\u000a	},\u000a\u000a	// Don't automatically add "px" to these possibly-unitless properties\u000a	cssNumber: {\u000a		"animationIterationCount": true,\u000a		"columnCount": true,\u000a		"fillOpacity": true,\u000a		"flexGrow": true,\u000a		"flexShrink": true,\u000a		"fontWeight": true,\u000a		"lineHeight": true,\u000a		"opacity": true,\u000a		"order": true,\u000a		"orphans": true,\u000a		"widows": true,\u000a		"zIndex": true,\u000a		"zoom": true\u000a	},\u000a\u000a	// Add in properties whose names you wish to fix before\u000a	// setting or getting the value\u000a	cssProps: {},\u000a\u000a	// Get and set the style property on a DOM Node\u000a	style: function( elem, name, value, extra ) {\u000a\u000a		// Don't set styles on text and comment nodes\u000a		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\u000a			return;\u000a		}\u000a\u000a		// Make sure that we're working with the right name\u000a		var ret, type, hooks,\u000a			origName = camelCase( name ),\u000a			isCustomProp = rcustomProp.test( name ),\u000a			style = elem.style;\u000a\u000a		// Make sure that we're working with the right name. We don't\u000a		// want to query the value if it is a CSS custom property\u000a		// since they are user-defined.\u000a		if ( !isCustomProp ) {\u000a			name = finalPropName( origName );\u000a		}\u000a\u000a		// Gets hook for the prefixed version, then unprefixed version\u000a		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\u000a\u000a		// Check if we're setting a value\u000a		if ( value !== undefined ) {\u000a			type = typeof value;\u000a\u000a			// Convert "+=" or "-=" to relative numbers (#7345)\u000a			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\u000a				value = adjustCSS( elem, name, ret );\u000a\u000a				// Fixes bug #9237\u000a				type = "number";\u000a			}\u000a\u000a			// Make sure that null and NaN values aren't set (#7116)\u000a			if ( value == null || value !== value ) {\u000a				return;\u000a			}\u000a\u000a			// If a number was passed in, add the unit (except for certain CSS properties)\u000a			if ( type === "number" ) {\u000a				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );\u000a			}\u000a\u000a			// background-* props affect original clone's values\u000a			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {\u000a				style[ name ] = "inherit";\u000a			}\u000a\u000a			// If a hook was provided, use that value, otherwise just set the specified value\u000a			if ( !hooks || !( "set" in hooks ) ||\u000a				( value = hooks.set( elem, value, extra ) ) !== undefined ) {\u000a\u000a				if ( isCustomProp ) {\u000a					style.setProperty( name, value );\u000a				} else {\u000a					style[ name ] = value;\u000a				}\u000a			}\u000a\u000a		} else {\u000a\u000a			// If a hook was provided get the non-computed value from there\u000a			if ( hooks && "get" in hooks &&\u000a				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\u000a\u000a				return ret;\u000a			}\u000a\u000a			// Otherwise just get the value from the style object\u000a			return style[ name ];\u000a		}\u000a	},\u000a\u000a	css: function( elem, name, extra, styles ) {\u000a		var val, num, hooks,\u000a			origName = camelCase( name ),\u000a			isCustomProp = rcustomProp.test( name );\u000a\u000a		// Make sure that we're working with the right name. We don't\u000a		// want to modify the value if it is a CSS custom property\u000a		// since they are user-defined.\u000a		if ( !isCustomProp ) {\u000a			name = finalPropName( origName );\u000a		}\u000a\u000a		// Try prefixed name followed by the unprefixed name\u000a		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\u000a\u000a		// If a hook was provided get the computed value from there\u000a		if ( hooks && "get" in hooks ) {\u000a			val = hooks.get( elem, true, extra );\u000a		}\u000a\u000a		// Otherwise, if a way to get the computed value exists, use that\u000a		if ( val === undefined ) {\u000a			val = curCSS( elem, name, styles );\u000a		}\u000a\u000a		// Convert "normal" to computed value\u000a		if ( val === "normal" && name in cssNormalTransform ) {\u000a			val = cssNormalTransform[ name ];\u000a		}\u000a\u000a		// Make numeric if forced or a qualifier was provided and val looks numeric\u000a		if ( extra === "" || extra ) {\u000a			num = parseFloat( val );\u000a			return extra === true || isFinite( num ) ? num || 0 : val;\u000a		}\u000a\u000a		return val;\u000a	}\u000a} );\u000a\u000ajQuery.each( [ "height", "width" ], function( i, dimension ) {\u000a	jQuery.cssHooks[ dimension ] = {\u000a		get: function( elem, computed, extra ) {\u000a			if ( computed ) {\u000a\u000a				// Certain elements can have dimension info if we invisibly show them\u000a				// but it must have a current display style that would benefit\u000a				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&\u000a\u000a					// Support: Safari 8+\u000a					// Table columns in Safari have non-zero offsetWidth & zero\u000a					// getBoundingClientRect().width unless display is changed.\u000a					// Support: IE <=11 only\u000a					// Running getBoundingClientRect on a disconnected node\u000a					// in IE throws an error.\u000a					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\u000a						swap( elem, cssShow, function() {\u000a							return getWidthOrHeight( elem, dimension, extra );\u000a						} ) :\u000a						getWidthOrHeight( elem, dimension, extra );\u000a			}\u000a		},\u000a\u000a		set: function( elem, value, extra ) {\u000a			var matches,\u000a				styles = getStyles( elem ),\u000a				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",\u000a				subtract = extra && boxModelAdjustment(\u000a					elem,\u000a					dimension,\u000a					extra,\u000a					isBorderBox,\u000a					styles\u000a				);\u000a\u000a			// Account for unreliable border-box dimensions by comparing offset* to computed and\u000a			// faking a content-box to get border and padding (gh-3699)\u000a			if ( isBorderBox && support.scrollboxSize() === styles.position ) {\u000a				subtract -= Math.ceil(\u000a					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\u000a					parseFloat( styles[ dimension ] ) -\u000a					boxModelAdjustment( elem, dimension, "border", false, styles ) -\u000a					0.5\u000a				);\u000a			}\u000a\u000a			// Convert to pixels if value adjustment is needed\u000a			if ( subtract && ( matches = rcssNum.exec( value ) ) &&\u000a				( matches[ 3 ] || "px" ) !== "px" ) {\u000a\u000a				elem.style[ dimension ] = value;\u000a				value = jQuery.css( elem, dimension );\u000a			}\u000a\u000a			return setPositiveNumber( elem, value, subtract );\u000a		}\u000a	};\u000a} );\u000a\u000ajQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\u000a	function( elem, computed ) {\u000a		if ( computed ) {\u000a			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||\u000a				elem.getBoundingClientRect().left -\u000a					swap( elem, { marginLeft: 0 }, function() {\u000a						return elem.getBoundingClientRect().left;\u000a					} )\u000a				) + "px";\u000a		}\u000a	}\u000a);\u000a\u000a// These hooks are used by animate to expand properties\u000ajQuery.each( {\u000a	margin: "",\u000a	padding: "",\u000a	border: "Width"\u000a}, function( prefix, suffix ) {\u000a	jQuery.cssHooks[ prefix + suffix ] = {\u000a		expand: function( value ) {\u000a			var i = 0,\u000a				expanded = {},\u000a\u000a				// Assumes a single number if not a string\u000a				parts = typeof value === "string" ? value.split( " " ) : [ value ];\u000a\u000a			for ( ; i < 4; i++ ) {\u000a				expanded[ prefix + cssExpand[ i ] + suffix ] =\u000a					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];\u000a			}\u000a\u000a			return expanded;\u000a		}\u000a	};\u000a\u000a	if ( prefix !== "margin" ) {\u000a		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\u000a	}\u000a} );\u000a\u000ajQuery.fn.extend( {\u000a	css: function( name, value ) {\u000a		return access( this, function( elem, name, value ) {\u000a			var styles, len,\u000a				map = {},\u000a				i = 0;\u000a\u000a			if ( Array.isArray( name ) ) {\u000a				styles = getStyles( elem );\u000a				len = name.length;\u000a\u000a				for ( ; i < len; i++ ) {\u000a					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\u000a				}\u000a\u000a				return map;\u000a			}\u000a\u000a			return value !== undefined ?\u000a				jQuery.style( elem, name, value ) :\u000a				jQuery.css( elem, name );\u000a		}, name, value, arguments.length > 1 );\u000a	}\u000a} );\u000a\u000a\u000afunction Tween( elem, options, prop, end, easing ) {\u000a	return new Tween.prototype.init( elem, options, prop, end, easing );\u000a}\u000ajQuery.Tween = Tween;\u000a\u000aTween.prototype = {\u000a	constructor: Tween,\u000a	init: function( elem, options, prop, end, easing, unit ) {\u000a		this.elem = elem;\u000a		this.prop = prop;\u000a		this.easing = easing || jQuery.easing._default;\u000a		this.options = options;\u000a		this.start = this.now = this.cur();\u000a		this.end = end;\u000a		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\u000a	},\u000a	cur: function() {\u000a		var hooks = Tween.propHooks[ this.prop ];\u000a\u000a		return hooks && hooks.get ?\u000a			hooks.get( this ) :\u000a			Tween.propHooks._default.get( this );\u000a	},\u000a	run: function( percent ) {\u000a		var eased,\u000a			hooks = Tween.propHooks[ this.prop ];\u000a\u000a		if ( this.options.duration ) {\u000a			this.pos = eased = jQuery.easing[ this.easing ](\u000a				percent, this.options.duration * percent, 0, 1, this.options.duration\u000a			);\u000a		} else {\u000a			this.pos = eased = percent;\u000a		}\u000a		this.now = ( this.end - this.start ) * eased + this.start;\u000a\u000a		if ( this.options.step ) {\u000a			this.options.step.call( this.elem, this.now, this );\u000a		}\u000a\u000a		if ( hooks && hooks.set ) {\u000a			hooks.set( this );\u000a		} else {\u000a			Tween.propHooks._default.set( this );\u000a		}\u000a		return this;\u000a	}\u000a};\u000a\u000aTween.prototype.init.prototype = Tween.prototype;\u000a\u000aTween.propHooks = {\u000a	_default: {\u000a		get: function( tween ) {\u000a			var result;\u000a\u000a			// Use a property on the element directly when it is not a DOM element,\u000a			// or when there is no matching style property that exists.\u000a			if ( tween.elem.nodeType !== 1 ||\u000a				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\u000a				return tween.elem[ tween.prop ];\u000a			}\u000a\u000a			// Passing an empty string as a 3rd parameter to .css will automatically\u000a			// attempt a parseFloat and fallback to a string if the parse fails.\u000a			// Simple values such as "10px" are parsed to Float;\u000a			// complex values such as "rotate(1rad)" are returned as-is.\u000a			result = jQuery.css( tween.elem, tween.prop, "" );\u000a\u000a			// Empty strings, null, undefined and "auto" are converted to 0.\u000a			return !result || result === "auto" ? 0 : result;\u000a		},\u000a		set: function( tween ) {\u000a\u000a			// Use step hook for back compat.\u000a			// Use cssHook if its there.\u000a			// Use .style if available and use plain properties where available.\u000a			if ( jQuery.fx.step[ tween.prop ] ) {\u000a				jQuery.fx.step[ tween.prop ]( tween );\u000a			} else if ( tween.elem.nodeType === 1 &&\u000a				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\u000a					jQuery.cssHooks[ tween.prop ] ) ) {\u000a				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\u000a			} else {\u000a				tween.elem[ tween.prop ] = tween.now;\u000a			}\u000a		}\u000a	}\u000a};\u000a\u000a// Support: IE <=9 only\u000a// Panic based approach to setting things on disconnected nodes\u000aTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\u000a	set: function( tween ) {\u000a		if ( tween.elem.nodeType && tween.elem.parentNode ) {\u000a			tween.elem[ tween.prop ] = tween.now;\u000a		}\u000a	}\u000a};\u000a\u000ajQuery.easing = {\u000a	linear: function( p ) {\u000a		return p;\u000a	},\u000a	swing: function( p ) {\u000a		return 0.5 - Math.cos( p * Math.PI ) / 2;\u000a	},\u000a	_default: "swing"\u000a};\u000a\u000ajQuery.fx = Tween.prototype.init;\u000a\u000a// Back compat <1.8 extension point\u000ajQuery.fx.step = {};\u000a\u000a\u000a\u000a\u000avar\u000a	fxNow, inProgress,\u000a	rfxtypes = /^(?:toggle|show|hide)$/,\u000a	rrun = /queueHooks$/;\u000a\u000afunction schedule() {\u000a	if ( inProgress ) {\u000a		if ( document.hidden === false && window.requestAnimationFrame ) {\u000a			window.requestAnimationFrame( schedule );\u000a		} else {\u000a			window.setTimeout( schedule, jQuery.fx.interval );\u000a		}\u000a\u000a		jQuery.fx.tick();\u000a	}\u000a}\u000a\u000a// Animations created synchronously will run synchronously\u000afunction createFxNow() {\u000a	window.setTimeout( function() {\u000a		fxNow = undefined;\u000a	} );\u000a	return ( fxNow = Date.now() );\u000a}\u000a\u000a// Generate parameters to create a standard animation\u000afunction genFx( type, includeWidth ) {\u000a	var which,\u000a		i = 0,\u000a		attrs = { height: type };\u000a\u000a	// If we include width, step value is 1 to do all cssExpand values,\u000a	// otherwise step value is 2 to skip over Left and Right\u000a	includeWidth = includeWidth ? 1 : 0;\u000a	for ( ; i < 4; i += 2 - includeWidth ) {\u000a		which = cssExpand[ i ];\u000a		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\u000a	}\u000a\u000a	if ( includeWidth ) {\u000a		attrs.opacity = attrs.width = type;\u000a	}\u000a\u000a	return attrs;\u000a}\u000a\u000afunction createTween( value, prop, animation ) {\u000a	var tween,\u000a		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),\u000a		index = 0,\u000a		length = collection.length;\u000a	for ( ; index < length; index++ ) {\u000a		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\u000a\u000a			// We're done with this property\u000a			return tween;\u000a		}\u000a	}\u000a}\u000a\u000afunction defaultPrefilter( elem, props, opts ) {\u000a	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\u000a		isBox = "width" in props || "height" in props,\u000a		anim = this,\u000a		orig = {},\u000a		style = elem.style,\u000a		hidden = elem.nodeType && isHiddenWithinTree( elem ),\u000a		dataShow = dataPriv.get( elem, "fxshow" );\u000a\u000a	// Queue-skipping animations hijack the fx hooks\u000a	if ( !opts.queue ) {\u000a		hooks = jQuery._queueHooks( elem, "fx" );\u000a		if ( hooks.unqueued == null ) {\u000a			hooks.unqueued = 0;\u000a			oldfire = hooks.empty.fire;\u000a			hooks.empty.fire = function() {\u000a				if ( !hooks.unqueued ) {\u000a					oldfire();\u000a				}\u000a			};\u000a		}\u000a		hooks.unqueued++;\u000a\u000a		anim.always( function() {\u000a\u000a			// Ensure the complete handler is called before this completes\u000a			anim.always( function() {\u000a				hooks.unqueued--;\u000a				if ( !jQuery.queue( elem, "fx" ).length ) {\u000a					hooks.empty.fire();\u000a				}\u000a			} );\u000a		} );\u000a	}\u000a\u000a	// Detect show/hide animations\u000a	for ( prop in props ) {\u000a		value = props[ prop ];\u000a		if ( rfxtypes.test( value ) ) {\u000a			delete props[ prop ];\u000a			toggle = toggle || value === "toggle";\u000a			if ( value === ( hidden ? "hide" : "show" ) ) {\u000a\u000a				// Pretend to be hidden if this is a "show" and\u000a				// there is still data from a stopped show/hide\u000a				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {\u000a					hidden = true;\u000a\u000a				// Ignore all other no-op show/hide data\u000a				} else {\u000a					continue;\u000a				}\u000a			}\u000a			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\u000a		}\u000a	}\u000a\u000a	// Bail out if this is a no-op like .hide().hide()\u000a	propTween = !jQuery.isEmptyObject( props );\u000a	if ( !propTween && jQuery.isEmptyObject( orig ) ) {\u000a		return;\u000a	}\u000a\u000a	// Restrict "overflow" and "display" styles during box animations\u000a	if ( isBox && elem.nodeType === 1 ) {\u000a\u000a		// Support: IE <=9 - 11, Edge 12 - 15\u000a		// Record all 3 overflow attributes because IE does not infer the shorthand\u000a		// from identically-valued overflowX and overflowY and Edge just mirrors\u000a		// the overflowX value there.\u000a		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\u000a\u000a		// Identify a display type, preferring old show/hide data over the CSS cascade\u000a		restoreDisplay = dataShow && dataShow.display;\u000a		if ( restoreDisplay == null ) {\u000a			restoreDisplay = dataPriv.get( elem, "display" );\u000a		}\u000a		display = jQuery.css( elem, "display" );\u000a		if ( display === "none" ) {\u000a			if ( restoreDisplay ) {\u000a				display = restoreDisplay;\u000a			} else {\u000a\u000a				// Get nonempty value(s) by temporarily forcing visibility\u000a				showHide( [ elem ], true );\u000a				restoreDisplay = elem.style.display || restoreDisplay;\u000a				display = jQuery.css( elem, "display" );\u000a				showHide( [ elem ] );\u000a			}\u000a		}\u000a\u000a		// Animate inline elements as inline-block\u000a		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {\u000a			if ( jQuery.css( elem, "float" ) === "none" ) {\u000a\u000a				// Restore the original display value at the end of pure show/hide animations\u000a				if ( !propTween ) {\u000a					anim.done( function() {\u000a						style.display = restoreDisplay;\u000a					} );\u000a					if ( restoreDisplay == null ) {\u000a						display = style.display;\u000a						restoreDisplay = display === "none" ? "" : display;\u000a					}\u000a				}\u000a				style.display = "inline-block";\u000a			}\u000a		}\u000a	}\u000a\u000a	if ( opts.overflow ) {\u000a		style.overflow = "hidden";\u000a		anim.always( function() {\u000a			style.overflow = opts.overflow[ 0 ];\u000a			style.overflowX = opts.overflow[ 1 ];\u000a			style.overflowY = opts.overflow[ 2 ];\u000a		} );\u000a	}\u000a\u000a	// Implement show/hide animations\u000a	propTween = false;\u000a	for ( prop in orig ) {\u000a\u000a		// General show/hide setup for this element animation\u000a		if ( !propTween ) {\u000a			if ( dataShow ) {\u000a				if ( "hidden" in dataShow ) {\u000a					hidden = dataShow.hidden;\u000a				}\u000a			} else {\u000a				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );\u000a			}\u000a\u000a			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"\u000a			if ( toggle ) {\u000a				dataShow.hidden = !hidden;\u000a			}\u000a\u000a			// Show elements before animating them\u000a			if ( hidden ) {\u000a				showHide( [ elem ], true );\u000a			}\u000a\u000a			/* eslint-disable no-loop-func */\u000a\u000a			anim.done( function() {\u000a\u000a			/* eslint-enable no-loop-func */\u000a\u000a				// The final step of a "hide" animation is actually hiding the element\u000a				if ( !hidden ) {\u000a					showHide( [ elem ] );\u000a				}\u000a				dataPriv.remove( elem, "fxshow" );\u000a				for ( prop in orig ) {\u000a					jQuery.style( elem, prop, orig[ prop ] );\u000a				}\u000a			} );\u000a		}\u000a\u000a		// Per-property setup\u000a		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\u000a		if ( !( prop in dataShow ) ) {\u000a			dataShow[ prop ] = propTween.start;\u000a			if ( hidden ) {\u000a				propTween.end = propTween.start;\u000a				propTween.start = 0;\u000a			}\u000a		}\u000a	}\u000a}\u000a\u000afunction propFilter( props, specialEasing ) {\u000a	var index, name, easing, value, hooks;\u000a\u000a	// camelCase, specialEasing and expand cssHook pass\u000a	for ( index in props ) {\u000a		name = camelCase( index );\u000a		easing = specialEasing[ name ];\u000a		value = props[ index ];\u000a		if ( Array.isArray( value ) ) {\u000a			easing = value[ 1 ];\u000a			value = props[ index ] = value[ 0 ];\u000a		}\u000a\u000a		if ( index !== name ) {\u000a			props[ name ] = value;\u000a			delete props[ index ];\u000a		}\u000a\u000a		hooks = jQuery.cssHooks[ name ];\u000a		if ( hooks && "expand" in hooks ) {\u000a			value = hooks.expand( value );\u000a			delete props[ name ];\u000a\u000a			// Not quite $.extend, this won't overwrite existing keys.\u000a			// Reusing 'index' because we have the correct "name"\u000a			for ( index in value ) {\u000a				if ( !( index in props ) ) {\u000a					props[ index ] = value[ index ];\u000a					specialEasing[ index ] = easing;\u000a				}\u000a			}\u000a		} else {\u000a			specialEasing[ name ] = easing;\u000a		}\u000a	}\u000a}\u000a\u000afunction Animation( elem, properties, options ) {\u000a	var result,\u000a		stopped,\u000a		index = 0,\u000a		length = Animation.prefilters.length,\u000a		deferred = jQuery.Deferred().always( function() {\u000a\u000a			// Don't match elem in the :animated selector\u000a			delete tick.elem;\u000a		} ),\u000a		tick = function() {\u000a			if ( stopped ) {\u000a				return false;\u000a			}\u000a			var currentTime = fxNow || createFxNow(),\u000a				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\u000a\u000a				// Support: Android 2.3 only\u000a				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\u000a				temp = remaining / animation.duration || 0,\u000a				percent = 1 - temp,\u000a				index = 0,\u000a				length = animation.tweens.length;\u000a\u000a			for ( ; index < length; index++ ) {\u000a				animation.tweens[ index ].run( percent );\u000a			}\u000a\u000a			deferred.notifyWith( elem, [ animation, percent, remaining ] );\u000a\u000a			// If there's more to do, yield\u000a			if ( percent < 1 && length ) {\u000a				return remaining;\u000a			}\u000a\u000a			// If this was an empty animation, synthesize a final progress notification\u000a			if ( !length ) {\u000a				deferred.notifyWith( elem, [ animation, 1, 0 ] );\u000a			}\u000a\u000a			// Resolve the animation and report its conclusion\u000a			deferred.resolveWith( elem, [ animation ] );\u000a			return false;\u000a		},\u000a		animation = deferred.promise( {\u000a			elem: elem,\u000a			props: jQuery.extend( {}, properties ),\u000a			opts: jQuery.extend( true, {\u000a				specialEasing: {},\u000a				easing: jQuery.easing._default\u000a			}, options ),\u000a			originalProperties: properties,\u000a			originalOptions: options,\u000a			startTime: fxNow || createFxNow(),\u000a			duration: options.duration,\u000a			tweens: [],\u000a			createTween: function( prop, end ) {\u000a				var tween = jQuery.Tween( elem, animation.opts, prop, end,\u000a						animation.opts.specialEasing[ prop ] || animation.opts.easing );\u000a				animation.tweens.push( tween );\u000a				return tween;\u000a			},\u000a			stop: function( gotoEnd ) {\u000a				var index = 0,\u000a\u000a					// If we are going to the end, we want to run all the tweens\u000a					// otherwise we skip this part\u000a					length = gotoEnd ? animation.tweens.length : 0;\u000a				if ( stopped ) {\u000a					return this;\u000a				}\u000a				stopped = true;\u000a				for ( ; index < length; index++ ) {\u000a					animation.tweens[ index ].run( 1 );\u000a				}\u000a\u000a				// Resolve when we played the last frame; otherwise, reject\u000a				if ( gotoEnd ) {\u000a					deferred.notifyWith( elem, [ animation, 1, 0 ] );\u000a					deferred.resolveWith( elem, [ animation, gotoEnd ] );\u000a				} else {\u000a					deferred.rejectWith( elem, [ animation, gotoEnd ] );\u000a				}\u000a				return this;\u000a			}\u000a		} ),\u000a		props = animation.props;\u000a\u000a	propFilter( props, animation.opts.specialEasing );\u000a\u000a	for ( ; index < length; index++ ) {\u000a		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\u000a		if ( result ) {\u000a			if ( isFunction( result.stop ) ) {\u000a				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\u000a					result.stop.bind( result );\u000a			}\u000a			return result;\u000a		}\u000a	}\u000a\u000a	jQuery.map( props, createTween, animation );\u000a\u000a	if ( isFunction( animation.opts.start ) ) {\u000a		animation.opts.start.call( elem, animation );\u000a	}\u000a\u000a	// Attach callbacks from options\u000a	animation\u000a		.progress( animation.opts.progress )\u000a		.done( animation.opts.done, animation.opts.complete )\u000a		.fail( animation.opts.fail )\u000a		.always( animation.opts.always );\u000a\u000a	jQuery.fx.timer(\u000a		jQuery.extend( tick, {\u000a			elem: elem,\u000a			anim: animation,\u000a			queue: animation.opts.queue\u000a		} )\u000a	);\u000a\u000a	return animation;\u000a}\u000a\u000ajQuery.Animation = jQuery.extend( Animation, {\u000a\u000a	tweeners: {\u000a		"*": [ function( prop, value ) {\u000a			var tween = this.createTween( prop, value );\u000a			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\u000a			return tween;\u000a		} ]\u000a	},\u000a\u000a	tweener: function( props, callback ) {\u000a		if ( isFunction( props ) ) {\u000a			callback = props;\u000a			props = [ "*" ];\u000a		} else {\u000a			props = props.match( rnothtmlwhite );\u000a		}\u000a\u000a		var prop,\u000a			index = 0,\u000a			length = props.length;\u000a\u000a		for ( ; index < length; index++ ) {\u000a			prop = props[ index ];\u000a			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\u000a			Animation.tweeners[ prop ].unshift( callback );\u000a		}\u000a	},\u000a\u000a	prefilters: [ defaultPrefilter ],\u000a\u000a	prefilter: function( callback, prepend ) {\u000a		if ( prepend ) {\u000a			Animation.prefilters.unshift( callback );\u000a		} else {\u000a			Animation.prefilters.push( callback );\u000a		}\u000a	}\u000a} );\u000a\u000ajQuery.speed = function( speed, easing, fn ) {\u000a	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\u000a		complete: fn || !fn && easing ||\u000a			isFunction( speed ) && speed,\u000a		duration: speed,\u000a		easing: fn && easing || easing && !isFunction( easing ) && easing\u000a	};\u000a\u000a	// Go to the end state if fx are off\u000a	if ( jQuery.fx.off ) {\u000a		opt.duration = 0;\u000a\u000a	} else {\u000a		if ( typeof opt.duration !== "number" ) {\u000a			if ( opt.duration in jQuery.fx.speeds ) {\u000a				opt.duration = jQuery.fx.speeds[ opt.duration ];\u000a\u000a			} else {\u000a				opt.duration = jQuery.fx.speeds._default;\u000a			}\u000a		}\u000a	}\u000a\u000a	// Normalize opt.queue - true/undefined/null -> "fx"\u000a	if ( opt.queue == null || opt.queue === true ) {\u000a		opt.queue = "fx";\u000a	}\u000a\u000a	// Queueing\u000a	opt.old = opt.complete;\u000a\u000a	opt.complete = function() {\u000a		if ( isFunction( opt.old ) ) {\u000a			opt.old.call( this );\u000a		}\u000a\u000a		if ( opt.queue ) {\u000a			jQuery.dequeue( this, opt.queue );\u000a		}\u000a	};\u000a\u000a	return opt;\u000a};\u000a\u000ajQuery.fn.extend( {\u000a	fadeTo: function( speed, to, easing, callback ) {\u000a\u000a		// Show any hidden elements after setting opacity to 0\u000a		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()\u000a\u000a			// Animate to the value specified\u000a			.end().animate( { opacity: to }, speed, easing, callback );\u000a	},\u000a	animate: function( prop, speed, easing, callback ) {\u000a		var empty = jQuery.isEmptyObject( prop ),\u000a			optall = jQuery.speed( speed, easing, callback ),\u000a			doAnimation = function() {\u000a\u000a				// Operate on a copy of prop so per-property easing won't be lost\u000a				var anim = Animation( this, jQuery.extend( {}, prop ), optall );\u000a\u000a				// Empty animations, or finishing resolves immediately\u000a				if ( empty || dataPriv.get( this, "finish" ) ) {\u000a					anim.stop( true );\u000a				}\u000a			};\u000a			doAnimation.finish = doAnimation;\u000a\u000a		return empty || optall.queue === false ?\u000a			this.each( doAnimation ) :\u000a			this.queue( optall.queue, doAnimation );\u000a	},\u000a	stop: function( type, clearQueue, gotoEnd ) {\u000a		var stopQueue = function( hooks ) {\u000a			var stop = hooks.stop;\u000a			delete hooks.stop;\u000a			stop( gotoEnd );\u000a		};\u000a\u000a		if ( typeof type !== "string" ) {\u000a			gotoEnd = clearQueue;\u000a			clearQueue = type;\u000a			type = undefined;\u000a		}\u000a		if ( clearQueue && type !== false ) {\u000a			this.queue( type || "fx", [] );\u000a		}\u000a\u000a		return this.each( function() {\u000a			var dequeue = true,\u000a				index = type != null && type + "queueHooks",\u000a				timers = jQuery.timers,\u000a				data = dataPriv.get( this );\u000a\u000a			if ( index ) {\u000a				if ( data[ index ] && data[ index ].stop ) {\u000a					stopQueue( data[ index ] );\u000a				}\u000a			} else {\u000a				for ( index in data ) {\u000a					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\u000a						stopQueue( data[ index ] );\u000a					}\u000a				}\u000a			}\u000a\u000a			for ( index = timers.length; index--; ) {\u000a				if ( timers[ index ].elem === this &&\u000a					( type == null || timers[ index ].queue === type ) ) {\u000a\u000a					timers[ index ].anim.stop( gotoEnd );\u000a					dequeue = false;\u000a					timers.splice( index, 1 );\u000a				}\u000a			}\u000a\u000a			// Start the next in the queue if the last step wasn't forced.\u000a			// Timers currently will call their complete callbacks, which\u000a			// will dequeue but only if they were gotoEnd.\u000a			if ( dequeue || !gotoEnd ) {\u000a				jQuery.dequeue( this, type );\u000a			}\u000a		} );\u000a	},\u000a	finish: function( type ) {\u000a		if ( type !== false ) {\u000a			type = type || "fx";\u000a		}\u000a		return this.each( function() {\u000a			var index,\u000a				data = dataPriv.get( this ),\u000a				queue = data[ type + "queue" ],\u000a				hooks = data[ type + "queueHooks" ],\u000a				timers = jQuery.timers,\u000a				length = queue ? queue.length : 0;\u000a\u000a			// Enable finishing flag on private data\u000a			data.finish = true;\u000a\u000a			// Empty the queue first\u000a			jQuery.queue( this, type, [] );\u000a\u000a			if ( hooks && hooks.stop ) {\u000a				hooks.stop.call( this, true );\u000a			}\u000a\u000a			// Look for any active animations, and finish them\u000a			for ( index = timers.length; index--; ) {\u000a				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {\u000a					timers[ index ].anim.stop( true );\u000a					timers.splice( index, 1 );\u000a				}\u000a			}\u000a\u000a			// Look for any animations in the old queue and finish them\u000a			for ( index = 0; index < length; index++ ) {\u000a				if ( queue[ index ] && queue[ index ].finish ) {\u000a					queue[ index ].finish.call( this );\u000a				}\u000a			}\u000a\u000a			// Turn off finishing flag\u000a			delete data.finish;\u000a		} );\u000a	}\u000a} );\u000a\u000ajQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {\u000a	var cssFn = jQuery.fn[ name ];\u000a	jQuery.fn[ name ] = function( speed, easing, callback ) {\u000a		return speed == null || typeof speed === "boolean" ?\u000a			cssFn.apply( this, arguments ) :\u000a			this.animate( genFx( name, true ), speed, easing, callback );\u000a	};\u000a} );\u000a\u000a// Generate shortcuts for custom animations\u000ajQuery.each( {\u000a	slideDown: genFx( "show" ),\u000a	slideUp: genFx( "hide" ),\u000a	slideToggle: genFx( "toggle" ),\u000a	fadeIn: { opacity: "show" },\u000a	fadeOut: { opacity: "hide" },\u000a	fadeToggle: { opacity: "toggle" }\u000a}, function( name, props ) {\u000a	jQuery.fn[ name ] = function( speed, easing, callback ) {\u000a		return this.animate( props, speed, easing, callback );\u000a	};\u000a} );\u000a\u000ajQuery.timers = [];\u000ajQuery.fx.tick = function() {\u000a	var timer,\u000a		i = 0,\u000a		timers = jQuery.timers;\u000a\u000a	fxNow = Date.now();\u000a\u000a	for ( ; i < timers.length; i++ ) {\u000a		timer = timers[ i ];\u000a\u000a		// Run the timer and safely remove it when done (allowing for external removal)\u000a		if ( !timer() && timers[ i ] === timer ) {\u000a			timers.splice( i--, 1 );\u000a		}\u000a	}\u000a\u000a	if ( !timers.length ) {\u000a		jQuery.fx.stop();\u000a	}\u000a	fxNow = undefined;\u000a};\u000a\u000ajQuery.fx.timer = function( timer ) {\u000a	jQuery.timers.push( timer );\u000a	jQuery.fx.start();\u000a};\u000a\u000ajQuery.fx.interval = 13;\u000ajQuery.fx.start = function() {\u000a	if ( inProgress ) {\u000a		return;\u000a	}\u000a\u000a	inProgress = true;\u000a	schedule();\u000a};\u000a\u000ajQuery.fx.stop = function() {\u000a	inProgress = null;\u000a};\u000a\u000ajQuery.fx.speeds = {\u000a	slow: 600,\u000a	fast: 200,\u000a\u000a	// Default speed\u000a	_default: 400\u000a};\u000a\u000a\u000a// Based off of the plugin by Clint Helfers, with permission.\u000a// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\u000ajQuery.fn.delay = function( time, type ) {\u000a	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\u000a	type = type || "fx";\u000a\u000a	return this.queue( type, function( next, hooks ) {\u000a		var timeout = window.setTimeout( next, time );\u000a		hooks.stop = function() {\u000a			window.clearTimeout( timeout );\u000a		};\u000a	} );\u000a};\u000a\u000a\u000a( function() {\u000a	var input = document.createElement( "input" ),\u000a		select = document.createElement( "select" ),\u000a		opt = select.appendChild( document.createElement( "option" ) );\u000a\u000a	input.type = "checkbox";\u000a\u000a	// Support: Android <=4.3 only\u000a	// Default value for a checkbox should be "on"\u000a	support.checkOn = input.value !== "";\u000a\u000a	// Support: IE <=11 only\u000a	// Must access selectedIndex to make default options select\u000a	support.optSelected = opt.selected;\u000a\u000a	// Support: IE <=11 only\u000a	// An input loses its value after becoming a radio\u000a	input = document.createElement( "input" );\u000a	input.value = "t";\u000a	input.type = "radio";\u000a	support.radioValue = input.value === "t";\u000a} )();\u000a\u000a\u000avar boolHook,\u000a	attrHandle = jQuery.expr.attrHandle;\u000a\u000ajQuery.fn.extend( {\u000a	attr: function( name, value ) {\u000a		return access( this, jQuery.attr, name, value, arguments.length > 1 );\u000a	},\u000a\u000a	removeAttr: function( name ) {\u000a		return this.each( function() {\u000a			jQuery.removeAttr( this, name );\u000a		} );\u000a	}\u000a} );\u000a\u000ajQuery.extend( {\u000a	attr: function( elem, name, value ) {\u000a		var ret, hooks,\u000a			nType = elem.nodeType;\u000a\u000a		// Don't get/set attributes on text, comment and attribute nodes\u000a		if ( nType === 3 || nType === 8 || nType === 2 ) {\u000a			return;\u000a		}\u000a\u000a		// Fallback to prop when attributes are not supported\u000a		if ( typeof elem.getAttribute === "undefined" ) {\u000a			return jQuery.prop( elem, name, value );\u000a		}\u000a\u000a		// Attribute hooks are determined by the lowercase version\u000a		// Grab necessary hook if one is defined\u000a		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\u000a			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||\u000a				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\u000a		}\u000a\u000a		if ( value !== undefined ) {\u000a			if ( value === null ) {\u000a				jQuery.removeAttr( elem, name );\u000a				return;\u000a			}\u000a\u000a			if ( hooks && "set" in hooks &&\u000a				( ret = hooks.set( elem, value, name ) ) !== undefined ) {\u000a				return ret;\u000a			}\u000a\u000a			elem.setAttribute( name, value + "" );\u000a			return value;\u000a		}\u000a\u000a		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\u000a			return ret;\u000a		}\u000a\u000a		ret = jQuery.find.attr( elem, name );\u000a\u000a		// Non-existent attributes return null, we normalize to undefined\u000a		return ret == null ? undefined : ret;\u000a	},\u000a\u000a	attrHooks: {\u000a		type: {\u000a			set: function( elem, value ) {\u000a				if ( !support.radioValue && value === "radio" &&\u000a					nodeName( elem, "input" ) ) {\u000a					var val = elem.value;\u000a					elem.setAttribute( "type", value );\u000a					if ( val ) {\u000a						elem.value = val;\u000a					}\u000a					return value;\u000a				}\u000a			}\u000a		}\u000a	},\u000a\u000a	removeAttr: function( elem, value ) {\u000a		var name,\u000a			i = 0,\u000a\u000a			// Attribute names can contain non-HTML whitespace characters\u000a			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\u000a			attrNames = value && value.match( rnothtmlwhite );\u000a\u000a		if ( attrNames && elem.nodeType === 1 ) {\u000a			while ( ( name = attrNames[ i++ ] ) ) {\u000a				elem.removeAttribute( name );\u000a			}\u000a		}\u000a	}\u000a} );\u000a\u000a// Hooks for boolean attributes\u000aboolHook = {\u000a	set: function( elem, value, name ) {\u000a		if ( value === false ) {\u000a\u000a			// Remove boolean attributes when set to false\u000a			jQuery.removeAttr( elem, name );\u000a		} else {\u000a			elem.setAttribute( name, name );\u000a		}\u000a		return name;\u000a	}\u000a};\u000a\u000ajQuery.each( jQuery.expr.match.bool.source.match( /\u005cw+/g ), function( i, name ) {\u000a	var getter = attrHandle[ name ] || jQuery.find.attr;\u000a\u000a	attrHandle[ name ] = function( elem, name, isXML ) {\u000a		var ret, handle,\u000a			lowercaseName = name.toLowerCase();\u000a\u000a		if ( !isXML ) {\u000a\u000a			// Avoid an infinite loop by temporarily removing this function from the getter\u000a			handle = attrHandle[ lowercaseName ];\u000a			attrHandle[ lowercaseName ] = ret;\u000a			ret = getter( elem, name, isXML ) != null ?\u000a				lowercaseName :\u000a				null;\u000a			attrHandle[ lowercaseName ] = handle;\u000a		}\u000a		return ret;\u000a	};\u000a} );\u000a\u000a\u000a\u000a\u000avar rfocusable = /^(?:input|select|textarea|button)$/i,\u000a	rclickable = /^(?:a|area)$/i;\u000a\u000ajQuery.fn.extend( {\u000a	prop: function( name, value ) {\u000a		return access( this, jQuery.prop, name, value, arguments.length > 1 );\u000a	},\u000a\u000a	removeProp: function( name ) {\u000a		return this.each( function() {\u000a			delete this[ jQuery.propFix[ name ] || name ];\u000a		} );\u000a	}\u000a} );\u000a\u000ajQuery.extend( {\u000a	prop: function( elem, name, value ) {\u000a		var ret, hooks,\u000a			nType = elem.nodeType;\u000a\u000a		// Don't get/set properties on text, comment and attribute nodes\u000a		if ( nType === 3 || nType === 8 || nType === 2 ) {\u000a			return;\u000a		}\u000a\u000a		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\u000a\u000a			// Fix name and attach hooks\u000a			name = jQuery.propFix[ name ] || name;\u000a			hooks = jQuery.propHooks[ name ];\u000a		}\u000a\u000a		if ( value !== undefined ) {\u000a			if ( hooks && "set" in hooks &&\u000a				( ret = hooks.set( elem, value, name ) ) !== undefined ) {\u000a				return ret;\u000a			}\u000a\u000a			return ( elem[ name ] = value );\u000a		}\u000a\u000a		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\u000a			return ret;\u000a		}\u000a\u000a		return elem[ name ];\u000a	},\u000a\u000a	propHooks: {\u000a		tabIndex: {\u000a			get: function( elem ) {\u000a\u000a				// Support: IE <=9 - 11 only\u000a				// elem.tabIndex doesn't always return the\u000a				// correct value when it hasn't been explicitly set\u000a				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\u000a				// Use proper attribute retrieval(#12072)\u000a				var tabindex = jQuery.find.attr( elem, "tabindex" );\u000a\u000a				if ( tabindex ) {\u000a					return parseInt( tabindex, 10 );\u000a				}\u000a\u000a				if (\u000a					rfocusable.test( elem.nodeName ) ||\u000a					rclickable.test( elem.nodeName ) &&\u000a					elem.href\u000a				) {\u000a					return 0;\u000a				}\u000a\u000a				return -1;\u000a			}\u000a		}\u000a	},\u000a\u000a	propFix: {\u000a		"for": "htmlFor",\u000a		"class": "className"\u000a	}\u000a} );\u000a\u000a// Support: IE <=11 only\u000a// Accessing the selectedIndex property\u000a// forces the browser to respect setting selected\u000a// on the option\u000a// The getter ensures a default option is selected\u000a// when in an optgroup\u000a// eslint rule "no-unused-expressions" is disabled for this code\u000a// since it considers such accessions noop\u000aif ( !support.optSelected ) {\u000a	jQuery.propHooks.selected = {\u000a		get: function( elem ) {\u000a\u000a			/* eslint no-unused-expressions: "off" */\u000a\u000a			var parent = elem.parentNode;\u000a			if ( parent && parent.parentNode ) {\u000a				parent.parentNode.selectedIndex;\u000a			}\u000a			return null;\u000a		},\u000a		set: function( elem ) {\u000a\u000a			/* eslint no-unused-expressions: "off" */\u000a\u000a			var parent = elem.parentNode;\u000a			if ( parent ) {\u000a				parent.selectedIndex;\u000a\u000a				if ( parent.parentNode ) {\u000a					parent.parentNode.selectedIndex;\u000a				}\u000a			}\u000a		}\u000a	};\u000a}\u000a\u000ajQuery.each( [\u000a	"tabIndex",\u000a	"readOnly",\u000a	"maxLength",\u000a	"cellSpacing",\u000a	"cellPadding",\u000a	"rowSpan",\u000a	"colSpan",\u000a	"useMap",\u000a	"frameBorder",\u000a	"contentEditable"\u000a], function() {\u000a	jQuery.propFix[ this.toLowerCase() ] = this;\u000a} );\u000a\u000a\u000a\u000a\u000a	// Strip and collapse whitespace according to HTML spec\u000a	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\u000a	function stripAndCollapse( value ) {\u000a		var tokens = value.match( rnothtmlwhite ) || [];\u000a		return tokens.join( " " );\u000a	}\u000a\u000a\u000afunction getClass( elem ) {\u000a	return elem.getAttribute && elem.getAttribute( "class" ) || "";\u000a}\u000a\u000afunction classesToArray( value ) {\u000a	if ( Array.isArray( value ) ) {\u000a		return value;\u000a	}\u000a	if ( typeof value === "string" ) {\u000a		return value.match( rnothtmlwhite ) || [];\u000a	}\u000a	return [];\u000a}\u000a\u000ajQuery.fn.extend( {\u000a	addClass: function( value ) {\u000a		var classes, elem, cur, curValue, clazz, j, finalValue,\u000a			i = 0;\u000a\u000a		if ( isFunction( value ) ) {\u000a			return this.each( function( j ) {\u000a				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\u000a			} );\u000a		}\u000a\u000a		classes = classesToArray( value );\u000a\u000a		if ( classes.length ) {\u000a			while ( ( elem = this[ i++ ] ) ) {\u000a				curValue = getClass( elem );\u000a				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\u000a\u000a				if ( cur ) {\u000a					j = 0;\u000a					while ( ( clazz = classes[ j++ ] ) ) {\u000a						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {\u000a							cur += clazz + " ";\u000a						}\u000a					}\u000a\u000a					// Only assign if different to avoid unneeded rendering.\u000a					finalValue = stripAndCollapse( cur );\u000a					if ( curValue !== finalValue ) {\u000a						elem.setAttribute( "class", finalValue );\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	removeClass: function( value ) {\u000a		var classes, elem, cur, curValue, clazz, j, finalValue,\u000a			i = 0;\u000a\u000a		if ( isFunction( value ) ) {\u000a			return this.each( function( j ) {\u000a				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\u000a			} );\u000a		}\u000a\u000a		if ( !arguments.length ) {\u000a			return this.attr( "class", "" );\u000a		}\u000a\u000a		classes = classesToArray( value );\u000a\u000a		if ( classes.length ) {\u000a			while ( ( elem = this[ i++ ] ) ) {\u000a				curValue = getClass( elem );\u000a\u000a				// This expression is here for better compressibility (see addClass)\u000a				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\u000a\u000a				if ( cur ) {\u000a					j = 0;\u000a					while ( ( clazz = classes[ j++ ] ) ) {\u000a\u000a						// Remove *all* instances\u000a						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {\u000a							cur = cur.replace( " " + clazz + " ", " " );\u000a						}\u000a					}\u000a\u000a					// Only assign if different to avoid unneeded rendering.\u000a					finalValue = stripAndCollapse( cur );\u000a					if ( curValue !== finalValue ) {\u000a						elem.setAttribute( "class", finalValue );\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	toggleClass: function( value, stateVal ) {\u000a		var type = typeof value,\u000a			isValidValue = type === "string" || Array.isArray( value );\u000a\u000a		if ( typeof stateVal === "boolean" && isValidValue ) {\u000a			return stateVal ? this.addClass( value ) : this.removeClass( value );\u000a		}\u000a\u000a		if ( isFunction( value ) ) {\u000a			return this.each( function( i ) {\u000a				jQuery( this ).toggleClass(\u000a					value.call( this, i, getClass( this ), stateVal ),\u000a					stateVal\u000a				);\u000a			} );\u000a		}\u000a\u000a		return this.each( function() {\u000a			var className, i, self, classNames;\u000a\u000a			if ( isValidValue ) {\u000a\u000a				// Toggle individual class names\u000a				i = 0;\u000a				self = jQuery( this );\u000a				classNames = classesToArray( value );\u000a\u000a				while ( ( className = classNames[ i++ ] ) ) {\u000a\u000a					// Check each className given, space separated list\u000a					if ( self.hasClass( className ) ) {\u000a						self.removeClass( className );\u000a					} else {\u000a						self.addClass( className );\u000a					}\u000a				}\u000a\u000a			// Toggle whole class name\u000a			} else if ( value === undefined || type === "boolean" ) {\u000a				className = getClass( this );\u000a				if ( className ) {\u000a\u000a					// Store className if set\u000a					dataPriv.set( this, "__className__", className );\u000a				}\u000a\u000a				// If the element has a class name or if we're passed `false`,\u000a				// then remove the whole classname (if there was one, the above saved it).\u000a				// Otherwise bring back whatever was previously saved (if anything),\u000a				// falling back to the empty string if nothing was stored.\u000a				if ( this.setAttribute ) {\u000a					this.setAttribute( "class",\u000a						className || value === false ?\u000a						"" :\u000a						dataPriv.get( this, "__className__" ) || ""\u000a					);\u000a				}\u000a			}\u000a		} );\u000a	},\u000a\u000a	hasClass: function( selector ) {\u000a		var className, elem,\u000a			i = 0;\u000a\u000a		className = " " + selector + " ";\u000a		while ( ( elem = this[ i++ ] ) ) {\u000a			if ( elem.nodeType === 1 &&\u000a				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {\u000a					return true;\u000a			}\u000a		}\u000a\u000a		return false;\u000a	}\u000a} );\u000a\u000a\u000a\u000a\u000avar rreturn = /\u005cr/g;\u000a\u000ajQuery.fn.extend( {\u000a	val: function( value ) {\u000a		var hooks, ret, valueIsFunction,\u000a			elem = this[ 0 ];\u000a\u000a		if ( !arguments.length ) {\u000a			if ( elem ) {\u000a				hooks = jQuery.valHooks[ elem.type ] ||\u000a					jQuery.valHooks[ elem.nodeName.toLowerCase() ];\u000a\u000a				if ( hooks &&\u000a					"get" in hooks &&\u000a					( ret = hooks.get( elem, "value" ) ) !== undefined\u000a				) {\u000a					return ret;\u000a				}\u000a\u000a				ret = elem.value;\u000a\u000a				// Handle most common string cases\u000a				if ( typeof ret === "string" ) {\u000a					return ret.replace( rreturn, "" );\u000a				}\u000a\u000a				// Handle cases where value is null/undef or number\u000a				return ret == null ? "" : ret;\u000a			}\u000a\u000a			return;\u000a		}\u000a\u000a		valueIsFunction = isFunction( value );\u000a\u000a		return this.each( function( i ) {\u000a			var val;\u000a\u000a			if ( this.nodeType !== 1 ) {\u000a				return;\u000a			}\u000a\u000a			if ( valueIsFunction ) {\u000a				val = value.call( this, i, jQuery( this ).val() );\u000a			} else {\u000a				val = value;\u000a			}\u000a\u000a			// Treat null/undefined as ""; convert numbers to string\u000a			if ( val == null ) {\u000a				val = "";\u000a\u000a			} else if ( typeof val === "number" ) {\u000a				val += "";\u000a\u000a			} else if ( Array.isArray( val ) ) {\u000a				val = jQuery.map( val, function( value ) {\u000a					return value == null ? "" : value + "";\u000a				} );\u000a			}\u000a\u000a			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\u000a\u000a			// If set returns undefined, fall back to normal setting\u000a			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {\u000a				this.value = val;\u000a			}\u000a		} );\u000a	}\u000a} );\u000a\u000ajQuery.extend( {\u000a	valHooks: {\u000a		option: {\u000a			get: function( elem ) {\u000a\u000a				var val = jQuery.find.attr( elem, "value" );\u000a				return val != null ?\u000a					val :\u000a\u000a					// Support: IE <=10 - 11 only\u000a					// option.text throws exceptions (#14686, #14858)\u000a					// Strip and collapse whitespace\u000a					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\u000a					stripAndCollapse( jQuery.text( elem ) );\u000a			}\u000a		},\u000a		select: {\u000a			get: function( elem ) {\u000a				var value, option, i,\u000a					options = elem.options,\u000a					index = elem.selectedIndex,\u000a					one = elem.type === "select-one",\u000a					values = one ? null : [],\u000a					max = one ? index + 1 : options.length;\u000a\u000a				if ( index < 0 ) {\u000a					i = max;\u000a\u000a				} else {\u000a					i = one ? index : 0;\u000a				}\u000a\u000a				// Loop through all the selected options\u000a				for ( ; i < max; i++ ) {\u000a					option = options[ i ];\u000a\u000a					// Support: IE <=9 only\u000a					// IE8-9 doesn't update selected after form reset (#2551)\u000a					if ( ( option.selected || i === index ) &&\u000a\u000a							// Don't return options that are disabled or in a disabled optgroup\u000a							!option.disabled &&\u000a							( !option.parentNode.disabled ||\u000a								!nodeName( option.parentNode, "optgroup" ) ) ) {\u000a\u000a						// Get the specific value for the option\u000a						value = jQuery( option ).val();\u000a\u000a						// We don't need an array for one selects\u000a						if ( one ) {\u000a							return value;\u000a						}\u000a\u000a						// Multi-Selects return an array\u000a						values.push( value );\u000a					}\u000a				}\u000a\u000a				return values;\u000a			},\u000a\u000a			set: function( elem, value ) {\u000a				var optionSet, option,\u000a					options = elem.options,\u000a					values = jQuery.makeArray( value ),\u000a					i = options.length;\u000a\u000a				while ( i-- ) {\u000a					option = options[ i ];\u000a\u000a					/* eslint-disable no-cond-assign */\u000a\u000a					if ( option.selected =\u000a						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\u000a					) {\u000a						optionSet = true;\u000a					}\u000a\u000a					/* eslint-enable no-cond-assign */\u000a				}\u000a\u000a				// Force browsers to behave consistently when non-matching value is set\u000a				if ( !optionSet ) {\u000a					elem.selectedIndex = -1;\u000a				}\u000a				return values;\u000a			}\u000a		}\u000a	}\u000a} );\u000a\u000a// Radios and checkboxes getter/setter\u000ajQuery.each( [ "radio", "checkbox" ], function() {\u000a	jQuery.valHooks[ this ] = {\u000a		set: function( elem, value ) {\u000a			if ( Array.isArray( value ) ) {\u000a				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\u000a			}\u000a		}\u000a	};\u000a	if ( !support.checkOn ) {\u000a		jQuery.valHooks[ this ].get = function( elem ) {\u000a			return elem.getAttribute( "value" ) === null ? "on" : elem.value;\u000a		};\u000a	}\u000a} );\u000a\u000a\u000a\u000a\u000a// Return jQuery for attributes-only inclusion\u000a\u000a\u000asupport.focusin = "onfocusin" in window;\u000a\u000a\u000avar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\u000a	stopPropagationCallback = function( e ) {\u000a		e.stopPropagation();\u000a	};\u000a\u000ajQuery.extend( jQuery.event, {\u000a\u000a	trigger: function( event, data, elem, onlyHandlers ) {\u000a\u000a		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\u000a			eventPath = [ elem || document ],\u000a			type = hasOwn.call( event, "type" ) ? event.type : event,\u000a			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];\u000a\u000a		cur = lastElement = tmp = elem = elem || document;\u000a\u000a		// Don't do events on text and comment nodes\u000a		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {\u000a			return;\u000a		}\u000a\u000a		// focus/blur morphs to focusin/out; ensure we're not firing them right now\u000a		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\u000a			return;\u000a		}\u000a\u000a		if ( type.indexOf( "." ) > -1 ) {\u000a\u000a			// Namespaced trigger; create a regexp to match event type in handle()\u000a			namespaces = type.split( "." );\u000a			type = namespaces.shift();\u000a			namespaces.sort();\u000a		}\u000a		ontype = type.indexOf( ":" ) < 0 && "on" + type;\u000a\u000a		// Caller can pass in a jQuery.Event object, Object, or just an event type string\u000a		event = event[ jQuery.expando ] ?\u000a			event :\u000a			new jQuery.Event( type, typeof event === "object" && event );\u000a\u000a		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\u000a		event.isTrigger = onlyHandlers ? 2 : 3;\u000a		event.namespace = namespaces.join( "." );\u000a		event.rnamespace = event.namespace ?\u000a			new RegExp( "(^|\u005c\u005c.)" + namespaces.join( "\u005c\u005c.(?:.*\u005c\u005c.|)" ) + "(\u005c\u005c.|$)" ) :\u000a			null;\u000a\u000a		// Clean up the event in case it is being reused\u000a		event.result = undefined;\u000a		if ( !event.target ) {\u000a			event.target = elem;\u000a		}\u000a\u000a		// Clone any incoming data and prepend the event, creating the handler arg list\u000a		data = data == null ?\u000a			[ event ] :\u000a			jQuery.makeArray( data, [ event ] );\u000a\u000a		// Allow special events to draw outside the lines\u000a		special = jQuery.event.special[ type ] || {};\u000a		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\u000a			return;\u000a		}\u000a\u000a		// Determine event propagation path in advance, per W3C events spec (#9951)\u000a		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\u000a		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\u000a\u000a			bubbleType = special.delegateType || type;\u000a			if ( !rfocusMorph.test( bubbleType + type ) ) {\u000a				cur = cur.parentNode;\u000a			}\u000a			for ( ; cur; cur = cur.parentNode ) {\u000a				eventPath.push( cur );\u000a				tmp = cur;\u000a			}\u000a\u000a			// Only add window if we got to document (e.g., not plain obj or detached DOM)\u000a			if ( tmp === ( elem.ownerDocument || document ) ) {\u000a				eventPath.push( tmp.defaultView || tmp.parentWindow || window );\u000a			}\u000a		}\u000a\u000a		// Fire handlers on the event path\u000a		i = 0;\u000a		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\u000a			lastElement = cur;\u000a			event.type = i > 1 ?\u000a				bubbleType :\u000a				special.bindType || type;\u000a\u000a			// jQuery handler\u000a			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&\u000a				dataPriv.get( cur, "handle" );\u000a			if ( handle ) {\u000a				handle.apply( cur, data );\u000a			}\u000a\u000a			// Native handler\u000a			handle = ontype && cur[ ontype ];\u000a			if ( handle && handle.apply && acceptData( cur ) ) {\u000a				event.result = handle.apply( cur, data );\u000a				if ( event.result === false ) {\u000a					event.preventDefault();\u000a				}\u000a			}\u000a		}\u000a		event.type = type;\u000a\u000a		// If nobody prevented the default action, do it now\u000a		if ( !onlyHandlers && !event.isDefaultPrevented() ) {\u000a\u000a			if ( ( !special._default ||\u000a				special._default.apply( eventPath.pop(), data ) === false ) &&\u000a				acceptData( elem ) ) {\u000a\u000a				// Call a native DOM method on the target with the same name as the event.\u000a				// Don't do default actions on window, that's where global variables be (#6170)\u000a				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\u000a\u000a					// Don't re-trigger an onFOO event when we call its FOO() method\u000a					tmp = elem[ ontype ];\u000a\u000a					if ( tmp ) {\u000a						elem[ ontype ] = null;\u000a					}\u000a\u000a					// Prevent re-triggering of the same event, since we already bubbled it above\u000a					jQuery.event.triggered = type;\u000a\u000a					if ( event.isPropagationStopped() ) {\u000a						lastElement.addEventListener( type, stopPropagationCallback );\u000a					}\u000a\u000a					elem[ type ]();\u000a\u000a					if ( event.isPropagationStopped() ) {\u000a						lastElement.removeEventListener( type, stopPropagationCallback );\u000a					}\u000a\u000a					jQuery.event.triggered = undefined;\u000a\u000a					if ( tmp ) {\u000a						elem[ ontype ] = tmp;\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		return event.result;\u000a	},\u000a\u000a	// Piggyback on a donor event to simulate a different one\u000a	// Used only for `focus(in | out)` events\u000a	simulate: function( type, elem, event ) {\u000a		var e = jQuery.extend(\u000a			new jQuery.Event(),\u000a			event,\u000a			{\u000a				type: type,\u000a				isSimulated: true\u000a			}\u000a		);\u000a\u000a		jQuery.event.trigger( e, null, elem );\u000a	}\u000a\u000a} );\u000a\u000ajQuery.fn.extend( {\u000a\u000a	trigger: function( type, data ) {\u000a		return this.each( function() {\u000a			jQuery.event.trigger( type, data, this );\u000a		} );\u000a	},\u000a	triggerHandler: function( type, data ) {\u000a		var elem = this[ 0 ];\u000a		if ( elem ) {\u000a			return jQuery.event.trigger( type, data, elem, true );\u000a		}\u000a	}\u000a} );\u000a\u000a\u000a// Support: Firefox <=44\u000a// Firefox doesn't have focus(in | out) events\u000a// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\u000a//\u000a// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\u000a// focus(in | out) events fire after focus & blur events,\u000a// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\u000a// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\u000aif ( !support.focusin ) {\u000a	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {\u000a\u000a		// Attach a single capturing handler on the document while someone wants focusin/focusout\u000a		var handler = function( event ) {\u000a			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\u000a		};\u000a\u000a		jQuery.event.special[ fix ] = {\u000a			setup: function() {\u000a				var doc = this.ownerDocument || this,\u000a					attaches = dataPriv.access( doc, fix );\u000a\u000a				if ( !attaches ) {\u000a					doc.addEventListener( orig, handler, true );\u000a				}\u000a				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\u000a			},\u000a			teardown: function() {\u000a				var doc = this.ownerDocument || this,\u000a					attaches = dataPriv.access( doc, fix ) - 1;\u000a\u000a				if ( !attaches ) {\u000a					doc.removeEventListener( orig, handler, true );\u000a					dataPriv.remove( doc, fix );\u000a\u000a				} else {\u000a					dataPriv.access( doc, fix, attaches );\u000a				}\u000a			}\u000a		};\u000a	} );\u000a}\u000avar location = window.location;\u000a\u000avar nonce = Date.now();\u000a\u000avar rquery = ( /\u005c?/ );\u000a\u000a\u000a\u000a// Cross-browser xml parsing\u000ajQuery.parseXML = function( data ) {\u000a	var xml;\u000a	if ( !data || typeof data !== "string" ) {\u000a		return null;\u000a	}\u000a\u000a	// Support: IE 9 - 11 only\u000a	// IE throws on parseFromString with invalid input.\u000a	try {\u000a		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );\u000a	} catch ( e ) {\u000a		xml = undefined;\u000a	}\u000a\u000a	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {\u000a		jQuery.error( "Invalid XML: " + data );\u000a	}\u000a	return xml;\u000a};\u000a\u000a\u000avar\u000a	rbracket = /\u005c[\u005c]$/,\u000a	rCRLF = /\u005cr?\u005cn/g,\u000a	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\u000a	rsubmittable = /^(?:input|select|textarea|keygen)/i;\u000a\u000afunction buildParams( prefix, obj, traditional, add ) {\u000a	var name;\u000a\u000a	if ( Array.isArray( obj ) ) {\u000a\u000a		// Serialize array item.\u000a		jQuery.each( obj, function( i, v ) {\u000a			if ( traditional || rbracket.test( prefix ) ) {\u000a\u000a				// Treat each array item as a scalar.\u000a				add( prefix, v );\u000a\u000a			} else {\u000a\u000a				// Item is non-scalar (array or object), encode its numeric index.\u000a				buildParams(\u000a					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",\u000a					v,\u000a					traditional,\u000a					add\u000a				);\u000a			}\u000a		} );\u000a\u000a	} else if ( !traditional && toType( obj ) === "object" ) {\u000a\u000a		// Serialize object item.\u000a		for ( name in obj ) {\u000a			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\u000a		}\u000a\u000a	} else {\u000a\u000a		// Serialize scalar item.\u000a		add( prefix, obj );\u000a	}\u000a}\u000a\u000a// Serialize an array of form elements or a set of\u000a// key/values into a query string\u000ajQuery.param = function( a, traditional ) {\u000a	var prefix,\u000a		s = [],\u000a		add = function( key, valueOrFunction ) {\u000a\u000a			// If value is a function, invoke it and use its return value\u000a			var value = isFunction( valueOrFunction ) ?\u000a				valueOrFunction() :\u000a				valueOrFunction;\u000a\u000a			s[ s.length ] = encodeURIComponent( key ) + "=" +\u000a				encodeURIComponent( value == null ? "" : value );\u000a		};\u000a\u000a	// If an array was passed in, assume that it is an array of form elements.\u000a	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\u000a\u000a		// Serialize the form elements\u000a		jQuery.each( a, function() {\u000a			add( this.name, this.value );\u000a		} );\u000a\u000a	} else {\u000a\u000a		// If traditional, encode the "old" way (the way 1.3.2 or older\u000a		// did it), otherwise encode params recursively.\u000a		for ( prefix in a ) {\u000a			buildParams( prefix, a[ prefix ], traditional, add );\u000a		}\u000a	}\u000a\u000a	// Return the resulting serialization\u000a	return s.join( "&" );\u000a};\u000a\u000ajQuery.fn.extend( {\u000a	serialize: function() {\u000a		return jQuery.param( this.serializeArray() );\u000a	},\u000a	serializeArray: function() {\u000a		return this.map( function() {\u000a\u000a			// Can add propHook for "elements" to filter or add form elements\u000a			var elements = jQuery.prop( this, "elements" );\u000a			return elements ? jQuery.makeArray( elements ) : this;\u000a		} )\u000a		.filter( function() {\u000a			var type = this.type;\u000a\u000a			// Use .is( ":disabled" ) so that fieldset[disabled] works\u000a			return this.name && !jQuery( this ).is( ":disabled" ) &&\u000a				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\u000a				( this.checked || !rcheckableType.test( type ) );\u000a		} )\u000a		.map( function( i, elem ) {\u000a			var val = jQuery( this ).val();\u000a\u000a			if ( val == null ) {\u000a				return null;\u000a			}\u000a\u000a			if ( Array.isArray( val ) ) {\u000a				return jQuery.map( val, function( val ) {\u000a					return { name: elem.name, value: val.replace( rCRLF, "\u005cr\u005cn" ) };\u000a				} );\u000a			}\u000a\u000a			return { name: elem.name, value: val.replace( rCRLF, "\u005cr\u005cn" ) };\u000a		} ).get();\u000a	}\u000a} );\u000a\u000a\u000avar\u000a	r20 = /%20/g,\u000a	rhash = /#.*$/,\u000a	rantiCache = /([?&])_=[^&]*/,\u000a	rheaders = /^(.*?):[ \u005ct]*([^\u005cr\u005cn]*)$/mg,\u000a\u000a	// #7653, #8125, #8152: local protocol detection\u000a	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\u000a	rnoContent = /^(?:GET|HEAD)$/,\u000a	rprotocol = /^\u005c/\u005c//,\u000a\u000a	/* Prefilters\u000a	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\u000a	 * 2) These are called:\u000a	 *    - BEFORE asking for a transport\u000a	 *    - AFTER param serialization (s.data is a string if s.processData is true)\u000a	 * 3) key is the dataType\u000a	 * 4) the catchall symbol "*" can be used\u000a	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed\u000a	 */\u000a	prefilters = {},\u000a\u000a	/* Transports bindings\u000a	 * 1) key is the dataType\u000a	 * 2) the catchall symbol "*" can be used\u000a	 * 3) selection will start with transport dataType and THEN go to "*" if needed\u000a	 */\u000a	transports = {},\u000a\u000a	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\u000a	allTypes = "*/".concat( "*" ),\u000a\u000a	// Anchor tag for parsing the document origin\u000a	originAnchor = document.createElement( "a" );\u000a	originAnchor.href = location.href;\u000a\u000a// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\u000afunction addToPrefiltersOrTransports( structure ) {\u000a\u000a	// dataTypeExpression is optional and defaults to "*"\u000a	return function( dataTypeExpression, func ) {\u000a\u000a		if ( typeof dataTypeExpression !== "string" ) {\u000a			func = dataTypeExpression;\u000a			dataTypeExpression = "*";\u000a		}\u000a\u000a		var dataType,\u000a			i = 0,\u000a			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\u000a\u000a		if ( isFunction( func ) ) {\u000a\u000a			// For each dataType in the dataTypeExpression\u000a			while ( ( dataType = dataTypes[ i++ ] ) ) {\u000a\u000a				// Prepend if requested\u000a				if ( dataType[ 0 ] === "+" ) {\u000a					dataType = dataType.slice( 1 ) || "*";\u000a					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\u000a\u000a				// Otherwise append\u000a				} else {\u000a					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\u000a				}\u000a			}\u000a		}\u000a	};\u000a}\u000a\u000a// Base inspection function for prefilters and transports\u000afunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\u000a\u000a	var inspected = {},\u000a		seekingTransport = ( structure === transports );\u000a\u000a	function inspect( dataType ) {\u000a		var selected;\u000a		inspected[ dataType ] = true;\u000a		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\u000a			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\u000a			if ( typeof dataTypeOrTransport === "string" &&\u000a				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\u000a\u000a				options.dataTypes.unshift( dataTypeOrTransport );\u000a				inspect( dataTypeOrTransport );\u000a				return false;\u000a			} else if ( seekingTransport ) {\u000a				return !( selected = dataTypeOrTransport );\u000a			}\u000a		} );\u000a		return selected;\u000a	}\u000a\u000a	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\u000a}\u000a\u000a// A special extend for ajax options\u000a// that takes "flat" options (not to be deep extended)\u000a// Fixes #9887\u000afunction ajaxExtend( target, src ) {\u000a	var key, deep,\u000a		flatOptions = jQuery.ajaxSettings.flatOptions || {};\u000a\u000a	for ( key in src ) {\u000a		if ( src[ key ] !== undefined ) {\u000a			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\u000a		}\u000a	}\u000a	if ( deep ) {\u000a		jQuery.extend( true, target, deep );\u000a	}\u000a\u000a	return target;\u000a}\u000a\u000a/* Handles responses to an ajax request:\u000a * - finds the right dataType (mediates between content-type and expected dataType)\u000a * - returns the corresponding response\u000a */\u000afunction ajaxHandleResponses( s, jqXHR, responses ) {\u000a\u000a	var ct, type, finalDataType, firstDataType,\u000a		contents = s.contents,\u000a		dataTypes = s.dataTypes;\u000a\u000a	// Remove auto dataType and get content-type in the process\u000a	while ( dataTypes[ 0 ] === "*" ) {\u000a		dataTypes.shift();\u000a		if ( ct === undefined ) {\u000a			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );\u000a		}\u000a	}\u000a\u000a	// Check if we're dealing with a known content-type\u000a	if ( ct ) {\u000a		for ( type in contents ) {\u000a			if ( contents[ type ] && contents[ type ].test( ct ) ) {\u000a				dataTypes.unshift( type );\u000a				break;\u000a			}\u000a		}\u000a	}\u000a\u000a	// Check to see if we have a response for the expected dataType\u000a	if ( dataTypes[ 0 ] in responses ) {\u000a		finalDataType = dataTypes[ 0 ];\u000a	} else {\u000a\u000a		// Try convertible dataTypes\u000a		for ( type in responses ) {\u000a			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {\u000a				finalDataType = type;\u000a				break;\u000a			}\u000a			if ( !firstDataType ) {\u000a				firstDataType = type;\u000a			}\u000a		}\u000a\u000a		// Or just use first one\u000a		finalDataType = finalDataType || firstDataType;\u000a	}\u000a\u000a	// If we found a dataType\u000a	// We add the dataType to the list if needed\u000a	// and return the corresponding response\u000a	if ( finalDataType ) {\u000a		if ( finalDataType !== dataTypes[ 0 ] ) {\u000a			dataTypes.unshift( finalDataType );\u000a		}\u000a		return responses[ finalDataType ];\u000a	}\u000a}\u000a\u000a/* Chain conversions given the request and the original response\u000a * Also sets the responseXXX fields on the jqXHR instance\u000a */\u000afunction ajaxConvert( s, response, jqXHR, isSuccess ) {\u000a	var conv2, current, conv, tmp, prev,\u000a		converters = {},\u000a\u000a		// Work with a copy of dataTypes in case we need to modify it for conversion\u000a		dataTypes = s.dataTypes.slice();\u000a\u000a	// Create converters map with lowercased keys\u000a	if ( dataTypes[ 1 ] ) {\u000a		for ( conv in s.converters ) {\u000a			converters[ conv.toLowerCase() ] = s.converters[ conv ];\u000a		}\u000a	}\u000a\u000a	current = dataTypes.shift();\u000a\u000a	// Convert to each sequential dataType\u000a	while ( current ) {\u000a\u000a		if ( s.responseFields[ current ] ) {\u000a			jqXHR[ s.responseFields[ current ] ] = response;\u000a		}\u000a\u000a		// Apply the dataFilter if provided\u000a		if ( !prev && isSuccess && s.dataFilter ) {\u000a			response = s.dataFilter( response, s.dataType );\u000a		}\u000a\u000a		prev = current;\u000a		current = dataTypes.shift();\u000a\u000a		if ( current ) {\u000a\u000a			// There's only work to do if current dataType is non-auto\u000a			if ( current === "*" ) {\u000a\u000a				current = prev;\u000a\u000a			// Convert response if prev dataType is non-auto and differs from current\u000a			} else if ( prev !== "*" && prev !== current ) {\u000a\u000a				// Seek a direct converter\u000a				conv = converters[ prev + " " + current ] || converters[ "* " + current ];\u000a\u000a				// If none found, seek a pair\u000a				if ( !conv ) {\u000a					for ( conv2 in converters ) {\u000a\u000a						// If conv2 outputs current\u000a						tmp = conv2.split( " " );\u000a						if ( tmp[ 1 ] === current ) {\u000a\u000a							// If prev can be converted to accepted input\u000a							conv = converters[ prev + " " + tmp[ 0 ] ] ||\u000a								converters[ "* " + tmp[ 0 ] ];\u000a							if ( conv ) {\u000a\u000a								// Condense equivalence converters\u000a								if ( conv === true ) {\u000a									conv = converters[ conv2 ];\u000a\u000a								// Otherwise, insert the intermediate dataType\u000a								} else if ( converters[ conv2 ] !== true ) {\u000a									current = tmp[ 0 ];\u000a									dataTypes.unshift( tmp[ 1 ] );\u000a								}\u000a								break;\u000a							}\u000a						}\u000a					}\u000a				}\u000a\u000a				// Apply converter (if not an equivalence)\u000a				if ( conv !== true ) {\u000a\u000a					// Unless errors are allowed to bubble, catch and return them\u000a					if ( conv && s.throws ) {\u000a						response = conv( response );\u000a					} else {\u000a						try {\u000a							response = conv( response );\u000a						} catch ( e ) {\u000a							return {\u000a								state: "parsererror",\u000a								error: conv ? e : "No conversion from " + prev + " to " + current\u000a							};\u000a						}\u000a					}\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	return { state: "success", data: response };\u000a}\u000a\u000ajQuery.extend( {\u000a\u000a	// Counter for holding the number of active queries\u000a	active: 0,\u000a\u000a	// Last-Modified header cache for next request\u000a	lastModified: {},\u000a	etag: {},\u000a\u000a	ajaxSettings: {\u000a		url: location.href,\u000a		type: "GET",\u000a		isLocal: rlocalProtocol.test( location.protocol ),\u000a		global: true,\u000a		processData: true,\u000a		async: true,\u000a		contentType: "application/x-www-form-urlencoded; charset=UTF-8",\u000a\u000a		/*\u000a		timeout: 0,\u000a		data: null,\u000a		dataType: null,\u000a		username: null,\u000a		password: null,\u000a		cache: null,\u000a		throws: false,\u000a		traditional: false,\u000a		headers: {},\u000a		*/\u000a\u000a		accepts: {\u000a			"*": allTypes,\u000a			text: "text/plain",\u000a			html: "text/html",\u000a			xml: "application/xml, text/xml",\u000a			json: "application/json, text/javascript"\u000a		},\u000a\u000a		contents: {\u000a			xml: /\u005cbxml\u005cb/,\u000a			html: /\u005cbhtml/,\u000a			json: /\u005cbjson\u005cb/\u000a		},\u000a\u000a		responseFields: {\u000a			xml: "responseXML",\u000a			text: "responseText",\u000a			json: "responseJSON"\u000a		},\u000a\u000a		// Data converters\u000a		// Keys separate source (or catchall "*") and destination types with a single space\u000a		converters: {\u000a\u000a			// Convert anything to text\u000a			"* text": String,\u000a\u000a			// Text to html (true = no transformation)\u000a			"text html": true,\u000a\u000a			// Evaluate text as a json expression\u000a			"text json": JSON.parse,\u000a\u000a			// Parse text as xml\u000a			"text xml": jQuery.parseXML\u000a		},\u000a\u000a		// For options that shouldn't be deep extended:\u000a		// you can add your own custom options here if\u000a		// and when you create one that shouldn't be\u000a		// deep extended (see ajaxExtend)\u000a		flatOptions: {\u000a			url: true,\u000a			context: true\u000a		}\u000a	},\u000a\u000a	// Creates a full fledged settings object into target\u000a	// with both ajaxSettings and settings fields.\u000a	// If target is omitted, writes into ajaxSettings.\u000a	ajaxSetup: function( target, settings ) {\u000a		return settings ?\u000a\u000a			// Building a settings object\u000a			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\u000a\u000a			// Extending ajaxSettings\u000a			ajaxExtend( jQuery.ajaxSettings, target );\u000a	},\u000a\u000a	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\u000a	ajaxTransport: addToPrefiltersOrTransports( transports ),\u000a\u000a	// Main method\u000a	ajax: function( url, options ) {\u000a\u000a		// If url is an object, simulate pre-1.5 signature\u000a		if ( typeof url === "object" ) {\u000a			options = url;\u000a			url = undefined;\u000a		}\u000a\u000a		// Force options to be an object\u000a		options = options || {};\u000a\u000a		var transport,\u000a\u000a			// URL without anti-cache param\u000a			cacheURL,\u000a\u000a			// Response headers\u000a			responseHeadersString,\u000a			responseHeaders,\u000a\u000a			// timeout handle\u000a			timeoutTimer,\u000a\u000a			// Url cleanup var\u000a			urlAnchor,\u000a\u000a			// Request state (becomes false upon send and true upon completion)\u000a			completed,\u000a\u000a			// To know if global events are to be dispatched\u000a			fireGlobals,\u000a\u000a			// Loop variable\u000a			i,\u000a\u000a			// uncached part of the url\u000a			uncached,\u000a\u000a			// Create the final options object\u000a			s = jQuery.ajaxSetup( {}, options ),\u000a\u000a			// Callbacks context\u000a			callbackContext = s.context || s,\u000a\u000a			// Context for global events is callbackContext if it is a DOM node or jQuery collection\u000a			globalEventContext = s.context &&\u000a				( callbackContext.nodeType || callbackContext.jquery ) ?\u000a					jQuery( callbackContext ) :\u000a					jQuery.event,\u000a\u000a			// Deferreds\u000a			deferred = jQuery.Deferred(),\u000a			completeDeferred = jQuery.Callbacks( "once memory" ),\u000a\u000a			// Status-dependent callbacks\u000a			statusCode = s.statusCode || {},\u000a\u000a			// Headers (they are sent all at once)\u000a			requestHeaders = {},\u000a			requestHeadersNames = {},\u000a\u000a			// Default abort message\u000a			strAbort = "canceled",\u000a\u000a			// Fake xhr\u000a			jqXHR = {\u000a				readyState: 0,\u000a\u000a				// Builds headers hashtable if needed\u000a				getResponseHeader: function( key ) {\u000a					var match;\u000a					if ( completed ) {\u000a						if ( !responseHeaders ) {\u000a							responseHeaders = {};\u000a							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {\u000a								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\u000a							}\u000a						}\u000a						match = responseHeaders[ key.toLowerCase() ];\u000a					}\u000a					return match == null ? null : match;\u000a				},\u000a\u000a				// Raw string\u000a				getAllResponseHeaders: function() {\u000a					return completed ? responseHeadersString : null;\u000a				},\u000a\u000a				// Caches the header\u000a				setRequestHeader: function( name, value ) {\u000a					if ( completed == null ) {\u000a						name = requestHeadersNames[ name.toLowerCase() ] =\u000a							requestHeadersNames[ name.toLowerCase() ] || name;\u000a						requestHeaders[ name ] = value;\u000a					}\u000a					return this;\u000a				},\u000a\u000a				// Overrides response content-type header\u000a				overrideMimeType: function( type ) {\u000a					if ( completed == null ) {\u000a						s.mimeType = type;\u000a					}\u000a					return this;\u000a				},\u000a\u000a				// Status-dependent callbacks\u000a				statusCode: function( map ) {\u000a					var code;\u000a					if ( map ) {\u000a						if ( completed ) {\u000a\u000a							// Execute the appropriate callbacks\u000a							jqXHR.always( map[ jqXHR.status ] );\u000a						} else {\u000a\u000a							// Lazy-add the new callbacks in a way that preserves old ones\u000a							for ( code in map ) {\u000a								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];\u000a							}\u000a						}\u000a					}\u000a					return this;\u000a				},\u000a\u000a				// Cancel the request\u000a				abort: function( statusText ) {\u000a					var finalText = statusText || strAbort;\u000a					if ( transport ) {\u000a						transport.abort( finalText );\u000a					}\u000a					done( 0, finalText );\u000a					return this;\u000a				}\u000a			};\u000a\u000a		// Attach deferreds\u000a		deferred.promise( jqXHR );\u000a\u000a		// Add protocol if not provided (prefilters might expect it)\u000a		// Handle falsy url in the settings object (#10093: consistency with old signature)\u000a		// We also use the url parameter if available\u000a		s.url = ( ( url || s.url || location.href ) + "" )\u000a			.replace( rprotocol, location.protocol + "//" );\u000a\u000a		// Alias method option to type as per ticket #12004\u000a		s.type = options.method || options.type || s.method || s.type;\u000a\u000a		// Extract dataTypes list\u000a		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];\u000a\u000a		// A cross-domain request is in order when the origin doesn't match the current origin.\u000a		if ( s.crossDomain == null ) {\u000a			urlAnchor = document.createElement( "a" );\u000a\u000a			// Support: IE <=8 - 11, Edge 12 - 15\u000a			// IE throws exception on accessing the href property if url is malformed,\u000a			// e.g. http://example.com:80x/\u000a			try {\u000a				urlAnchor.href = s.url;\u000a\u000a				// Support: IE <=8 - 11 only\u000a				// Anchor's host property isn't correctly set when s.url is relative\u000a				urlAnchor.href = urlAnchor.href;\u000a				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==\u000a					urlAnchor.protocol + "//" + urlAnchor.host;\u000a			} catch ( e ) {\u000a\u000a				// If there is an error parsing the URL, assume it is crossDomain,\u000a				// it can be rejected by the transport if it is invalid\u000a				s.crossDomain = true;\u000a			}\u000a		}\u000a\u000a		// Convert data if not already a string\u000a		if ( s.data && s.processData && typeof s.data !== "string" ) {\u000a			s.data = jQuery.param( s.data, s.traditional );\u000a		}\u000a\u000a		// Apply prefilters\u000a		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\u000a\u000a		// If request was aborted inside a prefilter, stop there\u000a		if ( completed ) {\u000a			return jqXHR;\u000a		}\u000a\u000a		// We can fire global events as of now if asked to\u000a		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\u000a		fireGlobals = jQuery.event && s.global;\u000a\u000a		// Watch for a new set of requests\u000a		if ( fireGlobals && jQuery.active++ === 0 ) {\u000a			jQuery.event.trigger( "ajaxStart" );\u000a		}\u000a\u000a		// Uppercase the type\u000a		s.type = s.type.toUpperCase();\u000a\u000a		// Determine if request has content\u000a		s.hasContent = !rnoContent.test( s.type );\u000a\u000a		// Save the URL in case we're toying with the If-Modified-Since\u000a		// and/or If-None-Match header later on\u000a		// Remove hash to simplify url manipulation\u000a		cacheURL = s.url.replace( rhash, "" );\u000a\u000a		// More options handling for requests with no content\u000a		if ( !s.hasContent ) {\u000a\u000a			// Remember the hash so we can put it back\u000a			uncached = s.url.slice( cacheURL.length );\u000a\u000a			// If data is available and should be processed, append data to url\u000a			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {\u000a				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;\u000a\u000a				// #9682: remove data so that it's not used in an eventual retry\u000a				delete s.data;\u000a			}\u000a\u000a			// Add or update anti-cache param if needed\u000a			if ( s.cache === false ) {\u000a				cacheURL = cacheURL.replace( rantiCache, "$1" );\u000a				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;\u000a			}\u000a\u000a			// Put hash and anti-cache on the URL that will be requested (gh-1732)\u000a			s.url = cacheURL + uncached;\u000a\u000a		// Change '%20' to '+' if this is encoded form body content (gh-2658)\u000a		} else if ( s.data && s.processData &&\u000a			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {\u000a			s.data = s.data.replace( r20, "+" );\u000a		}\u000a\u000a		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\u000a		if ( s.ifModified ) {\u000a			if ( jQuery.lastModified[ cacheURL ] ) {\u000a				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\u000a			}\u000a			if ( jQuery.etag[ cacheURL ] ) {\u000a				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\u000a			}\u000a		}\u000a\u000a		// Set the correct header, if data is being sent\u000a		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\u000a			jqXHR.setRequestHeader( "Content-Type", s.contentType );\u000a		}\u000a\u000a		// Set the Accepts header for the server, depending on the dataType\u000a		jqXHR.setRequestHeader(\u000a			"Accept",\u000a			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\u000a				s.accepts[ s.dataTypes[ 0 ] ] +\u000a					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\u000a				s.accepts[ "*" ]\u000a		);\u000a\u000a		// Check for headers option\u000a		for ( i in s.headers ) {\u000a			jqXHR.setRequestHeader( i, s.headers[ i ] );\u000a		}\u000a\u000a		// Allow custom headers/mimetypes and early abort\u000a		if ( s.beforeSend &&\u000a			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\u000a\u000a			// Abort if not done already and return\u000a			return jqXHR.abort();\u000a		}\u000a\u000a		// Aborting is no longer a cancellation\u000a		strAbort = "abort";\u000a\u000a		// Install callbacks on deferreds\u000a		completeDeferred.add( s.complete );\u000a		jqXHR.done( s.success );\u000a		jqXHR.fail( s.error );\u000a\u000a		// Get transport\u000a		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\u000a\u000a		// If no transport, we auto-abort\u000a		if ( !transport ) {\u000a			done( -1, "No Transport" );\u000a		} else {\u000a			jqXHR.readyState = 1;\u000a\u000a			// Send global event\u000a			if ( fireGlobals ) {\u000a				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\u000a			}\u000a\u000a			// If request was aborted inside ajaxSend, stop there\u000a			if ( completed ) {\u000a				return jqXHR;\u000a			}\u000a\u000a			// Timeout\u000a			if ( s.async && s.timeout > 0 ) {\u000a				timeoutTimer = window.setTimeout( function() {\u000a					jqXHR.abort( "timeout" );\u000a				}, s.timeout );\u000a			}\u000a\u000a			try {\u000a				completed = false;\u000a				transport.send( requestHeaders, done );\u000a			} catch ( e ) {\u000a\u000a				// Rethrow post-completion exceptions\u000a				if ( completed ) {\u000a					throw e;\u000a				}\u000a\u000a				// Propagate others as results\u000a				done( -1, e );\u000a			}\u000a		}\u000a\u000a		// Callback for when everything is done\u000a		function done( status, nativeStatusText, responses, headers ) {\u000a			var isSuccess, success, error, response, modified,\u000a				statusText = nativeStatusText;\u000a\u000a			// Ignore repeat invocations\u000a			if ( completed ) {\u000a				return;\u000a			}\u000a\u000a			completed = true;\u000a\u000a			// Clear timeout if it exists\u000a			if ( timeoutTimer ) {\u000a				window.clearTimeout( timeoutTimer );\u000a			}\u000a\u000a			// Dereference transport for early garbage collection\u000a			// (no matter how long the jqXHR object will be used)\u000a			transport = undefined;\u000a\u000a			// Cache response headers\u000a			responseHeadersString = headers || "";\u000a\u000a			// Set readyState\u000a			jqXHR.readyState = status > 0 ? 4 : 0;\u000a\u000a			// Determine if successful\u000a			isSuccess = status >= 200 && status < 300 || status === 304;\u000a\u000a			// Get response data\u000a			if ( responses ) {\u000a				response = ajaxHandleResponses( s, jqXHR, responses );\u000a			}\u000a\u000a			// Convert no matter what (that way responseXXX fields are always set)\u000a			response = ajaxConvert( s, response, jqXHR, isSuccess );\u000a\u000a			// If successful, handle type chaining\u000a			if ( isSuccess ) {\u000a\u000a				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\u000a				if ( s.ifModified ) {\u000a					modified = jqXHR.getResponseHeader( "Last-Modified" );\u000a					if ( modified ) {\u000a						jQuery.lastModified[ cacheURL ] = modified;\u000a					}\u000a					modified = jqXHR.getResponseHeader( "etag" );\u000a					if ( modified ) {\u000a						jQuery.etag[ cacheURL ] = modified;\u000a					}\u000a				}\u000a\u000a				// if no content\u000a				if ( status === 204 || s.type === "HEAD" ) {\u000a					statusText = "nocontent";\u000a\u000a				// if not modified\u000a				} else if ( status === 304 ) {\u000a					statusText = "notmodified";\u000a\u000a				// If we have data, let's convert it\u000a				} else {\u000a					statusText = response.state;\u000a					success = response.data;\u000a					error = response.error;\u000a					isSuccess = !error;\u000a				}\u000a			} else {\u000a\u000a				// Extract error from statusText and normalize for non-aborts\u000a				error = statusText;\u000a				if ( status || !statusText ) {\u000a					statusText = "error";\u000a					if ( status < 0 ) {\u000a						status = 0;\u000a					}\u000a				}\u000a			}\u000a\u000a			// Set data for the fake xhr object\u000a			jqXHR.status = status;\u000a			jqXHR.statusText = ( nativeStatusText || statusText ) + "";\u000a\u000a			// Success/Error\u000a			if ( isSuccess ) {\u000a				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\u000a			} else {\u000a				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\u000a			}\u000a\u000a			// Status-dependent callbacks\u000a			jqXHR.statusCode( statusCode );\u000a			statusCode = undefined;\u000a\u000a			if ( fireGlobals ) {\u000a				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\u000a					[ jqXHR, s, isSuccess ? success : error ] );\u000a			}\u000a\u000a			// Complete\u000a			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\u000a\u000a			if ( fireGlobals ) {\u000a				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\u000a\u000a				// Handle the global AJAX counter\u000a				if ( !( --jQuery.active ) ) {\u000a					jQuery.event.trigger( "ajaxStop" );\u000a				}\u000a			}\u000a		}\u000a\u000a		return jqXHR;\u000a	},\u000a\u000a	getJSON: function( url, data, callback ) {\u000a		return jQuery.get( url, data, callback, "json" );\u000a	},\u000a\u000a	getScript: function( url, callback ) {\u000a		return jQuery.get( url, undefined, callback, "script" );\u000a	}\u000a} );\u000a\u000ajQuery.each( [ "get", "post" ], function( i, method ) {\u000a	jQuery[ method ] = function( url, data, callback, type ) {\u000a\u000a		// Shift arguments if data argument was omitted\u000a		if ( isFunction( data ) ) {\u000a			type = type || callback;\u000a			callback = data;\u000a			data = undefined;\u000a		}\u000a\u000a		// The url can be an options object (which then must have .url)\u000a		return jQuery.ajax( jQuery.extend( {\u000a			url: url,\u000a			type: method,\u000a			dataType: type,\u000a			data: data,\u000a			success: callback\u000a		}, jQuery.isPlainObject( url ) && url ) );\u000a	};\u000a} );\u000a\u000a\u000ajQuery._evalUrl = function( url ) {\u000a	return jQuery.ajax( {\u000a		url: url,\u000a\u000a		// Make this explicit, since user can override this through ajaxSetup (#11264)\u000a		type: "GET",\u000a		dataType: "script",\u000a		cache: true,\u000a		async: false,\u000a		global: false,\u000a		"throws": true\u000a	} );\u000a};\u000a\u000a\u000ajQuery.fn.extend( {\u000a	wrapAll: function( html ) {\u000a		var wrap;\u000a\u000a		if ( this[ 0 ] ) {\u000a			if ( isFunction( html ) ) {\u000a				html = html.call( this[ 0 ] );\u000a			}\u000a\u000a			// The elements to wrap the target around\u000a			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\u000a\u000a			if ( this[ 0 ].parentNode ) {\u000a				wrap.insertBefore( this[ 0 ] );\u000a			}\u000a\u000a			wrap.map( function() {\u000a				var elem = this;\u000a\u000a				while ( elem.firstElementChild ) {\u000a					elem = elem.firstElementChild;\u000a				}\u000a\u000a				return elem;\u000a			} ).append( this );\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	wrapInner: function( html ) {\u000a		if ( isFunction( html ) ) {\u000a			return this.each( function( i ) {\u000a				jQuery( this ).wrapInner( html.call( this, i ) );\u000a			} );\u000a		}\u000a\u000a		return this.each( function() {\u000a			var self = jQuery( this ),\u000a				contents = self.contents();\u000a\u000a			if ( contents.length ) {\u000a				contents.wrapAll( html );\u000a\u000a			} else {\u000a				self.append( html );\u000a			}\u000a		} );\u000a	},\u000a\u000a	wrap: function( html ) {\u000a		var htmlIsFunction = isFunction( html );\u000a\u000a		return this.each( function( i ) {\u000a			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\u000a		} );\u000a	},\u000a\u000a	unwrap: function( selector ) {\u000a		this.parent( selector ).not( "body" ).each( function() {\u000a			jQuery( this ).replaceWith( this.childNodes );\u000a		} );\u000a		return this;\u000a	}\u000a} );\u000a\u000a\u000ajQuery.expr.pseudos.hidden = function( elem ) {\u000a	return !jQuery.expr.pseudos.visible( elem );\u000a};\u000ajQuery.expr.pseudos.visible = function( elem ) {\u000a	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\u000a};\u000a\u000a\u000a\u000a\u000ajQuery.ajaxSettings.xhr = function() {\u000a	try {\u000a		return new window.XMLHttpRequest();\u000a	} catch ( e ) {}\u000a};\u000a\u000avar xhrSuccessStatus = {\u000a\u000a		// File protocol always yields status code 0, assume 200\u000a		0: 200,\u000a\u000a		// Support: IE <=9 only\u000a		// #1450: sometimes IE returns 1223 when it should be 204\u000a		1223: 204\u000a	},\u000a	xhrSupported = jQuery.ajaxSettings.xhr();\u000a\u000asupport.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\u000asupport.ajax = xhrSupported = !!xhrSupported;\u000a\u000ajQuery.ajaxTransport( function( options ) {\u000a	var callback, errorCallback;\u000a\u000a	// Cross domain only allowed if supported through XMLHttpRequest\u000a	if ( support.cors || xhrSupported && !options.crossDomain ) {\u000a		return {\u000a			send: function( headers, complete ) {\u000a				var i,\u000a					xhr = options.xhr();\u000a\u000a				xhr.open(\u000a					options.type,\u000a					options.url,\u000a					options.async,\u000a					options.username,\u000a					options.password\u000a				);\u000a\u000a				// Apply custom fields if provided\u000a				if ( options.xhrFields ) {\u000a					for ( i in options.xhrFields ) {\u000a						xhr[ i ] = options.xhrFields[ i ];\u000a					}\u000a				}\u000a\u000a				// Override mime type if needed\u000a				if ( options.mimeType && xhr.overrideMimeType ) {\u000a					xhr.overrideMimeType( options.mimeType );\u000a				}\u000a\u000a				// X-Requested-With header\u000a				// For cross-domain requests, seeing as conditions for a preflight are\u000a				// akin to a jigsaw puzzle, we simply never set it to be sure.\u000a				// (it can always be set on a per-request basis or even using ajaxSetup)\u000a				// For same-domain requests, won't change header if already provided.\u000a				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {\u000a					headers[ "X-Requested-With" ] = "XMLHttpRequest";\u000a				}\u000a\u000a				// Set headers\u000a				for ( i in headers ) {\u000a					xhr.setRequestHeader( i, headers[ i ] );\u000a				}\u000a\u000a				// Callback\u000a				callback = function( type ) {\u000a					return function() {\u000a						if ( callback ) {\u000a							callback = errorCallback = xhr.onload =\u000a								xhr.onerror = xhr.onabort = xhr.ontimeout =\u000a									xhr.onreadystatechange = null;\u000a\u000a							if ( type === "abort" ) {\u000a								xhr.abort();\u000a							} else if ( type === "error" ) {\u000a\u000a								// Support: IE <=9 only\u000a								// On a manual native abort, IE9 throws\u000a								// errors on any property access that is not readyState\u000a								if ( typeof xhr.status !== "number" ) {\u000a									complete( 0, "error" );\u000a								} else {\u000a									complete(\u000a\u000a										// File: protocol always yields status 0; see #8605, #14207\u000a										xhr.status,\u000a										xhr.statusText\u000a									);\u000a								}\u000a							} else {\u000a								complete(\u000a									xhrSuccessStatus[ xhr.status ] || xhr.status,\u000a									xhr.statusText,\u000a\u000a									// Support: IE <=9 only\u000a									// IE9 has no XHR2 but throws on binary (trac-11426)\u000a									// For XHR2 non-text, let the caller handle it (gh-2498)\u000a									( xhr.responseType || "text" ) !== "text"  ||\u000a									typeof xhr.responseText !== "string" ?\u000a										{ binary: xhr.response } :\u000a										{ text: xhr.responseText },\u000a									xhr.getAllResponseHeaders()\u000a								);\u000a							}\u000a						}\u000a					};\u000a				};\u000a\u000a				// Listen to events\u000a				xhr.onload = callback();\u000a				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );\u000a\u000a				// Support: IE 9 only\u000a				// Use onreadystatechange to replace onabort\u000a				// to handle uncaught aborts\u000a				if ( xhr.onabort !== undefined ) {\u000a					xhr.onabort = errorCallback;\u000a				} else {\u000a					xhr.onreadystatechange = function() {\u000a\u000a						// Check readyState before timeout as it changes\u000a						if ( xhr.readyState === 4 ) {\u000a\u000a							// Allow onerror to be called first,\u000a							// but that will not handle a native abort\u000a							// Also, save errorCallback to a variable\u000a							// as xhr.onerror cannot be accessed\u000a							window.setTimeout( function() {\u000a								if ( callback ) {\u000a									errorCallback();\u000a								}\u000a							} );\u000a						}\u000a					};\u000a				}\u000a\u000a				// Create the abort callback\u000a				callback = callback( "abort" );\u000a\u000a				try {\u000a\u000a					// Do send the request (this may raise an exception)\u000a					xhr.send( options.hasContent && options.data || null );\u000a				} catch ( e ) {\u000a\u000a					// #14683: Only rethrow if this hasn't been notified as an error yet\u000a					if ( callback ) {\u000a						throw e;\u000a					}\u000a				}\u000a			},\u000a\u000a			abort: function() {\u000a				if ( callback ) {\u000a					callback();\u000a				}\u000a			}\u000a		};\u000a	}\u000a} );\u000a\u000a\u000a\u000a\u000a// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\u000ajQuery.ajaxPrefilter( function( s ) {\u000a	if ( s.crossDomain ) {\u000a		s.contents.script = false;\u000a	}\u000a} );\u000a\u000a// Install script dataType\u000ajQuery.ajaxSetup( {\u000a	accepts: {\u000a		script: "text/javascript, application/javascript, " +\u000a			"application/ecmascript, application/x-ecmascript"\u000a	},\u000a	contents: {\u000a		script: /\u005cb(?:java|ecma)script\u005cb/\u000a	},\u000a	converters: {\u000a		"text script": function( text ) {\u000a			jQuery.globalEval( text );\u000a			return text;\u000a		}\u000a	}\u000a} );\u000a\u000a// Handle cache's special case and crossDomain\u000ajQuery.ajaxPrefilter( "script", function( s ) {\u000a	if ( s.cache === undefined ) {\u000a		s.cache = false;\u000a	}\u000a	if ( s.crossDomain ) {\u000a		s.type = "GET";\u000a	}\u000a} );\u000a\u000a// Bind script tag hack transport\u000ajQuery.ajaxTransport( "script", function( s ) {\u000a\u000a	// This transport only deals with cross domain requests\u000a	if ( s.crossDomain ) {\u000a		var script, callback;\u000a		return {\u000a			send: function( _, complete ) {\u000a				script = jQuery( "<script>" ).prop( {\u000a					charset: s.scriptCharset,\u000a					src: s.url\u000a				} ).on(\u000a					"load error",\u000a					callback = function( evt ) {\u000a						script.remove();\u000a						callback = null;\u000a						if ( evt ) {\u000a							complete( evt.type === "error" ? 404 : 200, evt.type );\u000a						}\u000a					}\u000a				);\u000a\u000a				// Use native DOM manipulation to avoid our domManip AJAX trickery\u000a				document.head.appendChild( script[ 0 ] );\u000a			},\u000a			abort: function() {\u000a				if ( callback ) {\u000a					callback();\u000a				}\u000a			}\u000a		};\u000a	}\u000a} );\u000a\u000a\u000a\u000a\u000avar oldCallbacks = [],\u000a	rjsonp = /(=)\u005c?(?=&|$)|\u005c?\u005c?/;\u000a\u000a// Default jsonp settings\u000ajQuery.ajaxSetup( {\u000a	jsonp: "callback",\u000a	jsonpCallback: function() {\u000a		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );\u000a		this[ callback ] = true;\u000a		return callback;\u000a	}\u000a} );\u000a\u000a// Detect, normalize options and install callbacks for jsonp requests\u000ajQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\u000a\u000a	var callbackName, overwritten, responseContainer,\u000a		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\u000a			"url" :\u000a			typeof s.data === "string" &&\u000a				( s.contentType || "" )\u000a					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&\u000a				rjsonp.test( s.data ) && "data"\u000a		);\u000a\u000a	// Handle iff the expected data type is "jsonp" or we have a parameter to set\u000a	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\u000a\u000a		// Get callback name, remembering preexisting value associated with it\u000a		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\u000a			s.jsonpCallback() :\u000a			s.jsonpCallback;\u000a\u000a		// Insert callback into url or form data\u000a		if ( jsonProp ) {\u000a			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\u000a		} else if ( s.jsonp !== false ) {\u000a			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\u000a		}\u000a\u000a		// Use data converter to retrieve json after script execution\u000a		s.converters[ "script json" ] = function() {\u000a			if ( !responseContainer ) {\u000a				jQuery.error( callbackName + " was not called" );\u000a			}\u000a			return responseContainer[ 0 ];\u000a		};\u000a\u000a		// Force json dataType\u000a		s.dataTypes[ 0 ] = "json";\u000a\u000a		// Install callback\u000a		overwritten = window[ callbackName ];\u000a		window[ callbackName ] = function() {\u000a			responseContainer = arguments;\u000a		};\u000a\u000a		// Clean-up function (fires after converters)\u000a		jqXHR.always( function() {\u000a\u000a			// If previous value didn't exist - remove it\u000a			if ( overwritten === undefined ) {\u000a				jQuery( window ).removeProp( callbackName );\u000a\u000a			// Otherwise restore preexisting value\u000a			} else {\u000a				window[ callbackName ] = overwritten;\u000a			}\u000a\u000a			// Save back as free\u000a			if ( s[ callbackName ] ) {\u000a\u000a				// Make sure that re-using the options doesn't screw things around\u000a				s.jsonpCallback = originalSettings.jsonpCallback;\u000a\u000a				// Save the callback name for future use\u000a				oldCallbacks.push( callbackName );\u000a			}\u000a\u000a			// Call if it was a function and we have a response\u000a			if ( responseContainer && isFunction( overwritten ) ) {\u000a				overwritten( responseContainer[ 0 ] );\u000a			}\u000a\u000a			responseContainer = overwritten = undefined;\u000a		} );\u000a\u000a		// Delegate to script\u000a		return "script";\u000a	}\u000a} );\u000a\u000a\u000a\u000a\u000a// Support: Safari 8 only\u000a// In Safari 8 documents created via document.implementation.createHTMLDocument\u000a// collapse sibling forms: the second one becomes a child of the first one.\u000a// Because of that, this security measure has to be disabled in Safari 8.\u000a// https://bugs.webkit.org/show_bug.cgi?id=137337\u000asupport.createHTMLDocument = ( function() {\u000a	var body = document.implementation.createHTMLDocument( "" ).body;\u000a	body.innerHTML = "<form></form><form></form>";\u000a	return body.childNodes.length === 2;\u000a} )();\u000a\u000a\u000a// Argument "data" should be string of html\u000a// context (optional): If specified, the fragment will be created in this context,\u000a// defaults to document\u000a// keepScripts (optional): If true, will include scripts passed in the html string\u000ajQuery.parseHTML = function( data, context, keepScripts ) {\u000a	if ( typeof data !== "string" ) {\u000a		return [];\u000a	}\u000a	if ( typeof context === "boolean" ) {\u000a		keepScripts = context;\u000a		context = false;\u000a	}\u000a\u000a	var base, parsed, scripts;\u000a\u000a	if ( !context ) {\u000a\u000a		// Stop scripts or inline event handlers from being executed immediately\u000a		// by using document.implementation\u000a		if ( support.createHTMLDocument ) {\u000a			context = document.implementation.createHTMLDocument( "" );\u000a\u000a			// Set the base href for the created document\u000a			// so any parsed elements with URLs\u000a			// are based on the document's URL (gh-2965)\u000a			base = context.createElement( "base" );\u000a			base.href = document.location.href;\u000a			context.head.appendChild( base );\u000a		} else {\u000a			context = document;\u000a		}\u000a	}\u000a\u000a	parsed = rsingleTag.exec( data );\u000a	scripts = !keepScripts && [];\u000a\u000a	// Single tag\u000a	if ( parsed ) {\u000a		return [ context.createElement( parsed[ 1 ] ) ];\u000a	}\u000a\u000a	parsed = buildFragment( [ data ], context, scripts );\u000a\u000a	if ( scripts && scripts.length ) {\u000a		jQuery( scripts ).remove();\u000a	}\u000a\u000a	return jQuery.merge( [], parsed.childNodes );\u000a};\u000a\u000a\u000a/**\u000a * Load a url into a page\u000a */\u000ajQuery.fn.load = function( url, params, callback ) {\u000a	var selector, type, response,\u000a		self = this,\u000a		off = url.indexOf( " " );\u000a\u000a	if ( off > -1 ) {\u000a		selector = stripAndCollapse( url.slice( off ) );\u000a		url = url.slice( 0, off );\u000a	}\u000a\u000a	// If it's a function\u000a	if ( isFunction( params ) ) {\u000a\u000a		// We assume that it's the callback\u000a		callback = params;\u000a		params = undefined;\u000a\u000a	// Otherwise, build a param string\u000a	} else if ( params && typeof params === "object" ) {\u000a		type = "POST";\u000a	}\u000a\u000a	// If we have elements to modify, make the request\u000a	if ( self.length > 0 ) {\u000a		jQuery.ajax( {\u000a			url: url,\u000a\u000a			// If "type" variable is undefined, then "GET" method will be used.\u000a			// Make value of this field explicit since\u000a			// user can override it through ajaxSetup method\u000a			type: type || "GET",\u000a			dataType: "html",\u000a			data: params\u000a		} ).done( function( responseText ) {\u000a\u000a			// Save response for use in complete callback\u000a			response = arguments;\u000a\u000a			self.html( selector ?\u000a\u000a				// If a selector was specified, locate the right elements in a dummy div\u000a				// Exclude scripts to avoid IE 'Permission Denied' errors\u000a				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\u000a\u000a				// Otherwise use the full result\u000a				responseText );\u000a\u000a		// If the request succeeds, this function gets "data", "status", "jqXHR"\u000a		// but they are ignored because response was set above.\u000a		// If it fails, this function gets "jqXHR", "status", "error"\u000a		} ).always( callback && function( jqXHR, status ) {\u000a			self.each( function() {\u000a				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\u000a			} );\u000a		} );\u000a	}\u000a\u000a	return this;\u000a};\u000a\u000a\u000a\u000a\u000a// Attach a bunch of functions for handling common AJAX events\u000ajQuery.each( [\u000a	"ajaxStart",\u000a	"ajaxStop",\u000a	"ajaxComplete",\u000a	"ajaxError",\u000a	"ajaxSuccess",\u000a	"ajaxSend"\u000a], function( i, type ) {\u000a	jQuery.fn[ type ] = function( fn ) {\u000a		return this.on( type, fn );\u000a	};\u000a} );\u000a\u000a\u000a\u000a\u000ajQuery.expr.pseudos.animated = function( elem ) {\u000a	return jQuery.grep( jQuery.timers, function( fn ) {\u000a		return elem === fn.elem;\u000a	} ).length;\u000a};\u000a\u000a\u000a\u000a\u000ajQuery.offset = {\u000a	setOffset: function( elem, options, i ) {\u000a		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\u000a			position = jQuery.css( elem, "position" ),\u000a			curElem = jQuery( elem ),\u000a			props = {};\u000a\u000a		// Set position first, in-case top/left are set even on static elem\u000a		if ( position === "static" ) {\u000a			elem.style.position = "relative";\u000a		}\u000a\u000a		curOffset = curElem.offset();\u000a		curCSSTop = jQuery.css( elem, "top" );\u000a		curCSSLeft = jQuery.css( elem, "left" );\u000a		calculatePosition = ( position === "absolute" || position === "fixed" ) &&\u000a			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;\u000a\u000a		// Need to be able to calculate position if either\u000a		// top or left is auto and position is either absolute or fixed\u000a		if ( calculatePosition ) {\u000a			curPosition = curElem.position();\u000a			curTop = curPosition.top;\u000a			curLeft = curPosition.left;\u000a\u000a		} else {\u000a			curTop = parseFloat( curCSSTop ) || 0;\u000a			curLeft = parseFloat( curCSSLeft ) || 0;\u000a		}\u000a\u000a		if ( isFunction( options ) ) {\u000a\u000a			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\u000a			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );\u000a		}\u000a\u000a		if ( options.top != null ) {\u000a			props.top = ( options.top - curOffset.top ) + curTop;\u000a		}\u000a		if ( options.left != null ) {\u000a			props.left = ( options.left - curOffset.left ) + curLeft;\u000a		}\u000a\u000a		if ( "using" in options ) {\u000a			options.using.call( elem, props );\u000a\u000a		} else {\u000a			curElem.css( props );\u000a		}\u000a	}\u000a};\u000a\u000ajQuery.fn.extend( {\u000a\u000a	// offset() relates an element's border box to the document origin\u000a	offset: function( options ) {\u000a\u000a		// Preserve chaining for setter\u000a		if ( arguments.length ) {\u000a			return options === undefined ?\u000a				this :\u000a				this.each( function( i ) {\u000a					jQuery.offset.setOffset( this, options, i );\u000a				} );\u000a		}\u000a\u000a		var rect, win,\u000a			elem = this[ 0 ];\u000a\u000a		if ( !elem ) {\u000a			return;\u000a		}\u000a\u000a		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\u000a		// Support: IE <=11 only\u000a		// Running getBoundingClientRect on a\u000a		// disconnected node in IE throws an error\u000a		if ( !elem.getClientRects().length ) {\u000a			return { top: 0, left: 0 };\u000a		}\u000a\u000a		// Get document-relative position by adding viewport scroll to viewport-relative gBCR\u000a		rect = elem.getBoundingClientRect();\u000a		win = elem.ownerDocument.defaultView;\u000a		return {\u000a			top: rect.top + win.pageYOffset,\u000a			left: rect.left + win.pageXOffset\u000a		};\u000a	},\u000a\u000a	// position() relates an element's margin box to its offset parent's padding box\u000a	// This corresponds to the behavior of CSS absolute positioning\u000a	position: function() {\u000a		if ( !this[ 0 ] ) {\u000a			return;\u000a		}\u000a\u000a		var offsetParent, offset, doc,\u000a			elem = this[ 0 ],\u000a			parentOffset = { top: 0, left: 0 };\u000a\u000a		// position:fixed elements are offset from the viewport, which itself always has zero offset\u000a		if ( jQuery.css( elem, "position" ) === "fixed" ) {\u000a\u000a			// Assume position:fixed implies availability of getBoundingClientRect\u000a			offset = elem.getBoundingClientRect();\u000a\u000a		} else {\u000a			offset = this.offset();\u000a\u000a			// Account for the *real* offset parent, which can be the document or its root element\u000a			// when a statically positioned element is identified\u000a			doc = elem.ownerDocument;\u000a			offsetParent = elem.offsetParent || doc.documentElement;\u000a			while ( offsetParent &&\u000a				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\u000a				jQuery.css( offsetParent, "position" ) === "static" ) {\u000a\u000a				offsetParent = offsetParent.parentNode;\u000a			}\u000a			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\u000a\u000a				// Incorporate borders into its offset, since they are outside its content origin\u000a				parentOffset = jQuery( offsetParent ).offset();\u000a				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );\u000a				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );\u000a			}\u000a		}\u000a\u000a		// Subtract parent offsets and element margins\u000a		return {\u000a			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),\u000a			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )\u000a		};\u000a	},\u000a\u000a	// This method will return documentElement in the following cases:\u000a	// 1) For the element inside the iframe without offsetParent, this method will return\u000a	//    documentElement of the parent window\u000a	// 2) For the hidden or detached element\u000a	// 3) For body or html element, i.e. in case of the html node - it will return itself\u000a	//\u000a	// but those exceptions were never presented as a real life use-cases\u000a	// and might be considered as more preferable results.\u000a	//\u000a	// This logic, however, is not guaranteed and can change at any point in the future\u000a	offsetParent: function() {\u000a		return this.map( function() {\u000a			var offsetParent = this.offsetParent;\u000a\u000a			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {\u000a				offsetParent = offsetParent.offsetParent;\u000a			}\u000a\u000a			return offsetParent || documentElement;\u000a		} );\u000a	}\u000a} );\u000a\u000a// Create scrollLeft and scrollTop methods\u000ajQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {\u000a	var top = "pageYOffset" === prop;\u000a\u000a	jQuery.fn[ method ] = function( val ) {\u000a		return access( this, function( elem, method, val ) {\u000a\u000a			// Coalesce documents and windows\u000a			var win;\u000a			if ( isWindow( elem ) ) {\u000a				win = elem;\u000a			} else if ( elem.nodeType === 9 ) {\u000a				win = elem.defaultView;\u000a			}\u000a\u000a			if ( val === undefined ) {\u000a				return win ? win[ prop ] : elem[ method ];\u000a			}\u000a\u000a			if ( win ) {\u000a				win.scrollTo(\u000a					!top ? val : win.pageXOffset,\u000a					top ? val : win.pageYOffset\u000a				);\u000a\u000a			} else {\u000a				elem[ method ] = val;\u000a			}\u000a		}, method, val, arguments.length );\u000a	};\u000a} );\u000a\u000a// Support: Safari <=7 - 9.1, Chrome <=37 - 49\u000a// Add the top/left cssHooks using jQuery.fn.position\u000a// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\u000a// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\u000a// getComputedStyle returns percent when specified for top/left/bottom/right;\u000a// rather than make the css module depend on the offset module, just check for it here\u000ajQuery.each( [ "top", "left" ], function( i, prop ) {\u000a	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\u000a		function( elem, computed ) {\u000a			if ( computed ) {\u000a				computed = curCSS( elem, prop );\u000a\u000a				// If curCSS returns percentage, fallback to offset\u000a				return rnumnonpx.test( computed ) ?\u000a					jQuery( elem ).position()[ prop ] + "px" :\u000a					computed;\u000a			}\u000a		}\u000a	);\u000a} );\u000a\u000a\u000a// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\u000ajQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\u000a	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },\u000a		function( defaultExtra, funcName ) {\u000a\u000a		// Margin is only for outerHeight, outerWidth\u000a		jQuery.fn[ funcName ] = function( margin, value ) {\u000a			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\u000a				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\u000a\u000a			return access( this, function( elem, type, value ) {\u000a				var doc;\u000a\u000a				if ( isWindow( elem ) ) {\u000a\u000a					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\u000a					return funcName.indexOf( "outer" ) === 0 ?\u000a						elem[ "inner" + name ] :\u000a						elem.document.documentElement[ "client" + name ];\u000a				}\u000a\u000a				// Get document width or height\u000a				if ( elem.nodeType === 9 ) {\u000a					doc = elem.documentElement;\u000a\u000a					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\u000a					// whichever is greatest\u000a					return Math.max(\u000a						elem.body[ "scroll" + name ], doc[ "scroll" + name ],\u000a						elem.body[ "offset" + name ], doc[ "offset" + name ],\u000a						doc[ "client" + name ]\u000a					);\u000a				}\u000a\u000a				return value === undefined ?\u000a\u000a					// Get width or height on the element, requesting but not forcing parseFloat\u000a					jQuery.css( elem, type, extra ) :\u000a\u000a					// Set width or height on the element\u000a					jQuery.style( elem, type, value, extra );\u000a			}, type, chainable ? margin : undefined, chainable );\u000a		};\u000a	} );\u000a} );\u000a\u000a\u000ajQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +\u000a	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\u000a	"change select submit keydown keypress keyup contextmenu" ).split( " " ),\u000a	function( i, name ) {\u000a\u000a	// Handle event binding\u000a	jQuery.fn[ name ] = function( data, fn ) {\u000a		return arguments.length > 0 ?\u000a			this.on( name, null, data, fn ) :\u000a			this.trigger( name );\u000a	};\u000a} );\u000a\u000ajQuery.fn.extend( {\u000a	hover: function( fnOver, fnOut ) {\u000a		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\u000a	}\u000a} );\u000a\u000a\u000a\u000a\u000ajQuery.fn.extend( {\u000a\u000a	bind: function( types, data, fn ) {\u000a		return this.on( types, null, data, fn );\u000a	},\u000a	unbind: function( types, fn ) {\u000a		return this.off( types, null, fn );\u000a	},\u000a\u000a	delegate: function( selector, types, data, fn ) {\u000a		return this.on( types, selector, data, fn );\u000a	},\u000a	undelegate: function( selector, types, fn ) {\u000a\u000a		// ( namespace ) or ( selector, types [, fn] )\u000a		return arguments.length === 1 ?\u000a			this.off( selector, "**" ) :\u000a			this.off( types, selector || "**", fn );\u000a	}\u000a} );\u000a\u000a// Bind a function to a context, optionally partially applying any\u000a// arguments.\u000a// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\u000a// However, it is not slated for removal any time soon\u000ajQuery.proxy = function( fn, context ) {\u000a	var tmp, args, proxy;\u000a\u000a	if ( typeof context === "string" ) {\u000a		tmp = fn[ context ];\u000a		context = fn;\u000a		fn = tmp;\u000a	}\u000a\u000a	// Quick check to determine if target is callable, in the spec\u000a	// this throws a TypeError, but we will just return undefined.\u000a	if ( !isFunction( fn ) ) {\u000a		return undefined;\u000a	}\u000a\u000a	// Simulated bind\u000a	args = slice.call( arguments, 2 );\u000a	proxy = function() {\u000a		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );\u000a	};\u000a\u000a	// Set the guid of unique handler to the same of original handler, so it can be removed\u000a	proxy.guid = fn.guid = fn.guid || jQuery.guid++;\u000a\u000a	return proxy;\u000a};\u000a\u000ajQuery.holdReady = function( hold ) {\u000a	if ( hold ) {\u000a		jQuery.readyWait++;\u000a	} else {\u000a		jQuery.ready( true );\u000a	}\u000a};\u000ajQuery.isArray = Array.isArray;\u000ajQuery.parseJSON = JSON.parse;\u000ajQuery.nodeName = nodeName;\u000ajQuery.isFunction = isFunction;\u000ajQuery.isWindow = isWindow;\u000ajQuery.camelCase = camelCase;\u000ajQuery.type = toType;\u000a\u000ajQuery.now = Date.now;\u000a\u000ajQuery.isNumeric = function( obj ) {\u000a\u000a	// As of jQuery 3.0, isNumeric is limited to\u000a	// strings and numbers (primitives or objects)\u000a	// that can be coerced to finite numbers (gh-2662)\u000a	var type = jQuery.type( obj );\u000a	return ( type === "number" || type === "string" ) &&\u000a\u000a		// parseFloat NaNs numeric-cast false positives ("")\u000a		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\u000a		// subtraction forces infinities to NaN\u000a		!isNaN( obj - parseFloat( obj ) );\u000a};\u000a\u000a\u000a\u000a\u000a// Register as a named AMD module, since jQuery can be concatenated with other\u000a// files that may use define, but not via a proper concatenation script that\u000a// understands anonymous AMD modules. A named AMD is safest and most robust\u000a// way to register. Lowercase jquery is used because AMD module names are\u000a// derived from file names, and jQuery is normally delivered in a lowercase\u000a// file name. Do this after creating the global so that if an AMD module wants\u000a// to call noConflict to hide this version of jQuery, it will work.\u000a\u000a// Note that for maximum portability, libraries that are not jQuery should\u000a// declare themselves as anonymous modules, and avoid setting a global if an\u000a// AMD loader is present. jQuery is a special case. For more information, see\u000a// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\u000a\u000aif ( typeof define === "function" && define.amd ) {\u000a	define( "jquery", [], function() {\u000a		return jQuery;\u000a	} );\u000a}\u000a\u000a\u000a\u000a\u000avar\u000a\u000a	// Map over jQuery in case of overwrite\u000a	_jQuery = window.jQuery,\u000a\u000a	// Map over the $ in case of overwrite\u000a	_$ = window.$;\u000a\u000ajQuery.noConflict = function( deep ) {\u000a	if ( window.$ === jQuery ) {\u000a		window.$ = _$;\u000a	}\u000a\u000a	if ( deep && window.jQuery === jQuery ) {\u000a		window.jQuery = _jQuery;\u000a	}\u000a\u000a	return jQuery;\u000a};\u000a\u000a// Expose jQuery and $ identifiers, even in AMD\u000a// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\u000a// and CommonJS for browser emulators (#13566)\u000aif ( !noGlobal ) {\u000a	window.jQuery = window.$ = jQuery;\u000a}\u000a\u000a\u000a\u000a\u000areturn jQuery;\u000a} );\u000a\u000a;\u000a
p0
.