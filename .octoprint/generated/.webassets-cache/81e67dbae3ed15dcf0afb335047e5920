V// source: js/lib/jquery/jquery.ui.mouse.js\u000a/*!\u000a * jQuery UI Mouse 1.9.2\u000a * http://jqueryui.com\u000a *\u000a * Copyright 2012 jQuery Foundation and other contributors\u000a * Released under the MIT license.\u000a * http://jquery.org/license\u000a *\u000a * http://api.jqueryui.com/mouse/\u000a *\u000a * Depends:\u000a *	jquery.ui.widget.js\u000a */\u000a(function( $, undefined ) {\u000a\u000avar mouseHandled = false;\u000a$( document ).mouseup( function( e ) {\u000a	mouseHandled = false;\u000a});\u000a\u000a$.widget("ui.mouse", {\u000a	version: "1.9.2",\u000a	options: {\u000a		cancel: 'input,textarea,button,select,option',\u000a		distance: 1,\u000a		delay: 0\u000a	},\u000a	_mouseInit: function() {\u000a		var that = this;\u000a\u000a		this.element\u000a			.bind('mousedown.'+this.widgetName, function(event) {\u000a				return that._mouseDown(event);\u000a			})\u000a			.bind('click.'+this.widgetName, function(event) {\u000a				if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {\u000a					$.removeData(event.target, that.widgetName + '.preventClickEvent');\u000a					event.stopImmediatePropagation();\u000a					return false;\u000a				}\u000a			});\u000a\u000a		this.started = false;\u000a	},\u000a\u000a	// TODO: make sure destroying one instance of mouse doesn't mess with\u000a	// other instances of mouse\u000a	_mouseDestroy: function() {\u000a		this.element.unbind('.'+this.widgetName);\u000a		if ( this._mouseMoveDelegate ) {\u000a			$(document)\u000a				.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)\u000a				.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);\u000a		}\u000a	},\u000a\u000a	_mouseDown: function(event) {\u000a		// don't let more than one widget handle mouseStart\u000a		if( mouseHandled ) { return; }\u000a\u000a		// we may have missed mouseup (out of window)\u000a		(this._mouseStarted && this._mouseUp(event));\u000a\u000a		this._mouseDownEvent = event;\u000a\u000a		var that = this,\u000a			btnIsLeft = (event.which === 1),\u000a			// event.target.nodeName works around a bug in IE 8 with\u000a			// disabled inputs (#7620)\u000a			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\u000a		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\u000a			return true;\u000a		}\u000a\u000a		this.mouseDelayMet = !this.options.delay;\u000a		if (!this.mouseDelayMet) {\u000a			this._mouseDelayTimer = setTimeout(function() {\u000a				that.mouseDelayMet = true;\u000a			}, this.options.delay);\u000a		}\u000a\u000a		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\u000a			this._mouseStarted = (this._mouseStart(event) !== false);\u000a			if (!this._mouseStarted) {\u000a				event.preventDefault();\u000a				return true;\u000a			}\u000a		}\u000a\u000a		// Click event may never have fired (Gecko & Opera)\u000a		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {\u000a			$.removeData(event.target, this.widgetName + '.preventClickEvent');\u000a		}\u000a\u000a		// these delegates are required to keep context\u000a		this._mouseMoveDelegate = function(event) {\u000a			return that._mouseMove(event);\u000a		};\u000a		this._mouseUpDelegate = function(event) {\u000a			return that._mouseUp(event);\u000a		};\u000a		$(document)\u000a			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)\u000a			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);\u000a\u000a		event.preventDefault();\u000a\u000a		mouseHandled = true;\u000a		return true;\u000a	},\u000a\u000a	_mouseMove: function(event) {\u000a		// IE mouseup check - mouseup happened when mouse was out of window\u000a		if ($.ui.ie && !(document.documentMode >= 9) && !event.button) {\u000a			return this._mouseUp(event);\u000a		}\u000a\u000a		if (this._mouseStarted) {\u000a			this._mouseDrag(event);\u000a			return event.preventDefault();\u000a		}\u000a\u000a		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\u000a			this._mouseStarted =\u000a				(this._mouseStart(this._mouseDownEvent, event) !== false);\u000a			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\u000a		}\u000a\u000a		return !this._mouseStarted;\u000a	},\u000a\u000a	_mouseUp: function(event) {\u000a		$(document)\u000a			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)\u000a			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);\u000a\u000a		if (this._mouseStarted) {\u000a			this._mouseStarted = false;\u000a\u000a			if (event.target === this._mouseDownEvent.target) {\u000a				$.data(event.target, this.widgetName + '.preventClickEvent', true);\u000a			}\u000a\u000a			this._mouseStop(event);\u000a		}\u000a\u000a		return false;\u000a	},\u000a\u000a	_mouseDistanceMet: function(event) {\u000a		return (Math.max(\u000a				Math.abs(this._mouseDownEvent.pageX - event.pageX),\u000a				Math.abs(this._mouseDownEvent.pageY - event.pageY)\u000a			) >= this.options.distance\u000a		);\u000a	},\u000a\u000a	_mouseDelayMet: function(event) {\u000a		return this.mouseDelayMet;\u000a	},\u000a\u000a	// These are placeholder methods, to be overriden by extending plugin\u000a	_mouseStart: function(event) {},\u000a	_mouseDrag: function(event) {},\u000a	_mouseStop: function(event) {},\u000a	_mouseCapture: function(event) { return true; }\u000a});\u000a\u000a})(jQuery);\u000a\u000a;\u000a
p0
.