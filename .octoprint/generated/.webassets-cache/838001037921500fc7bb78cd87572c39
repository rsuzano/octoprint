V// source: js/lib/jquery/jquery.fileupload.js\u000a/*\u000a * jQuery File Upload Plugin 5.19.7\u000a * https://github.com/blueimp/jQuery-File-Upload\u000a *\u000a * Copyright 2010, Sebastian Tschan\u000a * https://blueimp.net\u000a *\u000a * Licensed under the MIT license:\u000a * http://www.opensource.org/licenses/MIT\u000a */\u000a\u000a/*jslint nomen: true, unparam: true, regexp: true */\u000a/*global define, window, document, File, Blob, FormData, location */\u000a\u000a(function (factory) {\u000a    'use strict';\u000a    if (typeof define === 'function' && define.amd) {\u000a        // Register as an anonymous AMD module:\u000a        define([\u000a            'jquery',\u000a            'jquery.ui.widget.js'\u000a        ], factory);\u000a    } else {\u000a        // Browser globals:\u000a        factory(window.jQuery);\u000a    }\u000a}(function ($) {\u000a    'use strict';\u000a\u000a    // The FileReader API is not actually used, but works as feature detection,\u000a    // as e.g. Safari supports XHR file uploads via the FormData API,\u000a    // but not non-multipart XHR file uploads:\u000a    $.support.xhrFileUpload = !!(window.XMLHttpRequestUpload && window.FileReader);\u000a    $.support.xhrFormDataFileUpload = !!window.FormData;\u000a\u000a    // The fileupload widget listens for change events on file input fields defined\u000a    // via fileInput setting and paste or drop events of the given dropZone.\u000a    // In addition to the default jQuery Widget methods, the fileupload widget\u000a    // exposes the "add" and "send" methods, to add or directly send files using\u000a    // the fileupload API.\u000a    // By default, files added via file input selection, paste, drag & drop or\u000a    // "add" method are uploaded immediately, but it is possible to override\u000a    // the "add" callback option to queue file uploads.\u000a    $.widget('blueimp.fileupload', {\u000a\u000a        options: {\u000a            // The drop target element(s), by the default the complete document.\u000a            // Set to null to disable drag & drop support:\u000a            dropZone: $(document),\u000a            // The paste target element(s), by the default the complete document.\u000a            // Set to null to disable paste support:\u000a            pasteZone: $(document),\u000a            // The file input field(s), that are listened to for change events.\u000a            // If undefined, it is set to the file input fields inside\u000a            // of the widget element on plugin initialization.\u000a            // Set to null to disable the change listener.\u000a            fileInput: undefined,\u000a            // By default, the file input field is replaced with a clone after\u000a            // each input field change event. This is required for iframe transport\u000a            // queues and allows change events to be fired for the same file\u000a            // selection, but can be disabled by setting the following option to false:\u000a            replaceFileInput: true,\u000a            // The parameter name for the file form data (the request argument name).\u000a            // If undefined or empty, the name property of the file input field is\u000a            // used, or "files[]" if the file input name property is also empty,\u000a            // can be a string or an array of strings:\u000a            paramName: undefined,\u000a            // By default, each file of a selection is uploaded using an individual\u000a            // request for XHR type uploads. Set to false to upload file\u000a            // selections in one request each:\u000a            singleFileUploads: true,\u000a            // To limit the number of files uploaded with one XHR request,\u000a            // set the following option to an integer greater than 0:\u000a            limitMultiFileUploads: undefined,\u000a            // Set the following option to true to issue all file upload requests\u000a            // in a sequential order:\u000a            sequentialUploads: false,\u000a            // To limit the number of concurrent uploads,\u000a            // set the following option to an integer greater than 0:\u000a            limitConcurrentUploads: undefined,\u000a            // Set the following option to true to force iframe transport uploads:\u000a            forceIframeTransport: false,\u000a            // Set the following option to the location of a redirect url on the\u000a            // origin server, for cross-domain iframe transport uploads:\u000a            redirect: undefined,\u000a            // The parameter name for the redirect url, sent as part of the form\u000a            // data and set to 'redirect' if this option is empty:\u000a            redirectParamName: undefined,\u000a            // Set the following option to the location of a postMessage window,\u000a            // to enable postMessage transport uploads:\u000a            postMessage: undefined,\u000a            // By default, XHR file uploads are sent as multipart/form-data.\u000a            // The iframe transport is always using multipart/form-data.\u000a            // Set to false to enable non-multipart XHR uploads:\u000a            multipart: true,\u000a            // To upload large files in smaller chunks, set the following option\u000a            // to a preferred maximum chunk size. If set to 0, null or undefined,\u000a            // or the browser does not support the required Blob API, files will\u000a            // be uploaded as a whole.\u000a            maxChunkSize: undefined,\u000a            // When a non-multipart upload or a chunked multipart upload has been\u000a            // aborted, this option can be used to resume the upload by setting\u000a            // it to the size of the already uploaded bytes. This option is most\u000a            // useful when modifying the options object inside of the "add" or\u000a            // "send" callbacks, as the options are cloned for each file upload.\u000a            uploadedBytes: undefined,\u000a            // By default, failed (abort or error) file uploads are removed from the\u000a            // global progress calculation. Set the following option to false to\u000a            // prevent recalculating the global progress data:\u000a            recalculateProgress: true,\u000a            // Interval in milliseconds to calculate and trigger progress events:\u000a            progressInterval: 100,\u000a            // Interval in milliseconds to calculate progress bitrate:\u000a            bitrateInterval: 500,\u000a\u000a            // Additional form data to be sent along with the file uploads can be set\u000a            // using this option, which accepts an array of objects with name and\u000a            // value properties, a function returning such an array, a FormData\u000a            // object (for XHR file uploads), or a simple object.\u000a            // The form of the first fileInput is given as parameter to the function:\u000a            formData: function (form) {\u000a                return form.serializeArray();\u000a            },\u000a\u000a            // The add callback is invoked as soon as files are added to the fileupload\u000a            // widget (via file input selection, drag & drop, paste or add API call).\u000a            // If the singleFileUploads option is enabled, this callback will be\u000a            // called once for each file in the selection for XHR file uplaods, else\u000a            // once for each file selection.\u000a            // The upload starts when the submit method is invoked on the data parameter.\u000a            // The data object contains a files property holding the added files\u000a            // and allows to override plugin options as well as define ajax settings.\u000a            // Listeners for this callback can also be bound the following way:\u000a            // .bind('fileuploadadd', func);\u000a            // data.submit() returns a Promise object and allows to attach additional\u000a            // handlers using jQuery's Deferred callbacks:\u000a            // data.submit().done(func).fail(func).always(func);\u000a            add: function (e, data) {\u000a                data.submit();\u000a            },\u000a\u000a            // Other callbacks:\u000a            // Callback for the submit event of each file upload:\u000a            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\u000a            // Callback for the start of each file upload request:\u000a            // send: function (e, data) {}, // .bind('fileuploadsend', func);\u000a            // Callback for successful uploads:\u000a            // done: function (e, data) {}, // .bind('fileuploaddone', func);\u000a            // Callback for failed (abort or error) uploads:\u000a            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\u000a            // Callback for completed (success, abort or error) requests:\u000a            // always: function (e, data) {}, // .bind('fileuploadalways', func);\u000a            // Callback for upload progress events:\u000a            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\u000a            // Callback for global upload progress events:\u000a            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\u000a            // Callback for uploads start, equivalent to the global ajaxStart event:\u000a            // start: function (e) {}, // .bind('fileuploadstart', func);\u000a            // Callback for uploads stop, equivalent to the global ajaxStop event:\u000a            // stop: function (e) {}, // .bind('fileuploadstop', func);\u000a            // Callback for change events of the fileInput(s):\u000a            // change: function (e, data) {}, // .bind('fileuploadchange', func);\u000a            // Callback for paste events to the pasteZone(s):\u000a            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\u000a            // Callback for drop events of the dropZone(s):\u000a            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\u000a            // Callback for dragover events of the dropZone(s):\u000a            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\u000a\u000a            // The plugin options are used as settings object for the ajax calls.\u000a            // The following are jQuery ajax settings required for the file uploads:\u000a            processData: false,\u000a            contentType: false,\u000a            cache: false\u000a        },\u000a\u000a        // A list of options that require a refresh after assigning a new value:\u000a        _refreshOptionsList: [\u000a            'fileInput',\u000a            'dropZone',\u000a            'pasteZone',\u000a            'multipart',\u000a            'forceIframeTransport'\u000a        ],\u000a\u000a        _BitrateTimer: function () {\u000a            this.timestamp = +(new Date());\u000a            this.loaded = 0;\u000a            this.bitrate = 0;\u000a            this.getBitrate = function (now, loaded, interval) {\u000a                var timeDiff = now - this.timestamp;\u000a                if (!this.bitrate || !interval || timeDiff > interval) {\u000a                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\u000a                    this.loaded = loaded;\u000a                    this.timestamp = now;\u000a                }\u000a                return this.bitrate;\u000a            };\u000a        },\u000a\u000a        _isXHRUpload: function (options) {\u000a            return !options.forceIframeTransport &&\u000a                ((!options.multipart && $.support.xhrFileUpload) ||\u000a                $.support.xhrFormDataFileUpload);\u000a        },\u000a\u000a        _getFormData: function (options) {\u000a            var formData;\u000a            if (typeof options.formData === 'function') {\u000a                return options.formData(options.form);\u000a            }\u000a            if ($.isArray(options.formData)) {\u000a                return options.formData;\u000a            }\u000a            if (options.formData) {\u000a                formData = [];\u000a                $.each(options.formData, function (name, value) {\u000a                    formData.push({name: name, value: value});\u000a                });\u000a                return formData;\u000a            }\u000a            return [];\u000a        },\u000a\u000a        _getTotal: function (files) {\u000a            var total = 0;\u000a            $.each(files, function (index, file) {\u000a                total += file.size || 1;\u000a            });\u000a            return total;\u000a        },\u000a\u000a        _onProgress: function (e, data) {\u000a            if (e.lengthComputable) {\u000a                var now = +(new Date()),\u000a                    total,\u000a                    loaded;\u000a                if (data._time && data.progressInterval &&\u000a                        (now - data._time < data.progressInterval) &&\u000a                        e.loaded !== e.total) {\u000a                    return;\u000a                }\u000a                data._time = now;\u000a                total = data.total || this._getTotal(data.files);\u000a                loaded = parseInt(\u000a                    e.loaded / e.total * (data.chunkSize || total),\u000a                    10\u000a                ) + (data.uploadedBytes || 0);\u000a                this._loaded += loaded - (data.loaded || data.uploadedBytes || 0);\u000a                data.lengthComputable = true;\u000a                data.loaded = loaded;\u000a                data.total = total;\u000a                data.bitrate = data._bitrateTimer.getBitrate(\u000a                    now,\u000a                    loaded,\u000a                    data.bitrateInterval\u000a                );\u000a                // Trigger a custom progress event with a total data property set\u000a                // to the file size(s) of the current upload and a loaded data\u000a                // property calculated accordingly:\u000a                this._trigger('progress', e, data);\u000a                // Trigger a global progress event for all current file uploads,\u000a                // including ajax calls queued for sequential file uploads:\u000a                this._trigger('progressall', e, {\u000a                    lengthComputable: true,\u000a                    loaded: this._loaded,\u000a                    total: this._total,\u000a                    bitrate: this._bitrateTimer.getBitrate(\u000a                        now,\u000a                        this._loaded,\u000a                        data.bitrateInterval\u000a                    )\u000a                });\u000a            }\u000a        },\u000a\u000a        _initProgressListener: function (options) {\u000a            var that = this,\u000a                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\u000a            // Accesss to the native XHR object is required to add event listeners\u000a            // for the upload progress event:\u000a            if (xhr.upload) {\u000a                $(xhr.upload).bind('progress', function (e) {\u000a                    var oe = e.originalEvent;\u000a                    // Make sure the progress event properties get copied over:\u000a                    e.lengthComputable = oe.lengthComputable;\u000a                    e.loaded = oe.loaded;\u000a                    e.total = oe.total;\u000a                    that._onProgress(e, options);\u000a                });\u000a                options.xhr = function () {\u000a                    return xhr;\u000a                };\u000a            }\u000a        },\u000a\u000a        _initXHRData: function (options) {\u000a            var formData,\u000a                file = options.files[0],\u000a                // Ignore non-multipart setting if not supported:\u000a                multipart = options.multipart || !$.support.xhrFileUpload,\u000a                paramName = options.paramName[0];\u000a            options.headers = options.headers || {};\u000a            if (options.contentRange) {\u000a                options.headers['Content-Range'] = options.contentRange;\u000a            }\u000a            if (!multipart) {\u000a                options.headers['Content-Disposition'] = 'attachment; filename="' +\u000a                    encodeURI(file.name) + '"';\u000a                options.contentType = file.type;\u000a                options.data = options.blob || file;\u000a            } else if ($.support.xhrFormDataFileUpload) {\u000a                if (options.postMessage) {\u000a                    // window.postMessage does not allow sending FormData\u000a                    // objects, so we just add the File/Blob objects to\u000a                    // the formData array and let the postMessage window\u000a                    // create the FormData object out of this array:\u000a                    formData = this._getFormData(options);\u000a                    if (options.blob) {\u000a                        formData.push({\u000a                            name: paramName,\u000a                            value: options.blob\u000a                        });\u000a                    } else {\u000a                        $.each(options.files, function (index, file) {\u000a                            formData.push({\u000a                                name: options.paramName[index] || paramName,\u000a                                value: file\u000a                            });\u000a                        });\u000a                    }\u000a                } else {\u000a                    if (options.formData instanceof FormData) {\u000a                        formData = options.formData;\u000a                    } else {\u000a                        formData = new FormData();\u000a                        $.each(this._getFormData(options), function (index, field) {\u000a                            formData.append(field.name, field.value);\u000a                        });\u000a                    }\u000a                    if (options.blob) {\u000a                        options.headers['Content-Disposition'] = 'attachment; filename="' +\u000a                            encodeURI(file.name) + '"';\u000a                        formData.append(paramName, options.blob, file.name);\u000a                    } else {\u000a                        $.each(options.files, function (index, file) {\u000a                            // Files are also Blob instances, but some browsers\u000a                            // (Firefox 3.6) support the File API but not Blobs.\u000a                            // This check allows the tests to run with\u000a                            // dummy objects:\u000a                            if ((window.Blob && file instanceof Blob) ||\u000a                                    (window.File && file instanceof File)) {\u000a                                formData.append(\u000a                                    options.paramName[index] || paramName,\u000a                                    file,\u000a                                    file.name\u000a                                );\u000a                            }\u000a                        });\u000a                    }\u000a                }\u000a                options.data = formData;\u000a            }\u000a            // Blob reference is not needed anymore, free memory:\u000a            options.blob = null;\u000a        },\u000a\u000a        _initIframeSettings: function (options) {\u000a            // Setting the dataType to iframe enables the iframe transport:\u000a            options.dataType = 'iframe ' + (options.dataType || '');\u000a            // The iframe transport accepts a serialized array as form data:\u000a            options.formData = this._getFormData(options);\u000a            // Add redirect url to form data on cross-domain uploads:\u000a            if (options.redirect && $('<a></a>').prop('href', options.url)\u000a                    .prop('host') !== location.host) {\u000a                options.formData.push({\u000a                    name: options.redirectParamName || 'redirect',\u000a                    value: options.redirect\u000a                });\u000a            }\u000a        },\u000a\u000a        _initDataSettings: function (options) {\u000a            if (this._isXHRUpload(options)) {\u000a                if (!this._chunkedUpload(options, true)) {\u000a                    if (!options.data) {\u000a                        this._initXHRData(options);\u000a                    }\u000a                    this._initProgressListener(options);\u000a                }\u000a                if (options.postMessage) {\u000a                    // Setting the dataType to postmessage enables the\u000a                    // postMessage transport:\u000a                    options.dataType = 'postmessage ' + (options.dataType || '');\u000a                }\u000a            } else {\u000a                this._initIframeSettings(options, 'iframe');\u000a            }\u000a        },\u000a\u000a        _getParamName: function (options) {\u000a            var fileInput = $(options.fileInput),\u000a                paramName = options.paramName;\u000a            if (!paramName) {\u000a                paramName = [];\u000a                fileInput.each(function () {\u000a                    var input = $(this),\u000a                        name = input.prop('name') || 'files[]',\u000a                        i = (input.prop('files') || [1]).length;\u000a                    while (i) {\u000a                        paramName.push(name);\u000a                        i -= 1;\u000a                    }\u000a                });\u000a                if (!paramName.length) {\u000a                    paramName = [fileInput.prop('name') || 'files[]'];\u000a                }\u000a            } else if (!$.isArray(paramName)) {\u000a                paramName = [paramName];\u000a            }\u000a            return paramName;\u000a        },\u000a\u000a        _initFormSettings: function (options) {\u000a            // Retrieve missing options from the input field and the\u000a            // associated form, if available:\u000a            if (!options.form || !options.form.length) {\u000a                options.form = $(options.fileInput.prop('form'));\u000a                // If the given file input doesn't have an associated form,\u000a                // use the default widget file input's form:\u000a                if (!options.form.length) {\u000a                    options.form = $(this.options.fileInput.prop('form'));\u000a                }\u000a            }\u000a            options.paramName = this._getParamName(options);\u000a            if (!options.url) {\u000a                options.url = options.form.prop('action') || location.href;\u000a            }\u000a            // The HTTP request method must be "POST" or "PUT":\u000a            options.type = (options.type || options.form.prop('method') || '')\u000a                .toUpperCase();\u000a            if (options.type !== 'POST' && options.type !== 'PUT') {\u000a                options.type = 'POST';\u000a            }\u000a            if (!options.formAcceptCharset) {\u000a                options.formAcceptCharset = options.form.attr('accept-charset');\u000a            }\u000a        },\u000a\u000a        _getAJAXSettings: function (data) {\u000a            var options = $.extend({}, this.options, data);\u000a            this._initFormSettings(options);\u000a            this._initDataSettings(options);\u000a            return options;\u000a        },\u000a\u000a        // Maps jqXHR callbacks to the equivalent\u000a        // methods of the given Promise object:\u000a        _enhancePromise: function (promise) {\u000a            promise.success = promise.done;\u000a            promise.error = promise.fail;\u000a            promise.complete = promise.always;\u000a            return promise;\u000a        },\u000a\u000a        // Creates and returns a Promise object enhanced with\u000a        // the jqXHR methods abort, success, error and complete:\u000a        _getXHRPromise: function (resolveOrReject, context, args) {\u000a            var dfd = $.Deferred(),\u000a                promise = dfd.promise();\u000a            context = context || this.options.context || promise;\u000a            if (resolveOrReject === true) {\u000a                dfd.resolveWith(context, args);\u000a            } else if (resolveOrReject === false) {\u000a                dfd.rejectWith(context, args);\u000a            }\u000a            promise.abort = dfd.promise;\u000a            return this._enhancePromise(promise);\u000a        },\u000a\u000a        // Parses the Range header from the server response\u000a        // and returns the uploaded bytes:\u000a        _getUploadedBytes: function (jqXHR) {\u000a            var range = jqXHR.getResponseHeader('Range'),\u000a                parts = range && range.split('-'),\u000a                upperBytesPos = parts && parts.length > 1 &&\u000a                    parseInt(parts[1], 10);\u000a            return upperBytesPos && upperBytesPos + 1;\u000a        },\u000a\u000a        // Uploads a file in multiple, sequential requests\u000a        // by splitting the file up in multiple blob chunks.\u000a        // If the second parameter is true, only tests if the file\u000a        // should be uploaded in chunks, but does not invoke any\u000a        // upload requests:\u000a        _chunkedUpload: function (options, testOnly) {\u000a            var that = this,\u000a                file = options.files[0],\u000a                fs = file.size,\u000a                ub = options.uploadedBytes = options.uploadedBytes || 0,\u000a                mcs = options.maxChunkSize || fs,\u000a                slice = file.slice || file.webkitSlice || file.mozSlice,\u000a                dfd = $.Deferred(),\u000a                promise = dfd.promise(),\u000a                jqXHR,\u000a                upload;\u000a            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||\u000a                    options.data) {\u000a                return false;\u000a            }\u000a            if (testOnly) {\u000a                return true;\u000a            }\u000a            if (ub >= fs) {\u000a                file.error = 'Uploaded bytes exceed file size';\u000a                return this._getXHRPromise(\u000a                    false,\u000a                    options.context,\u000a                    [null, 'error', file.error]\u000a                );\u000a            }\u000a            // The chunk upload method:\u000a            upload = function (i) {\u000a                // Clone the options object for each chunk upload:\u000a                var o = $.extend({}, options);\u000a                o.blob = slice.call(\u000a                    file,\u000a                    ub,\u000a                    ub + mcs,\u000a                    file.type\u000a                );\u000a                // Store the current chunk size, as the blob itself\u000a                // will be dereferenced after data processing:\u000a                o.chunkSize = o.blob.size;\u000a                // Expose the chunk bytes position range:\u000a                o.contentRange = 'bytes ' + ub + '-' +\u000a                    (ub + o.chunkSize - 1) + '/' + fs;\u000a                // Process the upload data (the blob and potential form data):\u000a                that._initXHRData(o);\u000a                // Add progress listeners for this chunk upload:\u000a                that._initProgressListener(o);\u000a                jqXHR = ($.ajax(o) || that._getXHRPromise(false, o.context))\u000a                    .done(function (result, textStatus, jqXHR) {\u000a                        ub = that._getUploadedBytes(jqXHR) ||\u000a                            (ub + o.chunkSize);\u000a                        // Create a progress event if upload is done and\u000a                        // no progress event has been invoked for this chunk:\u000a                        if (!o.loaded) {\u000a                            that._onProgress($.Event('progress', {\u000a                                lengthComputable: true,\u000a                                loaded: ub - o.uploadedBytes,\u000a                                total: ub - o.uploadedBytes\u000a                            }), o);\u000a                        }\u000a                        options.uploadedBytes = o.uploadedBytes = ub;\u000a                        if (ub < fs) {\u000a                            // File upload not yet complete,\u000a                            // continue with the next chunk:\u000a                            upload();\u000a                        } else {\u000a                            dfd.resolveWith(\u000a                                o.context,\u000a                                [result, textStatus, jqXHR]\u000a                            );\u000a                        }\u000a                    })\u000a                    .fail(function (jqXHR, textStatus, errorThrown) {\u000a                        dfd.rejectWith(\u000a                            o.context,\u000a                            [jqXHR, textStatus, errorThrown]\u000a                        );\u000a                    });\u000a            };\u000a            this._enhancePromise(promise);\u000a            promise.abort = function () {\u000a                return jqXHR.abort();\u000a            };\u000a            upload();\u000a            return promise;\u000a        },\u000a\u000a        _beforeSend: function (e, data) {\u000a            if (this._active === 0) {\u000a                // the start callback is triggered when an upload starts\u000a                // and no other uploads are currently running,\u000a                // equivalent to the global ajaxStart event:\u000a                this._trigger('start');\u000a                // Set timer for global bitrate progress calculation:\u000a                this._bitrateTimer = new this._BitrateTimer();\u000a            }\u000a            this._active += 1;\u000a            // Initialize the global progress values:\u000a            this._loaded += data.uploadedBytes || 0;\u000a            this._total += this._getTotal(data.files);\u000a        },\u000a\u000a        _onDone: function (result, textStatus, jqXHR, options) {\u000a            if (!this._isXHRUpload(options)) {\u000a                // Create a progress event for each iframe load:\u000a                this._onProgress($.Event('progress', {\u000a                    lengthComputable: true,\u000a                    loaded: 1,\u000a                    total: 1\u000a                }), options);\u000a            }\u000a            options.result = result;\u000a            options.textStatus = textStatus;\u000a            options.jqXHR = jqXHR;\u000a            this._trigger('done', null, options);\u000a        },\u000a\u000a        _onFail: function (jqXHR, textStatus, errorThrown, options) {\u000a            options.jqXHR = jqXHR;\u000a            options.textStatus = textStatus;\u000a            options.errorThrown = errorThrown;\u000a            this._trigger('fail', null, options);\u000a            if (options.recalculateProgress) {\u000a                // Remove the failed (error or abort) file upload from\u000a                // the global progress calculation:\u000a                this._loaded -= options.loaded || options.uploadedBytes || 0;\u000a                this._total -= options.total || this._getTotal(options.files);\u000a            }\u000a        },\u000a\u000a        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\u000a            this._active -= 1;\u000a            options.textStatus = textStatus;\u000a            if (jqXHRorError && jqXHRorError.always) {\u000a                options.jqXHR = jqXHRorError;\u000a                options.result = jqXHRorResult;\u000a            } else {\u000a                options.jqXHR = jqXHRorResult;\u000a                options.errorThrown = jqXHRorError;\u000a            }\u000a            this._trigger('always', null, options);\u000a            if (this._active === 0) {\u000a                // The stop callback is triggered when all uploads have\u000a                // been completed, equivalent to the global ajaxStop event:\u000a                this._trigger('stop');\u000a                // Reset the global progress values:\u000a                this._loaded = this._total = 0;\u000a                this._bitrateTimer = null;\u000a            }\u000a        },\u000a\u000a        _onSend: function (e, data) {\u000a            var that = this,\u000a                jqXHR,\u000a                aborted,\u000a                slot,\u000a                pipe,\u000a                options = that._getAJAXSettings(data),\u000a                send = function () {\u000a                    that._sending += 1;\u000a                    // Set timer for bitrate progress calculation:\u000a                    options._bitrateTimer = new that._BitrateTimer();\u000a                    jqXHR = jqXHR || (\u000a                        ((aborted || that._trigger('send', e, options) === false) &&\u000a                        that._getXHRPromise(false, options.context, aborted)) ||\u000a                        that._chunkedUpload(options) || $.ajax(options)\u000a                    ).done(function (result, textStatus, jqXHR) {\u000a                        that._onDone(result, textStatus, jqXHR, options);\u000a                    }).fail(function (jqXHR, textStatus, errorThrown) {\u000a                        that._onFail(jqXHR, textStatus, errorThrown, options);\u000a                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {\u000a                        that._sending -= 1;\u000a                        that._onAlways(\u000a                            jqXHRorResult,\u000a                            textStatus,\u000a                            jqXHRorError,\u000a                            options\u000a                        );\u000a                        if (options.limitConcurrentUploads &&\u000a                                options.limitConcurrentUploads > that._sending) {\u000a                            // Start the next queued upload,\u000a                            // that has not been aborted:\u000a                            var nextSlot = that._slots.shift(),\u000a                                isPending;\u000a                            while (nextSlot) {\u000a                                // jQuery 1.6 doesn't provide .state(),\u000a                                // while jQuery 1.8+ removed .isRejected():\u000a                                isPending = nextSlot.state ?\u000a                                        nextSlot.state() === 'pending' :\u000a                                        !nextSlot.isRejected();\u000a                                if (isPending) {\u000a                                    nextSlot.resolve();\u000a                                    break;\u000a                                }\u000a                                nextSlot = that._slots.shift();\u000a                            }\u000a                        }\u000a                    });\u000a                    return jqXHR;\u000a                };\u000a            this._beforeSend(e, options);\u000a            if (this.options.sequentialUploads ||\u000a                    (this.options.limitConcurrentUploads &&\u000a                    this.options.limitConcurrentUploads <= this._sending)) {\u000a                if (this.options.limitConcurrentUploads > 1) {\u000a                    slot = $.Deferred();\u000a                    this._slots.push(slot);\u000a                    pipe = slot.pipe(send);\u000a                } else {\u000a                    pipe = (this._sequence = this._sequence.pipe(send, send));\u000a                }\u000a                // Return the piped Promise object, enhanced with an abort method,\u000a                // which is delegated to the jqXHR object of the current upload,\u000a                // and jqXHR callbacks mapped to the equivalent Promise methods:\u000a                pipe.abort = function () {\u000a                    aborted = [undefined, 'abort', 'abort'];\u000a                    if (!jqXHR) {\u000a                        if (slot) {\u000a                            slot.rejectWith(options.context, aborted);\u000a                        }\u000a                        return send();\u000a                    }\u000a                    return jqXHR.abort();\u000a                };\u000a                return this._enhancePromise(pipe);\u000a            }\u000a            return send();\u000a        },\u000a\u000a        _onAdd: function (e, data) {\u000a            var that = this,\u000a                result = true,\u000a                options = $.extend({}, this.options, data),\u000a                limit = options.limitMultiFileUploads,\u000a                paramName = this._getParamName(options),\u000a                paramNameSet,\u000a                paramNameSlice,\u000a                fileSet,\u000a                i;\u000a            if (!(options.singleFileUploads || limit) ||\u000a                    !this._isXHRUpload(options)) {\u000a                fileSet = [data.files];\u000a                paramNameSet = [paramName];\u000a            } else if (!options.singleFileUploads && limit) {\u000a                fileSet = [];\u000a                paramNameSet = [];\u000a                for (i = 0; i < data.files.length; i += limit) {\u000a                    fileSet.push(data.files.slice(i, i + limit));\u000a                    paramNameSlice = paramName.slice(i, i + limit);\u000a                    if (!paramNameSlice.length) {\u000a                        paramNameSlice = paramName;\u000a                    }\u000a                    paramNameSet.push(paramNameSlice);\u000a                }\u000a            } else {\u000a                paramNameSet = paramName;\u000a            }\u000a            data.originalFiles = data.files;\u000a            $.each(fileSet || data.files, function (index, element) {\u000a                var newData = $.extend({}, data);\u000a                newData.files = fileSet ? element : [element];\u000a                newData.paramName = paramNameSet[index];\u000a                newData.submit = function () {\u000a                    newData.jqXHR = this.jqXHR =\u000a                        (that._trigger('submit', e, this) !== false) &&\u000a                        that._onSend(e, this);\u000a                    return this.jqXHR;\u000a                };\u000a                result = that._trigger('add', e, newData);\u000a                return result;\u000a            });\u000a            return result;\u000a        },\u000a\u000a        _replaceFileInput: function (input) {\u000a            var inputClone = input.clone(true);\u000a            $('<form></form>').append(inputClone)[0].reset();\u000a            // Detaching allows to insert the fileInput on another form\u000a            // without loosing the file input value:\u000a            input.after(inputClone).detach();\u000a            // Avoid memory leaks with the detached file input:\u000a            $.cleanData(input.unbind('remove'));\u000a            // Replace the original file input element in the fileInput\u000a            // elements set with the clone, which has been copied including\u000a            // event handlers:\u000a            this.options.fileInput = this.options.fileInput.map(function (i, el) {\u000a                if (el === input[0]) {\u000a                    return inputClone[0];\u000a                }\u000a                return el;\u000a            });\u000a            // If the widget has been initialized on the file input itself,\u000a            // override this.element with the file input clone:\u000a            if (input[0] === this.element[0]) {\u000a                this.element = inputClone;\u000a            }\u000a        },\u000a\u000a        _handleFileTreeEntry: function (entry, path) {\u000a            var that = this,\u000a                dfd = $.Deferred(),\u000a                errorHandler = function (e) {\u000a                    if (e && !e.entry) {\u000a                        e.entry = entry;\u000a                    }\u000a                    // Since $.when returns immediately if one\u000a                    // Deferred is rejected, we use resolve instead.\u000a                    // This allows valid files and invalid items\u000a                    // to be returned together in one set:\u000a                    dfd.resolve([e]);\u000a                },\u000a                dirReader;\u000a            path = path || '';\u000a            if (entry.isFile) {\u000a                if (entry._file) {\u000a                    // Workaround for Chrome bug #149735\u000a                    entry._file.relativePath = path;\u000a                    dfd.resolve(entry._file);\u000a                } else {\u000a                    entry.file(function (file) {\u000a                        file.relativePath = path;\u000a                        dfd.resolve(file);\u000a                    }, errorHandler);\u000a                }\u000a            } else if (entry.isDirectory) {\u000a                dirReader = entry.createReader();\u000a                dirReader.readEntries(function (entries) {\u000a                    that._handleFileTreeEntries(\u000a                        entries,\u000a                        path + entry.name + '/'\u000a                    ).done(function (files) {\u000a                        dfd.resolve(files);\u000a                    }).fail(errorHandler);\u000a                }, errorHandler);\u000a            } else {\u000a                // Return an empy list for file system items\u000a                // other than files or directories:\u000a                dfd.resolve([]);\u000a            }\u000a            return dfd.promise();\u000a        },\u000a\u000a        _handleFileTreeEntries: function (entries, path) {\u000a            var that = this;\u000a            return $.when.apply(\u000a                $,\u000a                $.map(entries, function (entry) {\u000a                    return that._handleFileTreeEntry(entry, path);\u000a                })\u000a            ).pipe(function () {\u000a                return Array.prototype.concat.apply(\u000a                    [],\u000a                    arguments\u000a                );\u000a            });\u000a        },\u000a\u000a        _getDroppedFiles: function (dataTransfer) {\u000a            dataTransfer = dataTransfer || {};\u000a            var items = dataTransfer.items;\u000a            if (items && items.length && (items[0].webkitGetAsEntry ||\u000a                    items[0].getAsEntry)) {\u000a                return this._handleFileTreeEntries(\u000a                    $.map(items, function (item) {\u000a                        var entry;\u000a                        if (item.webkitGetAsEntry) {\u000a                            entry = item.webkitGetAsEntry();\u000a                            if (entry) {\u000a                                // Workaround for Chrome bug #149735:\u000a                                entry._file = item.getAsFile();\u000a                            }\u000a                            return entry;\u000a                        }\u000a                        return item.getAsEntry();\u000a                    })\u000a                );\u000a            }\u000a            return $.Deferred().resolve(\u000a                $.makeArray(dataTransfer.files)\u000a            ).promise();\u000a        },\u000a\u000a        _getSingleFileInputFiles: function (fileInput) {\u000a            fileInput = $(fileInput);\u000a            var entries = fileInput.prop('webkitEntries') ||\u000a                    fileInput.prop('entries'),\u000a                files,\u000a                value;\u000a            if (entries && entries.length) {\u000a                return this._handleFileTreeEntries(entries);\u000a            }\u000a            files = $.makeArray(fileInput.prop('files'));\u000a            if (!files.length) {\u000a                value = fileInput.prop('value');\u000a                if (!value) {\u000a                    return $.Deferred().resolve([]).promise();\u000a                }\u000a                // If the files property is not available, the browser does not\u000a                // support the File API and we add a pseudo File object with\u000a                // the input value as name with path information removed:\u000a                files = [{name: value.replace(/^.*\u005c\u005c/, '')}];\u000a            } else if (files[0].name === undefined && files[0].fileName) {\u000a                // File normalization for Safari 4 and Firefox 3:\u000a                $.each(files, function (index, file) {\u000a                    file.name = file.fileName;\u000a                    file.size = file.fileSize;\u000a                });\u000a            }\u000a            return $.Deferred().resolve(files).promise();\u000a        },\u000a\u000a        _getFileInputFiles: function (fileInput) {\u000a            if (!(fileInput instanceof $) || fileInput.length === 1) {\u000a                return this._getSingleFileInputFiles(fileInput);\u000a            }\u000a            return $.when.apply(\u000a                $,\u000a                $.map(fileInput, this._getSingleFileInputFiles)\u000a            ).pipe(function () {\u000a                return Array.prototype.concat.apply(\u000a                    [],\u000a                    arguments\u000a                );\u000a            });\u000a        },\u000a\u000a        _onChange: function (e) {\u000a            var that = this,\u000a                data = {\u000a                    fileInput: $(e.target),\u000a                    form: $(e.target.form)\u000a                };\u000a            this._getFileInputFiles(data.fileInput).always(function (files) {\u000a                data.files = files;\u000a                if (that.options.replaceFileInput) {\u000a                    that._replaceFileInput(data.fileInput);\u000a                }\u000a                if (that._trigger('change', e, data) !== false) {\u000a                    that._onAdd(e, data);\u000a                }\u000a            });\u000a        },\u000a\u000a        _onPaste: function (e) {\u000a            var cbd = e.originalEvent.clipboardData,\u000a                items = (cbd && cbd.items) || [],\u000a                data = {files: []};\u000a            $.each(items, function (index, item) {\u000a                var file = item.getAsFile && item.getAsFile();\u000a                if (file) {\u000a                    data.files.push(file);\u000a                }\u000a            });\u000a            if (this._trigger('paste', e, data) === false ||\u000a                    this._onAdd(e, data) === false) {\u000a                return false;\u000a            }\u000a        },\u000a\u000a        _onDrop: function (e) {\u000a            var that = this,\u000a                dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer,\u000a                data = {};\u000a            if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\u000a                e.preventDefault();\u000a            }\u000a            this._getDroppedFiles(dataTransfer).always(function (files) {\u000a                data.files = files;\u000a                if (that._trigger('drop', e, data) !== false) {\u000a                    that._onAdd(e, data);\u000a                }\u000a            });\u000a        },\u000a\u000a        _onDragOver: function (e) {\u000a            var dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer;\u000a            if (this._trigger('dragover', e) === false) {\u000a                return false;\u000a            }\u000a            if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1) {\u000a                dataTransfer.dropEffect = 'copy';\u000a                e.preventDefault();\u000a            }\u000a        },\u000a\u000a        _initEventHandlers: function () {\u000a            if (this._isXHRUpload(this.options)) {\u000a                this._on(this.options.dropZone, {\u000a                    dragover: this._onDragOver,\u000a                    drop: this._onDrop\u000a                });\u000a                this._on(this.options.pasteZone, {\u000a                    paste: this._onPaste\u000a                });\u000a            }\u000a            this._on(this.options.fileInput, {\u000a                change: this._onChange\u000a            });\u000a        },\u000a\u000a        _destroyEventHandlers: function () {\u000a            this._off(this.options.dropZone, 'dragover drop');\u000a            this._off(this.options.pasteZone, 'paste');\u000a            this._off(this.options.fileInput, 'change');\u000a        },\u000a\u000a        _setOption: function (key, value) {\u000a            var refresh = $.inArray(key, this._refreshOptionsList) !== -1;\u000a            if (refresh) {\u000a                this._destroyEventHandlers();\u000a            }\u000a            this._super(key, value);\u000a            if (refresh) {\u000a                this._initSpecialOptions();\u000a                this._initEventHandlers();\u000a            }\u000a        },\u000a\u000a        _initSpecialOptions: function () {\u000a            var options = this.options;\u000a            if (options.fileInput === undefined) {\u000a                options.fileInput = this.element.is('input[type="file"]') ?\u000a                        this.element : this.element.find('input[type="file"]');\u000a            } else if (!(options.fileInput instanceof $)) {\u000a                options.fileInput = $(options.fileInput);\u000a            }\u000a            if (!(options.dropZone instanceof $)) {\u000a                options.dropZone = $(options.dropZone);\u000a            }\u000a            if (!(options.pasteZone instanceof $)) {\u000a                options.pasteZone = $(options.pasteZone);\u000a            }\u000a        },\u000a\u000a        _create: function () {\u000a            var options = this.options;\u000a            // Initialize options set via HTML5 data-attributes:\u000a            $.extend(options, $(this.element[0].cloneNode(false)).data());\u000a            this._initSpecialOptions();\u000a            this._slots = [];\u000a            this._sequence = this._getXHRPromise(true);\u000a            this._sending = this._active = this._loaded = this._total = 0;\u000a            this._initEventHandlers();\u000a        },\u000a\u000a        _destroy: function () {\u000a            this._destroyEventHandlers();\u000a        },\u000a\u000a        // This method is exposed to the widget API and allows adding files\u000a        // using the fileupload API. The data parameter accepts an object which\u000a        // must have a files property and can contain additional options:\u000a        // .fileupload('add', {files: filesList});\u000a        add: function (data) {\u000a            var that = this;\u000a            if (!data || this.options.disabled) {\u000a                return;\u000a            }\u000a            if (data.fileInput && !data.files) {\u000a                this._getFileInputFiles(data.fileInput).always(function (files) {\u000a                    data.files = files;\u000a                    that._onAdd(null, data);\u000a                });\u000a            } else {\u000a                data.files = $.makeArray(data.files);\u000a                this._onAdd(null, data);\u000a            }\u000a        },\u000a\u000a        // This method is exposed to the widget API and allows sending files\u000a        // using the fileupload API. The data parameter accepts an object which\u000a        // must have a files or fileInput property and can contain additional options:\u000a        // .fileupload('send', {files: filesList});\u000a        // The method returns a Promise object for the file upload call.\u000a        send: function (data) {\u000a            if (data && !this.options.disabled) {\u000a                if (data.fileInput && !data.files) {\u000a                    var that = this,\u000a                        dfd = $.Deferred(),\u000a                        promise = dfd.promise(),\u000a                        jqXHR,\u000a                        aborted;\u000a                    promise.abort = function () {\u000a                        aborted = true;\u000a                        if (jqXHR) {\u000a                            return jqXHR.abort();\u000a                        }\u000a                        dfd.reject(null, 'abort', 'abort');\u000a                        return promise;\u000a                    };\u000a                    this._getFileInputFiles(data.fileInput).always(\u000a                        function (files) {\u000a                            if (aborted) {\u000a                                return;\u000a                            }\u000a                            data.files = files;\u000a                            jqXHR = that._onSend(null, data).then(\u000a                                function (result, textStatus, jqXHR) {\u000a                                    dfd.resolve(result, textStatus, jqXHR);\u000a                                },\u000a                                function (jqXHR, textStatus, errorThrown) {\u000a                                    dfd.reject(jqXHR, textStatus, errorThrown);\u000a                                }\u000a                            );\u000a                        }\u000a                    );\u000a                    return this._enhancePromise(promise);\u000a                }\u000a                data.files = $.makeArray(data.files);\u000a                if (data.files.length) {\u000a                    return this._onSend(null, data);\u000a                }\u000a            }\u000a            return this._getXHRPromise(false, data && data.context);\u000a        }\u000a\u000a    });\u000a\u000a}));\u000a\u000a;\u000a
p0
.