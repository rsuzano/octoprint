V// source: js/lib/sockjs.js\u000a/* sockjs-client v1.1.2 | http://sockjs.org | MIT license */\u000a(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SockJS = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000avar transportList = require('./transport-list');\u000a\u000amodule.exports = require('./main')(transportList);\u000a\u000a// TODO can't get rid of this until all servers do\u000aif ('_sockjs_onload' in global) {\u000a  setTimeout(global._sockjs_onload, 1);\u000a}\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , Event = require('./event')\u000a  ;\u000a\u000afunction CloseEvent() {\u000a  Event.call(this);\u000a  this.initEvent('close', false, false);\u000a  this.wasClean = false;\u000a  this.code = 0;\u000a  this.reason = '';\u000a}\u000a\u000ainherits(CloseEvent, Event);\u000a\u000amodule.exports = CloseEvent;\u000a\u000a},{"./event":4,"inherits":56}],3:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , EventTarget = require('./eventtarget')\u000a  ;\u000a\u000afunction EventEmitter() {\u000a  EventTarget.call(this);\u000a}\u000a\u000ainherits(EventEmitter, EventTarget);\u000a\u000aEventEmitter.prototype.removeAllListeners = function(type) {\u000a  if (type) {\u000a    delete this._listeners[type];\u000a  } else {\u000a    this._listeners = {};\u000a  }\u000a};\u000a\u000aEventEmitter.prototype.once = function(type, listener) {\u000a  var self = this\u000a    , fired = false;\u000a\u000a  function g() {\u000a    self.removeListener(type, g);\u000a\u000a    if (!fired) {\u000a      fired = true;\u000a      listener.apply(this, arguments);\u000a    }\u000a  }\u000a\u000a  this.on(type, g);\u000a};\u000a\u000aEventEmitter.prototype.emit = function() {\u000a  var type = arguments[0];\u000a  var listeners = this._listeners[type];\u000a  if (!listeners) {\u000a    return;\u000a  }\u000a  // equivalent of Array.prototype.slice.call(arguments, 1);\u000a  var l = arguments.length;\u000a  var args = new Array(l - 1);\u000a  for (var ai = 1; ai < l; ai++) {\u000a    args[ai - 1] = arguments[ai];\u000a  }\u000a  for (var i = 0; i < listeners.length; i++) {\u000a    listeners[i].apply(this, args);\u000a  }\u000a};\u000a\u000aEventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;\u000aEventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;\u000a\u000amodule.exports.EventEmitter = EventEmitter;\u000a\u000a},{"./eventtarget":5,"inherits":56}],4:[function(require,module,exports){\u000a'use strict';\u000a\u000afunction Event(eventType) {\u000a  this.type = eventType;\u000a}\u000a\u000aEvent.prototype.initEvent = function(eventType, canBubble, cancelable) {\u000a  this.type = eventType;\u000a  this.bubbles = canBubble;\u000a  this.cancelable = cancelable;\u000a  this.timeStamp = +new Date();\u000a  return this;\u000a};\u000a\u000aEvent.prototype.stopPropagation = function() {};\u000aEvent.prototype.preventDefault = function() {};\u000a\u000aEvent.CAPTURING_PHASE = 1;\u000aEvent.AT_TARGET = 2;\u000aEvent.BUBBLING_PHASE = 3;\u000a\u000amodule.exports = Event;\u000a\u000a},{}],5:[function(require,module,exports){\u000a'use strict';\u000a\u000a/* Simplified implementation of DOM2 EventTarget.\u000a *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\u000a */\u000a\u000afunction EventTarget() {\u000a  this._listeners = {};\u000a}\u000a\u000aEventTarget.prototype.addEventListener = function(eventType, listener) {\u000a  if (!(eventType in this._listeners)) {\u000a    this._listeners[eventType] = [];\u000a  }\u000a  var arr = this._listeners[eventType];\u000a  // #4\u000a  if (arr.indexOf(listener) === -1) {\u000a    // Make a copy so as not to interfere with a current dispatchEvent.\u000a    arr = arr.concat([listener]);\u000a  }\u000a  this._listeners[eventType] = arr;\u000a};\u000a\u000aEventTarget.prototype.removeEventListener = function(eventType, listener) {\u000a  var arr = this._listeners[eventType];\u000a  if (!arr) {\u000a    return;\u000a  }\u000a  var idx = arr.indexOf(listener);\u000a  if (idx !== -1) {\u000a    if (arr.length > 1) {\u000a      // Make a copy so as not to interfere with a current dispatchEvent.\u000a      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));\u000a    } else {\u000a      delete this._listeners[eventType];\u000a    }\u000a    return;\u000a  }\u000a};\u000a\u000aEventTarget.prototype.dispatchEvent = function() {\u000a  var event = arguments[0];\u000a  var t = event.type;\u000a  // equivalent of Array.prototype.slice.call(arguments, 0);\u000a  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);\u000a  // TODO: This doesn't match the real behavior; per spec, onfoo get\u000a  // their place in line from the /first/ time they're set from\u000a  // non-null. Although WebKit bumps it to the end every time it's\u000a  // set.\u000a  if (this['on' + t]) {\u000a    this['on' + t].apply(this, args);\u000a  }\u000a  if (t in this._listeners) {\u000a    // Grab a reference to the listeners list. removeEventListener may alter the list.\u000a    var listeners = this._listeners[t];\u000a    for (var i = 0; i < listeners.length; i++) {\u000a      listeners[i].apply(this, args);\u000a    }\u000a  }\u000a};\u000a\u000amodule.exports = EventTarget;\u000a\u000a},{}],6:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , Event = require('./event')\u000a  ;\u000a\u000afunction TransportMessageEvent(data) {\u000a  Event.call(this);\u000a  this.initEvent('message', false, false);\u000a  this.data = data;\u000a}\u000a\u000ainherits(TransportMessageEvent, Event);\u000a\u000amodule.exports = TransportMessageEvent;\u000a\u000a},{"./event":4,"inherits":56}],7:[function(require,module,exports){\u000a'use strict';\u000a\u000avar JSON3 = require('json3')\u000a  , iframeUtils = require('./utils/iframe')\u000a  ;\u000a\u000afunction FacadeJS(transport) {\u000a  this._transport = transport;\u000a  transport.on('message', this._transportMessage.bind(this));\u000a  transport.on('close', this._transportClose.bind(this));\u000a}\u000a\u000aFacadeJS.prototype._transportClose = function(code, reason) {\u000a  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));\u000a};\u000aFacadeJS.prototype._transportMessage = function(frame) {\u000a  iframeUtils.postMessage('t', frame);\u000a};\u000aFacadeJS.prototype._send = function(data) {\u000a  this._transport.send(data);\u000a};\u000aFacadeJS.prototype._close = function() {\u000a  this._transport.close();\u000a  this._transport.removeAllListeners();\u000a};\u000a\u000amodule.exports = FacadeJS;\u000a\u000a},{"./utils/iframe":47,"json3":57}],8:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar urlUtils = require('./utils/url')\u000a  , eventUtils = require('./utils/event')\u000a  , JSON3 = require('json3')\u000a  , FacadeJS = require('./facade')\u000a  , InfoIframeReceiver = require('./info-iframe-receiver')\u000a  , iframeUtils = require('./utils/iframe')\u000a  , loc = require('./location')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:iframe-bootstrap');\u000a}\u000a\u000amodule.exports = function(SockJS, availableTransports) {\u000a  var transportMap = {};\u000a  availableTransports.forEach(function(at) {\u000a    if (at.facadeTransport) {\u000a      transportMap[at.facadeTransport.transportName] = at.facadeTransport;\u000a    }\u000a  });\u000a\u000a  // hard-coded for the info iframe\u000a  // TODO see if we can make this more dynamic\u000a  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;\u000a  var parentOrigin;\u000a\u000a  /* eslint-disable camelcase */\u000a  SockJS.bootstrap_iframe = function() {\u000a    /* eslint-enable camelcase */\u000a    var facade;\u000a    iframeUtils.currentWindowId = loc.hash.slice(1);\u000a    var onMessage = function(e) {\u000a      if (e.source !== parent) {\u000a        return;\u000a      }\u000a      if (typeof parentOrigin === 'undefined') {\u000a        parentOrigin = e.origin;\u000a      }\u000a      if (e.origin !== parentOrigin) {\u000a        return;\u000a      }\u000a\u000a      var iframeMessage;\u000a      try {\u000a        iframeMessage = JSON3.parse(e.data);\u000a      } catch (ignored) {\u000a        debug('bad json', e.data);\u000a        return;\u000a      }\u000a\u000a      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {\u000a        return;\u000a      }\u000a      switch (iframeMessage.type) {\u000a      case 's':\u000a        var p;\u000a        try {\u000a          p = JSON3.parse(iframeMessage.data);\u000a        } catch (ignored) {\u000a          debug('bad json', iframeMessage.data);\u000a          break;\u000a        }\u000a        var version = p[0];\u000a        var transport = p[1];\u000a        var transUrl = p[2];\u000a        var baseUrl = p[3];\u000a        debug(version, transport, transUrl, baseUrl);\u000a        // change this to semver logic\u000a        if (version !== SockJS.version) {\u000a          throw new Error('Incompatible SockJS! Main site uses:' +\u000a                    ' "' + version + '", the iframe:' +\u000a                    ' "' + SockJS.version + '".');\u000a        }\u000a\u000a        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||\u000a            !urlUtils.isOriginEqual(baseUrl, loc.href)) {\u000a          throw new Error('Can\u005c't connect to different domain from within an ' +\u000a                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');\u000a        }\u000a        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));\u000a        break;\u000a      case 'm':\u000a        facade._send(iframeMessage.data);\u000a        break;\u000a      case 'c':\u000a        if (facade) {\u000a          facade._close();\u000a        }\u000a        facade = null;\u000a        break;\u000a      }\u000a    };\u000a\u000a    eventUtils.attachEvent('message', onMessage);\u000a\u000a    // Start\u000a    iframeUtils.postMessage('s');\u000a  };\u000a};\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":54,"json3":57}],9:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar EventEmitter = require('events').EventEmitter\u000a  , inherits = require('inherits')\u000a  , JSON3 = require('json3')\u000a  , objectUtils = require('./utils/object')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:info-ajax');\u000a}\u000a\u000afunction InfoAjax(url, AjaxObject) {\u000a  EventEmitter.call(this);\u000a\u000a  var self = this;\u000a  var t0 = +new Date();\u000a  this.xo = new AjaxObject('GET', url);\u000a\u000a  this.xo.once('finish', function(status, text) {\u000a    var info, rtt;\u000a    if (status === 200) {\u000a      rtt = (+new Date()) - t0;\u000a      if (text) {\u000a        try {\u000a          info = JSON3.parse(text);\u000a        } catch (e) {\u000a          debug('bad json', text);\u000a        }\u000a      }\u000a\u000a      if (!objectUtils.isObject(info)) {\u000a        info = {};\u000a      }\u000a    }\u000a    self.emit('finish', info, rtt);\u000a    self.removeAllListeners();\u000a  });\u000a}\u000a\u000ainherits(InfoAjax, EventEmitter);\u000a\u000aInfoAjax.prototype.close = function() {\u000a  this.removeAllListeners();\u000a  this.xo.close();\u000a};\u000a\u000amodule.exports = InfoAjax;\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"./utils/object":49,"debug":54,"events":3,"inherits":56,"json3":57}],10:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , EventEmitter = require('events').EventEmitter\u000a  , JSON3 = require('json3')\u000a  , XHRLocalObject = require('./transport/sender/xhr-local')\u000a  , InfoAjax = require('./info-ajax')\u000a  ;\u000a\u000afunction InfoReceiverIframe(transUrl) {\u000a  var self = this;\u000a  EventEmitter.call(this);\u000a\u000a  this.ir = new InfoAjax(transUrl, XHRLocalObject);\u000a  this.ir.once('finish', function(info, rtt) {\u000a    self.ir = null;\u000a    self.emit('message', JSON3.stringify([info, rtt]));\u000a  });\u000a}\u000a\u000ainherits(InfoReceiverIframe, EventEmitter);\u000a\u000aInfoReceiverIframe.transportName = 'iframe-info-receiver';\u000a\u000aInfoReceiverIframe.prototype.close = function() {\u000a  if (this.ir) {\u000a    this.ir.close();\u000a    this.ir = null;\u000a  }\u000a  this.removeAllListeners();\u000a};\u000a\u000amodule.exports = InfoReceiverIframe;\u000a\u000a},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":56,"json3":57}],11:[function(require,module,exports){\u000a(function (process,global){\u000a'use strict';\u000a\u000avar EventEmitter = require('events').EventEmitter\u000a  , inherits = require('inherits')\u000a  , JSON3 = require('json3')\u000a  , utils = require('./utils/event')\u000a  , IframeTransport = require('./transport/iframe')\u000a  , InfoReceiverIframe = require('./info-iframe-receiver')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:info-iframe');\u000a}\u000a\u000afunction InfoIframe(baseUrl, url) {\u000a  var self = this;\u000a  EventEmitter.call(this);\u000a\u000a  var go = function() {\u000a    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);\u000a\u000a    ifr.once('message', function(msg) {\u000a      if (msg) {\u000a        var d;\u000a        try {\u000a          d = JSON3.parse(msg);\u000a        } catch (e) {\u000a          debug('bad json', msg);\u000a          self.emit('finish');\u000a          self.close();\u000a          return;\u000a        }\u000a\u000a        var info = d[0], rtt = d[1];\u000a        self.emit('finish', info, rtt);\u000a      }\u000a      self.close();\u000a    });\u000a\u000a    ifr.once('close', function() {\u000a      self.emit('finish');\u000a      self.close();\u000a    });\u000a  };\u000a\u000a  // TODO this seems the same as the 'needBody' from transports\u000a  if (!global.document.body) {\u000a    utils.attachEvent('load', go);\u000a  } else {\u000a    go();\u000a  }\u000a}\u000a\u000ainherits(InfoIframe, EventEmitter);\u000a\u000aInfoIframe.enabled = function() {\u000a  return IframeTransport.enabled();\u000a};\u000a\u000aInfoIframe.prototype.close = function() {\u000a  if (this.ifr) {\u000a    this.ifr.close();\u000a  }\u000a  this.removeAllListeners();\u000a  this.ifr = null;\u000a};\u000a\u000amodule.exports = InfoIframe;\u000a\u000a}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":54,"events":3,"inherits":56,"json3":57}],12:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar EventEmitter = require('events').EventEmitter\u000a  , inherits = require('inherits')\u000a  , urlUtils = require('./utils/url')\u000a  , XDR = require('./transport/sender/xdr')\u000a  , XHRCors = require('./transport/sender/xhr-cors')\u000a  , XHRLocal = require('./transport/sender/xhr-local')\u000a  , XHRFake = require('./transport/sender/xhr-fake')\u000a  , InfoIframe = require('./info-iframe')\u000a  , InfoAjax = require('./info-ajax')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:info-receiver');\u000a}\u000a\u000afunction InfoReceiver(baseUrl, urlInfo) {\u000a  debug(baseUrl);\u000a  var self = this;\u000a  EventEmitter.call(this);\u000a\u000a  setTimeout(function() {\u000a    self.doXhr(baseUrl, urlInfo);\u000a  }, 0);\u000a}\u000a\u000ainherits(InfoReceiver, EventEmitter);\u000a\u000a// TODO this is currently ignoring the list of available transports and the whitelist\u000a\u000aInfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {\u000a  // determine method of CORS support (if needed)\u000a  if (urlInfo.sameOrigin) {\u000a    return new InfoAjax(url, XHRLocal);\u000a  }\u000a  if (XHRCors.enabled) {\u000a    return new InfoAjax(url, XHRCors);\u000a  }\u000a  if (XDR.enabled && urlInfo.sameScheme) {\u000a    return new InfoAjax(url, XDR);\u000a  }\u000a  if (InfoIframe.enabled()) {\u000a    return new InfoIframe(baseUrl, url);\u000a  }\u000a  return new InfoAjax(url, XHRFake);\u000a};\u000a\u000aInfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {\u000a  var self = this\u000a    , url = urlUtils.addPath(baseUrl, '/info')\u000a    ;\u000a  debug('doXhr', url);\u000a\u000a  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);\u000a\u000a  this.timeoutRef = setTimeout(function() {\u000a    debug('timeout');\u000a    self._cleanup(false);\u000a    self.emit('finish');\u000a  }, InfoReceiver.timeout);\u000a\u000a  this.xo.once('finish', function(info, rtt) {\u000a    debug('finish', info, rtt);\u000a    self._cleanup(true);\u000a    self.emit('finish', info, rtt);\u000a  });\u000a};\u000a\u000aInfoReceiver.prototype._cleanup = function(wasClean) {\u000a  debug('_cleanup');\u000a  clearTimeout(this.timeoutRef);\u000a  this.timeoutRef = null;\u000a  if (!wasClean && this.xo) {\u000a    this.xo.close();\u000a  }\u000a  this.xo = null;\u000a};\u000a\u000aInfoReceiver.prototype.close = function() {\u000a  debug('close');\u000a  this.removeAllListeners();\u000a  this._cleanup(false);\u000a};\u000a\u000aInfoReceiver.timeout = 8000;\u000a\u000amodule.exports = InfoReceiver;\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":54,"events":3,"inherits":56}],13:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000amodule.exports = global.location || {\u000a  origin: 'http://localhost:80'\u000a, protocol: 'http'\u000a, host: 'localhost'\u000a, port: 80\u000a, href: 'http://localhost/'\u000a, hash: ''\u000a};\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{}],14:[function(require,module,exports){\u000a(function (process,global){\u000a'use strict';\u000a\u000arequire('./shims');\u000a\u000avar URL = require('url-parse')\u000a  , inherits = require('inherits')\u000a  , JSON3 = require('json3')\u000a  , random = require('./utils/random')\u000a  , escape = require('./utils/escape')\u000a  , urlUtils = require('./utils/url')\u000a  , eventUtils = require('./utils/event')\u000a  , transport = require('./utils/transport')\u000a  , objectUtils = require('./utils/object')\u000a  , browser = require('./utils/browser')\u000a  , log = require('./utils/log')\u000a  , Event = require('./event/event')\u000a  , EventTarget = require('./event/eventtarget')\u000a  , loc = require('./location')\u000a  , CloseEvent = require('./event/close')\u000a  , TransportMessageEvent = require('./event/trans-message')\u000a  , InfoReceiver = require('./info-receiver')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:main');\u000a}\u000a\u000avar transports;\u000a\u000a// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface\u000afunction SockJS(url, protocols, options) {\u000a  if (!(this instanceof SockJS)) {\u000a    return new SockJS(url, protocols, options);\u000a  }\u000a  if (arguments.length < 1) {\u000a    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");\u000a  }\u000a  EventTarget.call(this);\u000a\u000a  this.readyState = SockJS.CONNECTING;\u000a  this.extensions = '';\u000a  this.protocol = '';\u000a\u000a  // non-standard extension\u000a  options = options || {};\u000a  if (options.protocols_whitelist) {\u000a    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");\u000a  }\u000a  this._transportsWhitelist = options.transports;\u000a  this._transportOptions = options.transportOptions || {};\u000a\u000a  var sessionId = options.sessionId || 8;\u000a  if (typeof sessionId === 'function') {\u000a    this._generateSessionId = sessionId;\u000a  } else if (typeof sessionId === 'number') {\u000a    this._generateSessionId = function() {\u000a      return random.string(sessionId);\u000a    };\u000a  } else {\u000a    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');\u000a  }\u000a\u000a  this._server = options.server || random.numberString(1000);\u000a\u000a  // Step 1 of WS spec - parse and validate the url. Issue #8\u000a  var parsedUrl = new URL(url);\u000a  if (!parsedUrl.host || !parsedUrl.protocol) {\u000a    throw new SyntaxError("The URL '" + url + "' is invalid");\u000a  } else if (parsedUrl.hash) {\u000a    throw new SyntaxError('The URL must not contain a fragment');\u000a  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\u000a    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");\u000a  }\u000a\u000a  var secure = parsedUrl.protocol === 'https:';\u000a  // Step 2 - don't allow secure origin with an insecure protocol\u000a  if (loc.protocol === 'https' && !secure) {\u000a    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');\u000a  }\u000a\u000a  // Step 3 - check port access - no need here\u000a  // Step 4 - parse protocols argument\u000a  if (!protocols) {\u000a    protocols = [];\u000a  } else if (!Array.isArray(protocols)) {\u000a    protocols = [protocols];\u000a  }\u000a\u000a  // Step 5 - check protocols argument\u000a  var sortedProtocols = protocols.sort();\u000a  sortedProtocols.forEach(function(proto, i) {\u000a    if (!proto) {\u000a      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");\u000a    }\u000a    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {\u000a      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");\u000a    }\u000a  });\u000a\u000a  // Step 6 - convert origin\u000a  var o = urlUtils.getOrigin(loc.href);\u000a  this._origin = o ? o.toLowerCase() : null;\u000a\u000a  // remove the trailing slash\u000a  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\u005c/+$/, ''));\u000a\u000a  // store the sanitized url\u000a  this.url = parsedUrl.href;\u000a  debug('using url', this.url);\u000a\u000a  // Step 7 - start connection in background\u000a  // obtain server info\u000a  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26\u000a  this._urlInfo = {\u000a    nullOrigin: !browser.hasDomain()\u000a  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)\u000a  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)\u000a  };\u000a\u000a  this._ir = new InfoReceiver(this.url, this._urlInfo);\u000a  this._ir.once('finish', this._receiveInfo.bind(this));\u000a}\u000a\u000ainherits(SockJS, EventTarget);\u000a\u000afunction userSetCode(code) {\u000a  return code === 1000 || (code >= 3000 && code <= 4999);\u000a}\u000a\u000aSockJS.prototype.close = function(code, reason) {\u000a  // Step 1\u000a  if (code && !userSetCode(code)) {\u000a    throw new Error('InvalidAccessError: Invalid code');\u000a  }\u000a  // Step 2.4 states the max is 123 bytes, but we are just checking length\u000a  if (reason && reason.length > 123) {\u000a    throw new SyntaxError('reason argument has an invalid length');\u000a  }\u000a\u000a  // Step 3.1\u000a  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {\u000a    return;\u000a  }\u000a\u000a  // TODO look at docs to determine how to set this\u000a  var wasClean = true;\u000a  this._close(code || 1000, reason || 'Normal closure', wasClean);\u000a};\u000a\u000aSockJS.prototype.send = function(data) {\u000a  // #13 - convert anything non-string to string\u000a  // TODO this currently turns objects into [object Object]\u000a  if (typeof data !== 'string') {\u000a    data = '' + data;\u000a  }\u000a  if (this.readyState === SockJS.CONNECTING) {\u000a    throw new Error('InvalidStateError: The connection has not been established yet');\u000a  }\u000a  if (this.readyState !== SockJS.OPEN) {\u000a    return;\u000a  }\u000a  this._transport.send(escape.quote(data));\u000a};\u000a\u000aSockJS.version = require('./version');\u000a\u000aSockJS.CONNECTING = 0;\u000aSockJS.OPEN = 1;\u000aSockJS.CLOSING = 2;\u000aSockJS.CLOSED = 3;\u000a\u000aSockJS.prototype._receiveInfo = function(info, rtt) {\u000a  debug('_receiveInfo', rtt);\u000a  this._ir = null;\u000a  if (!info) {\u000a    this._close(1002, 'Cannot connect to server');\u000a    return;\u000a  }\u000a\u000a  // establish a round-trip timeout (RTO) based on the\u000a  // round-trip time (RTT)\u000a  this._rto = this.countRTO(rtt);\u000a  // allow server to override url used for the actual transport\u000a  this._transUrl = info.base_url ? info.base_url : this.url;\u000a  info = objectUtils.extend(info, this._urlInfo);\u000a  debug('info', info);\u000a  // determine list of desired and supported transports\u000a  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);\u000a  this._transports = enabledTransports.main;\u000a  debug(this._transports.length + ' enabled transports');\u000a\u000a  this._connect();\u000a};\u000a\u000aSockJS.prototype._connect = function() {\u000a  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {\u000a    debug('attempt', Transport.transportName);\u000a    if (Transport.needBody) {\u000a      if (!global.document.body ||\u000a          (typeof global.document.readyState !== 'undefined' &&\u000a            global.document.readyState !== 'complete' &&\u000a            global.document.readyState !== 'interactive')) {\u000a        debug('waiting for body');\u000a        this._transports.unshift(Transport);\u000a        eventUtils.attachEvent('load', this._connect.bind(this));\u000a        return;\u000a      }\u000a    }\u000a\u000a    // calculate timeout based on RTO and round trips, compensate for potential nagle. Default to 5s.\u000a    var timeoutMs = (this._rto * Transport.roundTrips + 300) || 5000;\u000a    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);\u000a    debug('using timeout', timeoutMs);\u000a\u000a    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());\u000a    var options = this._transportOptions[Transport.transportName];\u000a    debug('transport url', transportUrl);\u000a    var transportObj = new Transport(transportUrl, this._transUrl, options);\u000a    transportObj.on('message', this._transportMessage.bind(this));\u000a    transportObj.once('close', this._transportClose.bind(this));\u000a    transportObj.transportName = Transport.transportName;\u000a    this._transport = transportObj;\u000a\u000a    return;\u000a  }\u000a  this._close(2000, 'All transports failed', false);\u000a};\u000a\u000aSockJS.prototype._transportTimeout = function() {\u000a  debug('_transportTimeout');\u000a  if (this.readyState === SockJS.CONNECTING) {\u000a    this._transportClose(2007, 'Transport timed out');\u000a  }\u000a};\u000a\u000aSockJS.prototype._transportMessage = function(msg) {\u000a  debug('_transportMessage', msg);\u000a  var self = this\u000a    , type = msg.slice(0, 1)\u000a    , content = msg.slice(1)\u000a    , payload\u000a    ;\u000a\u000a  // first check for messages that don't need a payload\u000a  switch (type) {\u000a    case 'o':\u000a      this._open();\u000a      return;\u000a    case 'h':\u000a      this.dispatchEvent(new Event('heartbeat'));\u000a      debug('heartbeat', this.transport);\u000a      return;\u000a  }\u000a\u000a  if (content) {\u000a    try {\u000a      payload = JSON3.parse(content);\u000a    } catch (e) {\u000a      debug('bad json', content);\u000a    }\u000a  }\u000a\u000a  if (typeof payload === 'undefined') {\u000a    debug('empty payload', content);\u000a    return;\u000a  }\u000a\u000a  switch (type) {\u000a    case 'a':\u000a      if (Array.isArray(payload)) {\u000a        payload.forEach(function(p) {\u000a          debug('message', self.transport, p);\u000a          self.dispatchEvent(new TransportMessageEvent(p));\u000a        });\u000a      }\u000a      break;\u000a    case 'm':\u000a      debug('message', this.transport, payload);\u000a      this.dispatchEvent(new TransportMessageEvent(payload));\u000a      break;\u000a    case 'c':\u000a      if (Array.isArray(payload) && payload.length === 2) {\u000a        this._close(payload[0], payload[1], true);\u000a      }\u000a      break;\u000a  }\u000a};\u000a\u000aSockJS.prototype._transportClose = function(code, reason) {\u000a  debug('_transportClose', this.transport, code, reason);\u000a  if (this._transport) {\u000a    this._transport.removeAllListeners();\u000a    this._transport = null;\u000a    this.transport = null;\u000a  }\u000a\u000a  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {\u000a    this._connect();\u000a    return;\u000a  }\u000a\u000a  this._close(code, reason);\u000a};\u000a\u000aSockJS.prototype._open = function() {\u000a  debug('_open', this._transport.transportName, this.readyState);\u000a  if (this.readyState === SockJS.CONNECTING) {\u000a    if (this._transportTimeoutId) {\u000a      clearTimeout(this._transportTimeoutId);\u000a      this._transportTimeoutId = null;\u000a    }\u000a    this.readyState = SockJS.OPEN;\u000a    this.transport = this._transport.transportName;\u000a    this.dispatchEvent(new Event('open'));\u000a    debug('connected', this.transport);\u000a  } else {\u000a    // The server might have been restarted, and lost track of our\u000a    // connection.\u000a    this._close(1006, 'Server lost session');\u000a  }\u000a};\u000a\u000aSockJS.prototype._close = function(code, reason, wasClean) {\u000a  debug('_close', this.transport, code, reason, wasClean, this.readyState);\u000a  var forceFail = false;\u000a\u000a  if (this._ir) {\u000a    forceFail = true;\u000a    this._ir.close();\u000a    this._ir = null;\u000a  }\u000a  if (this._transport) {\u000a    this._transport.close();\u000a    this._transport = null;\u000a    this.transport = null;\u000a  }\u000a\u000a  if (this.readyState === SockJS.CLOSED) {\u000a    throw new Error('InvalidStateError: SockJS has already been closed');\u000a  }\u000a\u000a  this.readyState = SockJS.CLOSING;\u000a  setTimeout(function() {\u000a    this.readyState = SockJS.CLOSED;\u000a\u000a    if (forceFail) {\u000a      this.dispatchEvent(new Event('error'));\u000a    }\u000a\u000a    var e = new CloseEvent('close');\u000a    e.wasClean = wasClean || false;\u000a    e.code = code || 1000;\u000a    e.reason = reason;\u000a\u000a    this.dispatchEvent(e);\u000a    this.onmessage = this.onclose = this.onerror = null;\u000a    debug('disconnected');\u000a  }.bind(this), 0);\u000a};\u000a\u000a// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\u000a// and RFC 2988.\u000aSockJS.prototype.countRTO = function(rtt) {\u000a  // In a local environment, when using IE8/9 and the `jsonp-polling`\u000a  // transport the time needed to establish a connection (the time that pass\u000a  // from the opening of the transport to the call of `_dispatchOpen`) is\u000a  // around 200msec (the lower bound used in the article above) and this\u000a  // causes spurious timeouts. For this reason we calculate a value slightly\u000a  // larger than that used in the article.\u000a  if (rtt > 100) {\u000a    return 4 * rtt; // rto > 400msec\u000a  }\u000a  return 300 + rtt; // 300msec < rto <= 400msec\u000a};\u000a\u000amodule.exports = function(availableTransports) {\u000a  transports = transport(availableTransports);\u000a  require('./iframe-bootstrap')(SockJS, availableTransports);\u000a  return SockJS;\u000a};\u000a\u000a}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":54,"inherits":56,"json3":57,"url-parse":61}],15:[function(require,module,exports){\u000a/* eslint-disable */\u000a/* jscs: disable */\u000a'use strict';\u000a\u000a// pulled specific shims from https://github.com/es-shims/es5-shim\u000a\u000avar ArrayPrototype = Array.prototype;\u000avar ObjectPrototype = Object.prototype;\u000avar FunctionPrototype = Function.prototype;\u000avar StringPrototype = String.prototype;\u000avar array_slice = ArrayPrototype.slice;\u000a\u000avar _toString = ObjectPrototype.toString;\u000avar isFunction = function (val) {\u000a    return ObjectPrototype.toString.call(val) === '[object Function]';\u000a};\u000avar isArray = function isArray(obj) {\u000a    return _toString.call(obj) === '[object Array]';\u000a};\u000avar isString = function isString(obj) {\u000a    return _toString.call(obj) === '[object String]';\u000a};\u000a\u000avar supportsDescriptors = Object.defineProperty && (function () {\u000a    try {\u000a        Object.defineProperty({}, 'x', {});\u000a        return true;\u000a    } catch (e) { /* this is ES3 */\u000a        return false;\u000a    }\u000a}());\u000a\u000a// Define configurable, writable and non-enumerable props\u000a// if they don't exist.\u000avar defineProperty;\u000aif (supportsDescriptors) {\u000a    defineProperty = function (object, name, method, forceAssign) {\u000a        if (!forceAssign && (name in object)) { return; }\u000a        Object.defineProperty(object, name, {\u000a            configurable: true,\u000a            enumerable: false,\u000a            writable: true,\u000a            value: method\u000a        });\u000a    };\u000a} else {\u000a    defineProperty = function (object, name, method, forceAssign) {\u000a        if (!forceAssign && (name in object)) { return; }\u000a        object[name] = method;\u000a    };\u000a}\u000avar defineProperties = function (object, map, forceAssign) {\u000a    for (var name in map) {\u000a        if (ObjectPrototype.hasOwnProperty.call(map, name)) {\u000a          defineProperty(object, name, map[name], forceAssign);\u000a        }\u000a    }\u000a};\u000a\u000avar toObject = function (o) {\u000a    if (o == null) { // this matches both null and undefined\u000a        throw new TypeError("can't convert " + o + ' to object');\u000a    }\u000a    return Object(o);\u000a};\u000a\u000a//\u000a// Util\u000a// ======\u000a//\u000a\u000a// ES5 9.4\u000a// http://es5.github.com/#x9.4\u000a// http://jsperf.com/to-integer\u000a\u000afunction toInteger(num) {\u000a    var n = +num;\u000a    if (n !== n) { // isNaN\u000a        n = 0;\u000a    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\u000a        n = (n > 0 || -1) * Math.floor(Math.abs(n));\u000a    }\u000a    return n;\u000a}\u000a\u000afunction ToUint32(x) {\u000a    return x >>> 0;\u000a}\u000a\u000a//\u000a// Function\u000a// ========\u000a//\u000a\u000a// ES-5 15.3.4.5\u000a// http://es5.github.com/#x15.3.4.5\u000a\u000afunction Empty() {}\u000a\u000adefineProperties(FunctionPrototype, {\u000a    bind: function bind(that) { // .length is 1\u000a        // 1. Let Target be the this value.\u000a        var target = this;\u000a        // 2. If IsCallable(Target) is false, throw a TypeError exception.\u000a        if (!isFunction(target)) {\u000a            throw new TypeError('Function.prototype.bind called on incompatible ' + target);\u000a        }\u000a        // 3. Let A be a new (possibly empty) internal list of all of the\u000a        //   argument values provided after thisArg (arg1, arg2 etc), in order.\u000a        // XXX slicedArgs will stand in for "A" if used\u000a        var args = array_slice.call(arguments, 1); // for normal call\u000a        // 4. Let F be a new native ECMAScript object.\u000a        // 11. Set the [[Prototype]] internal property of F to the standard\u000a        //   built-in Function prototype object as specified in 15.3.3.1.\u000a        // 12. Set the [[Call]] internal property of F as described in\u000a        //   15.3.4.5.1.\u000a        // 13. Set the [[Construct]] internal property of F as described in\u000a        //   15.3.4.5.2.\u000a        // 14. Set the [[HasInstance]] internal property of F as described in\u000a        //   15.3.4.5.3.\u000a        var binder = function () {\u000a\u000a            if (this instanceof bound) {\u000a                // 15.3.4.5.2 [[Construct]]\u000a                // When the [[Construct]] internal method of a function object,\u000a                // F that was created using the bind function is called with a\u000a                // list of arguments ExtraArgs, the following steps are taken:\u000a                // 1. Let target be the value of F's [[TargetFunction]]\u000a                //   internal property.\u000a                // 2. If target has no [[Construct]] internal method, a\u000a                //   TypeError exception is thrown.\u000a                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal\u000a                //   property.\u000a                // 4. Let args be a new list containing the same values as the\u000a                //   list boundArgs in the same order followed by the same\u000a                //   values as the list ExtraArgs in the same order.\u000a                // 5. Return the result of calling the [[Construct]] internal\u000a                //   method of target providing args as the arguments.\u000a\u000a                var result = target.apply(\u000a                    this,\u000a                    args.concat(array_slice.call(arguments))\u000a                );\u000a                if (Object(result) === result) {\u000a                    return result;\u000a                }\u000a                return this;\u000a\u000a            } else {\u000a                // 15.3.4.5.1 [[Call]]\u000a                // When the [[Call]] internal method of a function object, F,\u000a                // which was created using the bind function is called with a\u000a                // this value and a list of arguments ExtraArgs, the following\u000a                // steps are taken:\u000a                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal\u000a                //   property.\u000a                // 2. Let boundThis be the value of F's [[BoundThis]] internal\u000a                //   property.\u000a                // 3. Let target be the value of F's [[TargetFunction]] internal\u000a                //   property.\u000a                // 4. Let args be a new list containing the same values as the\u000a                //   list boundArgs in the same order followed by the same\u000a                //   values as the list ExtraArgs in the same order.\u000a                // 5. Return the result of calling the [[Call]] internal method\u000a                //   of target providing boundThis as the this value and\u000a                //   providing args as the arguments.\u000a\u000a                // equiv: target.call(this, ...boundArgs, ...args)\u000a                return target.apply(\u000a                    that,\u000a                    args.concat(array_slice.call(arguments))\u000a                );\u000a\u000a            }\u000a\u000a        };\u000a\u000a        // 15. If the [[Class]] internal property of Target is "Function", then\u000a        //     a. Let L be the length property of Target minus the length of A.\u000a        //     b. Set the length own property of F to either 0 or L, whichever is\u000a        //       larger.\u000a        // 16. Else set the length own property of F to 0.\u000a\u000a        var boundLength = Math.max(0, target.length - args.length);\u000a\u000a        // 17. Set the attributes of the length own property of F to the values\u000a        //   specified in 15.3.5.1.\u000a        var boundArgs = [];\u000a        for (var i = 0; i < boundLength; i++) {\u000a            boundArgs.push('$' + i);\u000a        }\u000a\u000a        // XXX Build a dynamic function with desired amount of arguments is the only\u000a        // way to set the length property of a function.\u000a        // In environments where Content Security Policies enabled (Chrome extensions,\u000a        // for ex.) all use of eval or Function costructor throws an exception.\u000a        // However in all of these environments Function.prototype.bind exists\u000a        // and so this code will never be executed.\u000a        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\u000a\u000a        if (target.prototype) {\u000a            Empty.prototype = target.prototype;\u000a            bound.prototype = new Empty();\u000a            // Clean up dangling references.\u000a            Empty.prototype = null;\u000a        }\u000a\u000a        // TODO\u000a        // 18. Set the [[Extensible]] internal property of F to true.\u000a\u000a        // TODO\u000a        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\u000a        // 20. Call the [[DefineOwnProperty]] internal method of F with\u000a        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\u000a        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\u000a        //   false.\u000a        // 21. Call the [[DefineOwnProperty]] internal method of F with\u000a        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,\u000a        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\u000a        //   and false.\u000a\u000a        // TODO\u000a        // NOTE Function objects created using Function.prototype.bind do not\u000a        // have a prototype property or the [[Code]], [[FormalParameters]], and\u000a        // [[Scope]] internal properties.\u000a        // XXX can't delete prototype in pure-js.\u000a\u000a        // 22. Return F.\u000a        return bound;\u000a    }\u000a});\u000a\u000a//\u000a// Array\u000a// =====\u000a//\u000a\u000a// ES5 15.4.3.2\u000a// http://es5.github.com/#x15.4.3.2\u000a// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\u000adefineProperties(Array, { isArray: isArray });\u000a\u000a\u000avar boxedString = Object('a');\u000avar splitString = boxedString[0] !== 'a' || !(0 in boxedString);\u000a\u000avar properlyBoxesContext = function properlyBoxed(method) {\u000a    // Check node 0.6.21 bug where third parameter is not boxed\u000a    var properlyBoxesNonStrict = true;\u000a    var properlyBoxesStrict = true;\u000a    if (method) {\u000a        method.call('foo', function (_, __, context) {\u000a            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }\u000a        });\u000a\u000a        method.call([1], function () {\u000a            'use strict';\u000a            properlyBoxesStrict = typeof this === 'string';\u000a        }, 'x');\u000a    }\u000a    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;\u000a};\u000a\u000adefineProperties(ArrayPrototype, {\u000a    forEach: function forEach(fun /*, thisp*/) {\u000a        var object = toObject(this),\u000a            self = splitString && isString(this) ? this.split('') : object,\u000a            thisp = arguments[1],\u000a            i = -1,\u000a            length = self.length >>> 0;\u000a\u000a        // If no callback function or if callback is not a callable function\u000a        if (!isFunction(fun)) {\u000a            throw new TypeError(); // TODO message\u000a        }\u000a\u000a        while (++i < length) {\u000a            if (i in self) {\u000a                // Invoke the callback function with call, passing arguments:\u000a                // context, property value, property key, thisArg object\u000a                // context\u000a                fun.call(thisp, self[i], i, object);\u000a            }\u000a        }\u000a    }\u000a}, !properlyBoxesContext(ArrayPrototype.forEach));\u000a\u000a// ES5 15.4.4.14\u000a// http://es5.github.com/#x15.4.4.14\u000a// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\u000avar hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;\u000adefineProperties(ArrayPrototype, {\u000a    indexOf: function indexOf(sought /*, fromIndex */ ) {\u000a        var self = splitString && isString(this) ? this.split('') : toObject(this),\u000a            length = self.length >>> 0;\u000a\u000a        if (!length) {\u000a            return -1;\u000a        }\u000a\u000a        var i = 0;\u000a        if (arguments.length > 1) {\u000a            i = toInteger(arguments[1]);\u000a        }\u000a\u000a        // handle negative indices\u000a        i = i >= 0 ? i : Math.max(0, length + i);\u000a        for (; i < length; i++) {\u000a            if (i in self && self[i] === sought) {\u000a                return i;\u000a            }\u000a        }\u000a        return -1;\u000a    }\u000a}, hasFirefox2IndexOfBug);\u000a\u000a//\u000a// String\u000a// ======\u000a//\u000a\u000a// ES5 15.5.4.14\u000a// http://es5.github.com/#x15.5.4.14\u000a\u000a// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]\u000a// Many browsers do not split properly with regular expressions or they\u000a// do not perform the split correctly under obscure conditions.\u000a// See http://blog.stevenlevithan.com/archives/cross-browser-split\u000a// I've tested in many browsers and this seems to cover the deviant ones:\u000a//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]\u000a//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]\u000a//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not\u000a//       [undefined, "t", undefined, "e", ...]\u000a//    ''.split(/.?/) should be [], not [""]\u000a//    '.'.split(/()()/) should be ["."], not ["", "", "."]\u000a\u000avar string_split = StringPrototype.split;\u000aif (\u000a    'ab'.split(/(?:ab)*/).length !== 2 ||\u000a    '.'.split(/(.?)(.?)/).length !== 4 ||\u000a    'tesst'.split(/(s)*/)[1] === 't' ||\u000a    'test'.split(/(?:)/, -1).length !== 4 ||\u000a    ''.split(/.?/).length ||\u000a    '.'.split(/()()/).length > 1\u000a) {\u000a    (function () {\u000a        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group\u000a\u000a        StringPrototype.split = function (separator, limit) {\u000a            var string = this;\u000a            if (separator === void 0 && limit === 0) {\u000a                return [];\u000a            }\u000a\u000a            // If `separator` is not a regex, use native split\u000a            if (_toString.call(separator) !== '[object RegExp]') {\u000a                return string_split.call(this, separator, limit);\u000a            }\u000a\u000a            var output = [],\u000a                flags = (separator.ignoreCase ? 'i' : '') +\u000a                        (separator.multiline  ? 'm' : '') +\u000a                        (separator.extended   ? 'x' : '') + // Proposed for ES6\u000a                        (separator.sticky     ? 'y' : ''), // Firefox 3+\u000a                lastLastIndex = 0,\u000a                // Make `global` and avoid `lastIndex` issues by working with a copy\u000a                separator2, match, lastIndex, lastLength;\u000a            separator = new RegExp(separator.source, flags + 'g');\u000a            string += ''; // Type-convert\u000a            if (!compliantExecNpcg) {\u000a                // Doesn't need flags gy, but they don't hurt\u000a                separator2 = new RegExp('^' + separator.source + '$(?!\u005c\u005cs)', flags);\u000a            }\u000a            /* Values for `limit`, per the spec:\u000a             * If undefined: 4294967295 // Math.pow(2, 32) - 1\u000a             * If 0, Infinity, or NaN: 0\u000a             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\u000a             * If negative number: 4294967296 - Math.floor(Math.abs(limit))\u000a             * If other: Type-convert, then use the above rules\u000a             */\u000a            limit = limit === void 0 ?\u000a                -1 >>> 0 : // Math.pow(2, 32) - 1\u000a                ToUint32(limit);\u000a            while (match = separator.exec(string)) {\u000a                // `separator.lastIndex` is not reliable cross-browser\u000a                lastIndex = match.index + match[0].length;\u000a                if (lastIndex > lastLastIndex) {\u000a                    output.push(string.slice(lastLastIndex, match.index));\u000a                    // Fix browsers whose `exec` methods don't consistently return `undefined` for\u000a                    // nonparticipating capturing groups\u000a                    if (!compliantExecNpcg && match.length > 1) {\u000a                        match[0].replace(separator2, function () {\u000a                            for (var i = 1; i < arguments.length - 2; i++) {\u000a                                if (arguments[i] === void 0) {\u000a                                    match[i] = void 0;\u000a                                }\u000a                            }\u000a                        });\u000a                    }\u000a                    if (match.length > 1 && match.index < string.length) {\u000a                        ArrayPrototype.push.apply(output, match.slice(1));\u000a                    }\u000a                    lastLength = match[0].length;\u000a                    lastLastIndex = lastIndex;\u000a                    if (output.length >= limit) {\u000a                        break;\u000a                    }\u000a                }\u000a                if (separator.lastIndex === match.index) {\u000a                    separator.lastIndex++; // Avoid an infinite loop\u000a                }\u000a            }\u000a            if (lastLastIndex === string.length) {\u000a                if (lastLength || !separator.test('')) {\u000a                    output.push('');\u000a                }\u000a            } else {\u000a                output.push(string.slice(lastLastIndex));\u000a            }\u000a            return output.length > limit ? output.slice(0, limit) : output;\u000a        };\u000a    }());\u000a\u000a// [bugfix, chrome]\u000a// If separator is undefined, then the result array contains just one String,\u000a// which is the this value (converted to a String). If limit is not undefined,\u000a// then the output array is truncated so that it contains no more than limit\u000a// elements.\u000a// "0".split(undefined, 0) -> []\u000a} else if ('0'.split(void 0, 0).length) {\u000a    StringPrototype.split = function split(separator, limit) {\u000a        if (separator === void 0 && limit === 0) { return []; }\u000a        return string_split.call(this, separator, limit);\u000a    };\u000a}\u000a\u000a// ECMA-262, 3rd B.2.3\u000a// Not an ECMAScript standard, although ECMAScript 3rd Edition has a\u000a// non-normative section suggesting uniform semantics and it should be\u000a// normalized across all browsers\u000a// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE\u000avar string_substr = StringPrototype.substr;\u000avar hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';\u000adefineProperties(StringPrototype, {\u000a    substr: function substr(start, length) {\u000a        return string_substr.call(\u000a            this,\u000a            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,\u000a            length\u000a        );\u000a    }\u000a}, hasNegativeSubstrBug);\u000a\u000a},{}],16:[function(require,module,exports){\u000a'use strict';\u000a\u000amodule.exports = [\u000a  // streaming transports\u000a  require('./transport/websocket')\u000a, require('./transport/xhr-streaming')\u000a, require('./transport/xdr-streaming')\u000a, require('./transport/eventsource')\u000a, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))\u000a\u000a  // polling transports\u000a, require('./transport/htmlfile')\u000a, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))\u000a, require('./transport/xhr-polling')\u000a, require('./transport/xdr-polling')\u000a, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))\u000a, require('./transport/jsonp-polling')\u000a];\u000a\u000a},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){\u000a(function (process,global){\u000a'use strict';\u000a\u000avar EventEmitter = require('events').EventEmitter\u000a  , inherits = require('inherits')\u000a  , utils = require('../../utils/event')\u000a  , urlUtils = require('../../utils/url')\u000a  , XHR = global.XMLHttpRequest\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:browser:xhr');\u000a}\u000a\u000afunction AbstractXHRObject(method, url, payload, opts) {\u000a  debug(method, url);\u000a  var self = this;\u000a  EventEmitter.call(this);\u000a\u000a  setTimeout(function () {\u000a    self._start(method, url, payload, opts);\u000a  }, 0);\u000a}\u000a\u000ainherits(AbstractXHRObject, EventEmitter);\u000a\u000aAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\u000a  var self = this;\u000a\u000a  try {\u000a    this.xhr = new XHR();\u000a  } catch (x) {\u000a    // intentionally empty\u000a  }\u000a\u000a  if (!this.xhr) {\u000a    debug('no xhr');\u000a    this.emit('finish', 0, 'no xhr support');\u000a    this._cleanup();\u000a    return;\u000a  }\u000a\u000a  // several browsers cache POSTs\u000a  url = urlUtils.addQuery(url, 't=' + (+new Date()));\u000a\u000a  // Explorer tends to keep connection open, even after the\u000a  // tab gets closed: http://bugs.jquery.com/ticket/5280\u000a  this.unloadRef = utils.unloadAdd(function() {\u000a    debug('unload cleanup');\u000a    self._cleanup(true);\u000a  });\u000a  try {\u000a    this.xhr.open(method, url, true);\u000a    if (this.timeout && 'timeout' in this.xhr) {\u000a      this.xhr.timeout = this.timeout;\u000a      this.xhr.ontimeout = function() {\u000a        debug('xhr timeout');\u000a        self.emit('finish', 0, '');\u000a        self._cleanup(false);\u000a      };\u000a    }\u000a  } catch (e) {\u000a    debug('exception', e);\u000a    // IE raises an exception on wrong port.\u000a    this.emit('finish', 0, '');\u000a    this._cleanup(false);\u000a    return;\u000a  }\u000a\u000a  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {\u000a    debug('withCredentials');\u000a    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\u000a    // "This never affects same-site requests."\u000a\u000a    this.xhr.withCredentials = 'true';\u000a  }\u000a  if (opts && opts.headers) {\u000a    for (var key in opts.headers) {\u000a      this.xhr.setRequestHeader(key, opts.headers[key]);\u000a    }\u000a  }\u000a\u000a  this.xhr.onreadystatechange = function() {\u000a    if (self.xhr) {\u000a      var x = self.xhr;\u000a      var text, status;\u000a      debug('readyState', x.readyState);\u000a      switch (x.readyState) {\u000a      case 3:\u000a        // IE doesn't like peeking into responseText or status\u000a        // on Microsoft.XMLHTTP and readystate=3\u000a        try {\u000a          status = x.status;\u000a          text = x.responseText;\u000a        } catch (e) {\u000a          // intentionally empty\u000a        }\u000a        debug('status', status);\u000a        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\u000a        if (status === 1223) {\u000a          status = 204;\u000a        }\u000a\u000a        // IE does return readystate == 3 for 404 answers.\u000a        if (status === 200 && text && text.length > 0) {\u000a          debug('chunk');\u000a          self.emit('chunk', status, text);\u000a        }\u000a        break;\u000a      case 4:\u000a        status = x.status;\u000a        debug('status', status);\u000a        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\u000a        if (status === 1223) {\u000a          status = 204;\u000a        }\u000a        // IE returns this for a bad port\u000a        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx\u000a        if (status === 12005 || status === 12029) {\u000a          status = 0;\u000a        }\u000a\u000a        debug('finish', status, x.responseText);\u000a        self.emit('finish', status, x.responseText);\u000a        self._cleanup(false);\u000a        break;\u000a      }\u000a    }\u000a  };\u000a\u000a  try {\u000a    self.xhr.send(payload);\u000a  } catch (e) {\u000a    self.emit('finish', 0, '');\u000a    self._cleanup(false);\u000a  }\u000a};\u000a\u000aAbstractXHRObject.prototype._cleanup = function(abort) {\u000a  debug('cleanup');\u000a  if (!this.xhr) {\u000a    return;\u000a  }\u000a  this.removeAllListeners();\u000a  utils.unloadDel(this.unloadRef);\u000a\u000a  // IE needs this field to be a function\u000a  this.xhr.onreadystatechange = function() {};\u000a  if (this.xhr.ontimeout) {\u000a    this.xhr.ontimeout = null;\u000a  }\u000a\u000a  if (abort) {\u000a    try {\u000a      this.xhr.abort();\u000a    } catch (x) {\u000a      // intentionally empty\u000a    }\u000a  }\u000a  this.unloadRef = this.xhr = null;\u000a};\u000a\u000aAbstractXHRObject.prototype.close = function() {\u000a  debug('close');\u000a  this._cleanup(true);\u000a};\u000a\u000aAbstractXHRObject.enabled = !!XHR;\u000a// override XMLHttpRequest for IE6/7\u000a// obfuscate to avoid firewalls\u000avar axo = ['Active'].concat('Object').join('X');\u000aif (!AbstractXHRObject.enabled && (axo in global)) {\u000a  debug('overriding xmlhttprequest');\u000a  XHR = function() {\u000a    try {\u000a      return new global[axo]('Microsoft.XMLHTTP');\u000a    } catch (e) {\u000a      return null;\u000a    }\u000a  };\u000a  AbstractXHRObject.enabled = !!new XHR();\u000a}\u000a\u000avar cors = false;\u000atry {\u000a  cors = 'withCredentials' in new XHR();\u000a} catch (ignored) {\u000a  // intentionally empty\u000a}\u000a\u000aAbstractXHRObject.supportsCORS = cors;\u000a\u000amodule.exports = AbstractXHRObject;\u000a\u000a}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"../../utils/event":46,"../../utils/url":52,"debug":54,"events":3,"inherits":56}],18:[function(require,module,exports){\u000a(function (global){\u000amodule.exports = global.EventSource;\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{}],19:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000avar Driver = global.WebSocket || global.MozWebSocket;\u000aif (Driver) {\u000a	module.exports = function WebSocketBrowserDriver(url) {\u000a		return new Driver(url);\u000a	};\u000a} else {\u000a	module.exports = undefined;\u000a}\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{}],20:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , AjaxBasedTransport = require('./lib/ajax-based')\u000a  , EventSourceReceiver = require('./receiver/eventsource')\u000a  , XHRCorsObject = require('./sender/xhr-cors')\u000a  , EventSourceDriver = require('eventsource')\u000a  ;\u000a\u000afunction EventSourceTransport(transUrl) {\u000a  if (!EventSourceTransport.enabled()) {\u000a    throw new Error('Transport created when disabled');\u000a  }\u000a\u000a  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);\u000a}\u000a\u000ainherits(EventSourceTransport, AjaxBasedTransport);\u000a\u000aEventSourceTransport.enabled = function() {\u000a  return !!EventSourceDriver;\u000a};\u000a\u000aEventSourceTransport.transportName = 'eventsource';\u000aEventSourceTransport.roundTrips = 2;\u000a\u000amodule.exports = EventSourceTransport;\u000a\u000a},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":56}],21:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , HtmlfileReceiver = require('./receiver/htmlfile')\u000a  , XHRLocalObject = require('./sender/xhr-local')\u000a  , AjaxBasedTransport = require('./lib/ajax-based')\u000a  ;\u000a\u000afunction HtmlFileTransport(transUrl) {\u000a  if (!HtmlfileReceiver.enabled) {\u000a    throw new Error('Transport created when disabled');\u000a  }\u000a  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);\u000a}\u000a\u000ainherits(HtmlFileTransport, AjaxBasedTransport);\u000a\u000aHtmlFileTransport.enabled = function(info) {\u000a  return HtmlfileReceiver.enabled && info.sameOrigin;\u000a};\u000a\u000aHtmlFileTransport.transportName = 'htmlfile';\u000aHtmlFileTransport.roundTrips = 2;\u000a\u000amodule.exports = HtmlFileTransport;\u000a\u000a},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":56}],22:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000a// Few cool transports do work only for same-origin. In order to make\u000a// them work cross-domain we shall use iframe, served from the\u000a// remote domain. New browsers have capabilities to communicate with\u000a// cross domain iframe using postMessage(). In IE it was implemented\u000a// from IE 8+, but of course, IE got some details wrong:\u000a//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\u000a//    http://stevesouders.com/misc/test-postmessage.php\u000a\u000avar inherits = require('inherits')\u000a  , JSON3 = require('json3')\u000a  , EventEmitter = require('events').EventEmitter\u000a  , version = require('../version')\u000a  , urlUtils = require('../utils/url')\u000a  , iframeUtils = require('../utils/iframe')\u000a  , eventUtils = require('../utils/event')\u000a  , random = require('../utils/random')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:transport:iframe');\u000a}\u000a\u000afunction IframeTransport(transport, transUrl, baseUrl) {\u000a  if (!IframeTransport.enabled()) {\u000a    throw new Error('Transport created when disabled');\u000a  }\u000a  EventEmitter.call(this);\u000a\u000a  var self = this;\u000a  this.origin = urlUtils.getOrigin(baseUrl);\u000a  this.baseUrl = baseUrl;\u000a  this.transUrl = transUrl;\u000a  this.transport = transport;\u000a  this.windowId = random.string(8);\u000a\u000a  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;\u000a  debug(transport, transUrl, iframeUrl);\u000a\u000a  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {\u000a    debug('err callback');\u000a    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');\u000a    self.close();\u000a  });\u000a\u000a  this.onmessageCallback = this._message.bind(this);\u000a  eventUtils.attachEvent('message', this.onmessageCallback);\u000a}\u000a\u000ainherits(IframeTransport, EventEmitter);\u000a\u000aIframeTransport.prototype.close = function() {\u000a  debug('close');\u000a  this.removeAllListeners();\u000a  if (this.iframeObj) {\u000a    eventUtils.detachEvent('message', this.onmessageCallback);\u000a    try {\u000a      // When the iframe is not loaded, IE raises an exception\u000a      // on 'contentWindow'.\u000a      this.postMessage('c');\u000a    } catch (x) {\u000a      // intentionally empty\u000a    }\u000a    this.iframeObj.cleanup();\u000a    this.iframeObj = null;\u000a    this.onmessageCallback = this.iframeObj = null;\u000a  }\u000a};\u000a\u000aIframeTransport.prototype._message = function(e) {\u000a  debug('message', e.data);\u000a  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {\u000a    debug('not same origin', e.origin, this.origin);\u000a    return;\u000a  }\u000a\u000a  var iframeMessage;\u000a  try {\u000a    iframeMessage = JSON3.parse(e.data);\u000a  } catch (ignored) {\u000a    debug('bad json', e.data);\u000a    return;\u000a  }\u000a\u000a  if (iframeMessage.windowId !== this.windowId) {\u000a    debug('mismatched window id', iframeMessage.windowId, this.windowId);\u000a    return;\u000a  }\u000a\u000a  switch (iframeMessage.type) {\u000a  case 's':\u000a    this.iframeObj.loaded();\u000a    // window global dependency\u000a    this.postMessage('s', JSON3.stringify([\u000a      version\u000a    , this.transport\u000a    , this.transUrl\u000a    , this.baseUrl\u000a    ]));\u000a    break;\u000a  case 't':\u000a    this.emit('message', iframeMessage.data);\u000a    break;\u000a  case 'c':\u000a    var cdata;\u000a    try {\u000a      cdata = JSON3.parse(iframeMessage.data);\u000a    } catch (ignored) {\u000a      debug('bad json', iframeMessage.data);\u000a      return;\u000a    }\u000a    this.emit('close', cdata[0], cdata[1]);\u000a    this.close();\u000a    break;\u000a  }\u000a};\u000a\u000aIframeTransport.prototype.postMessage = function(type, data) {\u000a  debug('postMessage', type, data);\u000a  this.iframeObj.post(JSON3.stringify({\u000a    windowId: this.windowId\u000a  , type: type\u000a  , data: data || ''\u000a  }), this.origin);\u000a};\u000a\u000aIframeTransport.prototype.send = function(message) {\u000a  debug('send', message);\u000a  this.postMessage('m', message);\u000a};\u000a\u000aIframeTransport.enabled = function() {\u000a  return iframeUtils.iframeEnabled;\u000a};\u000a\u000aIframeTransport.transportName = 'iframe';\u000aIframeTransport.roundTrips = 2;\u000a\u000amodule.exports = IframeTransport;\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":54,"events":3,"inherits":56,"json3":57}],23:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000a// The simplest and most robust transport, using the well-know cross\u000a// domain hack - JSONP. This transport is quite inefficient - one\u000a// message could use up to one http request. But at least it works almost\u000a// everywhere.\u000a// Known limitations:\u000a//   o you will get a spinning cursor\u000a//   o for Konqueror a dumb timer is needed to detect errors\u000a\u000avar inherits = require('inherits')\u000a  , SenderReceiver = require('./lib/sender-receiver')\u000a  , JsonpReceiver = require('./receiver/jsonp')\u000a  , jsonpSender = require('./sender/jsonp')\u000a  ;\u000a\u000afunction JsonPTransport(transUrl) {\u000a  if (!JsonPTransport.enabled()) {\u000a    throw new Error('Transport created when disabled');\u000a  }\u000a  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);\u000a}\u000a\u000ainherits(JsonPTransport, SenderReceiver);\u000a\u000aJsonPTransport.enabled = function() {\u000a  return !!global.document;\u000a};\u000a\u000aJsonPTransport.transportName = 'jsonp-polling';\u000aJsonPTransport.roundTrips = 1;\u000aJsonPTransport.needBody = true;\u000a\u000amodule.exports = JsonPTransport;\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":56}],24:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , urlUtils = require('../../utils/url')\u000a  , SenderReceiver = require('./sender-receiver')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:ajax-based');\u000a}\u000a\u000afunction createAjaxSender(AjaxObject) {\u000a  return function(url, payload, callback) {\u000a    debug('create ajax sender', url, payload);\u000a    var opt = {};\u000a    if (typeof payload === 'string') {\u000a      opt.headers = {'Content-type': 'text/plain'};\u000a    }\u000a    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');\u000a    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);\u000a    xo.once('finish', function(status) {\u000a      debug('finish', status);\u000a      xo = null;\u000a\u000a      if (status !== 200 && status !== 204) {\u000a        return callback(new Error('http status ' + status));\u000a      }\u000a      callback();\u000a    });\u000a    return function() {\u000a      debug('abort');\u000a      xo.close();\u000a      xo = null;\u000a\u000a      var err = new Error('Aborted');\u000a      err.code = 1000;\u000a      callback(err);\u000a    };\u000a  };\u000a}\u000a\u000afunction AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {\u000a  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);\u000a}\u000a\u000ainherits(AjaxBasedTransport, SenderReceiver);\u000a\u000amodule.exports = AjaxBasedTransport;\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"../../utils/url":52,"./sender-receiver":28,"debug":54,"inherits":56}],25:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , EventEmitter = require('events').EventEmitter\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:buffered-sender');\u000a}\u000a\u000afunction BufferedSender(url, sender) {\u000a  debug(url);\u000a  EventEmitter.call(this);\u000a  this.sendBuffer = [];\u000a  this.sender = sender;\u000a  this.url = url;\u000a}\u000a\u000ainherits(BufferedSender, EventEmitter);\u000a\u000aBufferedSender.prototype.send = function(message) {\u000a  debug('send', message);\u000a  this.sendBuffer.push(message);\u000a  if (!this.sendStop) {\u000a    this.sendSchedule();\u000a  }\u000a};\u000a\u000a// For polling transports in a situation when in the message callback,\u000a// new message is being send. If the sending connection was started\u000a// before receiving one, it is possible to saturate the network and\u000a// timeout due to the lack of receiving socket. To avoid that we delay\u000a// sending messages by some small time, in order to let receiving\u000a// connection be started beforehand. This is only a halfmeasure and\u000a// does not fix the big problem, but it does make the tests go more\u000a// stable on slow networks.\u000aBufferedSender.prototype.sendScheduleWait = function() {\u000a  debug('sendScheduleWait');\u000a  var self = this;\u000a  var tref;\u000a  this.sendStop = function() {\u000a    debug('sendStop');\u000a    self.sendStop = null;\u000a    clearTimeout(tref);\u000a  };\u000a  tref = setTimeout(function() {\u000a    debug('timeout');\u000a    self.sendStop = null;\u000a    self.sendSchedule();\u000a  }, 25);\u000a};\u000a\u000aBufferedSender.prototype.sendSchedule = function() {\u000a  debug('sendSchedule', this.sendBuffer.length);\u000a  var self = this;\u000a  if (this.sendBuffer.length > 0) {\u000a    var payload = '[' + this.sendBuffer.join(',') + ']';\u000a    this.sendStop = this.sender(this.url, payload, function(err) {\u000a      self.sendStop = null;\u000a      if (err) {\u000a        debug('error', err);\u000a        self.emit('close', err.code || 1006, 'Sending error: ' + err);\u000a        self.close();\u000a      } else {\u000a        self.sendScheduleWait();\u000a      }\u000a    });\u000a    this.sendBuffer = [];\u000a  }\u000a};\u000a\u000aBufferedSender.prototype._cleanup = function() {\u000a  debug('_cleanup');\u000a  this.removeAllListeners();\u000a};\u000a\u000aBufferedSender.prototype.close = function() {\u000a  debug('close');\u000a  this._cleanup();\u000a  if (this.sendStop) {\u000a    this.sendStop();\u000a    this.sendStop = null;\u000a  }\u000a};\u000a\u000amodule.exports = BufferedSender;\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"debug":54,"events":3,"inherits":56}],26:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , IframeTransport = require('../iframe')\u000a  , objectUtils = require('../../utils/object')\u000a  ;\u000a\u000amodule.exports = function(transport) {\u000a\u000a  function IframeWrapTransport(transUrl, baseUrl) {\u000a    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);\u000a  }\u000a\u000a  inherits(IframeWrapTransport, IframeTransport);\u000a\u000a  IframeWrapTransport.enabled = function(url, info) {\u000a    if (!global.document) {\u000a      return false;\u000a    }\u000a\u000a    var iframeInfo = objectUtils.extend({}, info);\u000a    iframeInfo.sameOrigin = true;\u000a    return transport.enabled(iframeInfo) && IframeTransport.enabled();\u000a  };\u000a\u000a  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;\u000a  IframeWrapTransport.needBody = true;\u000a  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)\u000a\u000a  IframeWrapTransport.facadeTransport = transport;\u000a\u000a  return IframeWrapTransport;\u000a};\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"../../utils/object":49,"../iframe":22,"inherits":56}],27:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , EventEmitter = require('events').EventEmitter\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:polling');\u000a}\u000a\u000afunction Polling(Receiver, receiveUrl, AjaxObject) {\u000a  debug(receiveUrl);\u000a  EventEmitter.call(this);\u000a  this.Receiver = Receiver;\u000a  this.receiveUrl = receiveUrl;\u000a  this.AjaxObject = AjaxObject;\u000a  this._scheduleReceiver();\u000a}\u000a\u000ainherits(Polling, EventEmitter);\u000a\u000aPolling.prototype._scheduleReceiver = function() {\u000a  debug('_scheduleReceiver');\u000a  var self = this;\u000a  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);\u000a\u000a  poll.on('message', function(msg) {\u000a    debug('message', msg);\u000a    self.emit('message', msg);\u000a  });\u000a\u000a  poll.once('close', function(code, reason) {\u000a    debug('close', code, reason, self.pollIsClosing);\u000a    self.poll = poll = null;\u000a\u000a    if (!self.pollIsClosing) {\u000a      if (reason === 'network') {\u000a        self._scheduleReceiver();\u000a      } else {\u000a        self.emit('close', code || 1006, reason);\u000a        self.removeAllListeners();\u000a      }\u000a    }\u000a  });\u000a};\u000a\u000aPolling.prototype.abort = function() {\u000a  debug('abort');\u000a  this.removeAllListeners();\u000a  this.pollIsClosing = true;\u000a  if (this.poll) {\u000a    this.poll.abort();\u000a  }\u000a};\u000a\u000amodule.exports = Polling;\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"debug":54,"events":3,"inherits":56}],28:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , urlUtils = require('../../utils/url')\u000a  , BufferedSender = require('./buffered-sender')\u000a  , Polling = require('./polling')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:sender-receiver');\u000a}\u000a\u000afunction SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {\u000a  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);\u000a  debug(pollUrl);\u000a  var self = this;\u000a  BufferedSender.call(this, transUrl, senderFunc);\u000a\u000a  this.poll = new Polling(Receiver, pollUrl, AjaxObject);\u000a  this.poll.on('message', function(msg) {\u000a    debug('poll message', msg);\u000a    self.emit('message', msg);\u000a  });\u000a  this.poll.once('close', function(code, reason) {\u000a    debug('poll close', code, reason);\u000a    self.poll = null;\u000a    self.emit('close', code, reason);\u000a    self.close();\u000a  });\u000a}\u000a\u000ainherits(SenderReceiver, BufferedSender);\u000a\u000aSenderReceiver.prototype.close = function() {\u000a  BufferedSender.prototype.close.call(this);\u000a  debug('close');\u000a  this.removeAllListeners();\u000a  if (this.poll) {\u000a    this.poll.abort();\u000a    this.poll = null;\u000a  }\u000a};\u000a\u000amodule.exports = SenderReceiver;\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":54,"inherits":56}],29:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , EventEmitter = require('events').EventEmitter\u000a  , EventSourceDriver = require('eventsource')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:receiver:eventsource');\u000a}\u000a\u000afunction EventSourceReceiver(url) {\u000a  debug(url);\u000a  EventEmitter.call(this);\u000a\u000a  var self = this;\u000a  var es = this.es = new EventSourceDriver(url);\u000a  es.onmessage = function(e) {\u000a    debug('message', e.data);\u000a    self.emit('message', decodeURI(e.data));\u000a  };\u000a  es.onerror = function(e) {\u000a    debug('error', es.readyState, e);\u000a    // ES on reconnection has readyState = 0 or 1.\u000a    // on network error it's CLOSED = 2\u000a    var reason = (es.readyState !== 2 ? 'network' : 'permanent');\u000a    self._cleanup();\u000a    self._close(reason);\u000a  };\u000a}\u000a\u000ainherits(EventSourceReceiver, EventEmitter);\u000a\u000aEventSourceReceiver.prototype.abort = function() {\u000a  debug('abort');\u000a  this._cleanup();\u000a  this._close('user');\u000a};\u000a\u000aEventSourceReceiver.prototype._cleanup = function() {\u000a  debug('cleanup');\u000a  var es = this.es;\u000a  if (es) {\u000a    es.onmessage = es.onerror = null;\u000a    es.close();\u000a    this.es = null;\u000a  }\u000a};\u000a\u000aEventSourceReceiver.prototype._close = function(reason) {\u000a  debug('close', reason);\u000a  var self = this;\u000a  // Safari and chrome < 15 crash if we close window before\u000a  // waiting for ES cleanup. See:\u000a  // https://code.google.com/p/chromium/issues/detail?id=89155\u000a  setTimeout(function() {\u000a    self.emit('close', null, reason);\u000a    self.removeAllListeners();\u000a  }, 200);\u000a};\u000a\u000amodule.exports = EventSourceReceiver;\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"debug":54,"events":3,"eventsource":18,"inherits":56}],30:[function(require,module,exports){\u000a(function (process,global){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , iframeUtils = require('../../utils/iframe')\u000a  , urlUtils = require('../../utils/url')\u000a  , EventEmitter = require('events').EventEmitter\u000a  , random = require('../../utils/random')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:receiver:htmlfile');\u000a}\u000a\u000afunction HtmlfileReceiver(url) {\u000a  debug(url);\u000a  EventEmitter.call(this);\u000a  var self = this;\u000a  iframeUtils.polluteGlobalNamespace();\u000a\u000a  this.id = 'a' + random.string(6);\u000a  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));\u000a\u000a  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);\u000a  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?\u000a      iframeUtils.createHtmlfile : iframeUtils.createIframe;\u000a\u000a  global[iframeUtils.WPrefix][this.id] = {\u000a    start: function() {\u000a      debug('start');\u000a      self.iframeObj.loaded();\u000a    }\u000a  , message: function(data) {\u000a      debug('message', data);\u000a      self.emit('message', data);\u000a    }\u000a  , stop: function() {\u000a      debug('stop');\u000a      self._cleanup();\u000a      self._close('network');\u000a    }\u000a  };\u000a  this.iframeObj = constructFunc(url, function() {\u000a    debug('callback');\u000a    self._cleanup();\u000a    self._close('permanent');\u000a  });\u000a}\u000a\u000ainherits(HtmlfileReceiver, EventEmitter);\u000a\u000aHtmlfileReceiver.prototype.abort = function() {\u000a  debug('abort');\u000a  this._cleanup();\u000a  this._close('user');\u000a};\u000a\u000aHtmlfileReceiver.prototype._cleanup = function() {\u000a  debug('_cleanup');\u000a  if (this.iframeObj) {\u000a    this.iframeObj.cleanup();\u000a    this.iframeObj = null;\u000a  }\u000a  delete global[iframeUtils.WPrefix][this.id];\u000a};\u000a\u000aHtmlfileReceiver.prototype._close = function(reason) {\u000a  debug('_close', reason);\u000a  this.emit('close', null, reason);\u000a  this.removeAllListeners();\u000a};\u000a\u000aHtmlfileReceiver.htmlfileEnabled = false;\u000a\u000a// obfuscate to avoid firewalls\u000avar axo = ['Active'].concat('Object').join('X');\u000aif (axo in global) {\u000a  try {\u000a    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');\u000a  } catch (x) {\u000a    // intentionally empty\u000a  }\u000a}\u000a\u000aHtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;\u000a\u000amodule.exports = HtmlfileReceiver;\u000a\u000a}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":54,"events":3,"inherits":56}],31:[function(require,module,exports){\u000a(function (process,global){\u000a'use strict';\u000a\u000avar utils = require('../../utils/iframe')\u000a  , random = require('../../utils/random')\u000a  , browser = require('../../utils/browser')\u000a  , urlUtils = require('../../utils/url')\u000a  , inherits = require('inherits')\u000a  , EventEmitter = require('events').EventEmitter\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:receiver:jsonp');\u000a}\u000a\u000afunction JsonpReceiver(url) {\u000a  debug(url);\u000a  var self = this;\u000a  EventEmitter.call(this);\u000a\u000a  utils.polluteGlobalNamespace();\u000a\u000a  this.id = 'a' + random.string(6);\u000a  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));\u000a\u000a  global[utils.WPrefix][this.id] = this._callback.bind(this);\u000a  this._createScript(urlWithId);\u000a\u000a  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\u000a  this.timeoutId = setTimeout(function() {\u000a    debug('timeout');\u000a    self._abort(new Error('JSONP script loaded abnormally (timeout)'));\u000a  }, JsonpReceiver.timeout);\u000a}\u000a\u000ainherits(JsonpReceiver, EventEmitter);\u000a\u000aJsonpReceiver.prototype.abort = function() {\u000a  debug('abort');\u000a  if (global[utils.WPrefix][this.id]) {\u000a    var err = new Error('JSONP user aborted read');\u000a    err.code = 1000;\u000a    this._abort(err);\u000a  }\u000a};\u000a\u000aJsonpReceiver.timeout = 35000;\u000aJsonpReceiver.scriptErrorTimeout = 1000;\u000a\u000aJsonpReceiver.prototype._callback = function(data) {\u000a  debug('_callback', data);\u000a  this._cleanup();\u000a\u000a  if (this.aborting) {\u000a    return;\u000a  }\u000a\u000a  if (data) {\u000a    debug('message', data);\u000a    this.emit('message', data);\u000a  }\u000a  this.emit('close', null, 'network');\u000a  this.removeAllListeners();\u000a};\u000a\u000aJsonpReceiver.prototype._abort = function(err) {\u000a  debug('_abort', err);\u000a  this._cleanup();\u000a  this.aborting = true;\u000a  this.emit('close', err.code, err.message);\u000a  this.removeAllListeners();\u000a};\u000a\u000aJsonpReceiver.prototype._cleanup = function() {\u000a  debug('_cleanup');\u000a  clearTimeout(this.timeoutId);\u000a  if (this.script2) {\u000a    this.script2.parentNode.removeChild(this.script2);\u000a    this.script2 = null;\u000a  }\u000a  if (this.script) {\u000a    var script = this.script;\u000a    // Unfortunately, you can't really abort script loading of\u000a    // the script.\u000a    script.parentNode.removeChild(script);\u000a    script.onreadystatechange = script.onerror =\u000a        script.onload = script.onclick = null;\u000a    this.script = null;\u000a  }\u000a  delete global[utils.WPrefix][this.id];\u000a};\u000a\u000aJsonpReceiver.prototype._scriptError = function() {\u000a  debug('_scriptError');\u000a  var self = this;\u000a  if (this.errorTimer) {\u000a    return;\u000a  }\u000a\u000a  this.errorTimer = setTimeout(function() {\u000a    if (!self.loadedOkay) {\u000a      self._abort(new Error('JSONP script loaded abnormally (onerror)'));\u000a    }\u000a  }, JsonpReceiver.scriptErrorTimeout);\u000a};\u000a\u000aJsonpReceiver.prototype._createScript = function(url) {\u000a  debug('_createScript', url);\u000a  var self = this;\u000a  var script = this.script = global.document.createElement('script');\u000a  var script2;  // Opera synchronous load trick.\u000a\u000a  script.id = 'a' + random.string(8);\u000a  script.src = url;\u000a  script.type = 'text/javascript';\u000a  script.charset = 'UTF-8';\u000a  script.onerror = this._scriptError.bind(this);\u000a  script.onload = function() {\u000a    debug('onload');\u000a    self._abort(new Error('JSONP script loaded abnormally (onload)'));\u000a  };\u000a\u000a  // IE9 fires 'error' event after onreadystatechange or before, in random order.\u000a  // Use loadedOkay to determine if actually errored\u000a  script.onreadystatechange = function() {\u000a    debug('onreadystatechange', script.readyState);\u000a    if (/loaded|closed/.test(script.readyState)) {\u000a      if (script && script.htmlFor && script.onclick) {\u000a        self.loadedOkay = true;\u000a        try {\u000a          // In IE, actually execute the script.\u000a          script.onclick();\u000a        } catch (x) {\u000a          // intentionally empty\u000a        }\u000a      }\u000a      if (script) {\u000a        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));\u000a      }\u000a    }\u000a  };\u000a  // IE: event/htmlFor/onclick trick.\u000a  // One can't rely on proper order for onreadystatechange. In order to\u000a  // make sure, set a 'htmlFor' and 'event' properties, so that\u000a  // script code will be installed as 'onclick' handler for the\u000a  // script object. Later, onreadystatechange, manually execute this\u000a  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\u000a  // set. For reference see:\u000a  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\u000a  // Also, read on that about script ordering:\u000a  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\u000a  if (typeof script.async === 'undefined' && global.document.attachEvent) {\u000a    // According to mozilla docs, in recent browsers script.async defaults\u000a    // to 'true', so we may use it to detect a good browser:\u000a    // https://developer.mozilla.org/en/HTML/Element/script\u000a    if (!browser.isOpera()) {\u000a      // Naively assume we're in IE\u000a      try {\u000a        script.htmlFor = script.id;\u000a        script.event = 'onclick';\u000a      } catch (x) {\u000a        // intentionally empty\u000a      }\u000a      script.async = true;\u000a    } else {\u000a      // Opera, second sync script hack\u000a      script2 = this.script2 = global.document.createElement('script');\u000a      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";\u000a      script.async = script2.async = false;\u000a    }\u000a  }\u000a  if (typeof script.async !== 'undefined') {\u000a    script.async = true;\u000a  }\u000a\u000a  var head = global.document.getElementsByTagName('head')[0];\u000a  head.insertBefore(script, head.firstChild);\u000a  if (script2) {\u000a    head.insertBefore(script2, head.firstChild);\u000a  }\u000a};\u000a\u000amodule.exports = JsonpReceiver;\u000a\u000a}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":54,"events":3,"inherits":56}],32:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , EventEmitter = require('events').EventEmitter\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:receiver:xhr');\u000a}\u000a\u000afunction XhrReceiver(url, AjaxObject) {\u000a  debug(url);\u000a  EventEmitter.call(this);\u000a  var self = this;\u000a\u000a  this.bufferPosition = 0;\u000a\u000a  this.xo = new AjaxObject('POST', url, null);\u000a  this.xo.on('chunk', this._chunkHandler.bind(this));\u000a  this.xo.once('finish', function(status, text) {\u000a    debug('finish', status, text);\u000a    self._chunkHandler(status, text);\u000a    self.xo = null;\u000a    var reason = status === 200 ? 'network' : 'permanent';\u000a    debug('close', reason);\u000a    self.emit('close', null, reason);\u000a    self._cleanup();\u000a  });\u000a}\u000a\u000ainherits(XhrReceiver, EventEmitter);\u000a\u000aXhrReceiver.prototype._chunkHandler = function(status, text) {\u000a  debug('_chunkHandler', status);\u000a  if (status !== 200 || !text) {\u000a    return;\u000a  }\u000a\u000a  for (var idx = -1; ; this.bufferPosition += idx + 1) {\u000a    var buf = text.slice(this.bufferPosition);\u000a    idx = buf.indexOf('\u005cn');\u000a    if (idx === -1) {\u000a      break;\u000a    }\u000a    var msg = buf.slice(0, idx);\u000a    if (msg) {\u000a      debug('message', msg);\u000a      this.emit('message', msg);\u000a    }\u000a  }\u000a};\u000a\u000aXhrReceiver.prototype._cleanup = function() {\u000a  debug('_cleanup');\u000a  this.removeAllListeners();\u000a};\u000a\u000aXhrReceiver.prototype.abort = function() {\u000a  debug('abort');\u000a  if (this.xo) {\u000a    this.xo.close();\u000a    debug('close');\u000a    this.emit('close', null, 'user');\u000a    this.xo = null;\u000a  }\u000a  this._cleanup();\u000a};\u000a\u000amodule.exports = XhrReceiver;\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"debug":54,"events":3,"inherits":56}],33:[function(require,module,exports){\u000a(function (process,global){\u000a'use strict';\u000a\u000avar random = require('../../utils/random')\u000a  , urlUtils = require('../../utils/url')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:sender:jsonp');\u000a}\u000a\u000avar form, area;\u000a\u000afunction createIframe(id) {\u000a  debug('createIframe', id);\u000a  try {\u000a    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)\u000a    return global.document.createElement('<iframe name="' + id + '">');\u000a  } catch (x) {\u000a    var iframe = global.document.createElement('iframe');\u000a    iframe.name = id;\u000a    return iframe;\u000a  }\u000a}\u000a\u000afunction createForm() {\u000a  debug('createForm');\u000a  form = global.document.createElement('form');\u000a  form.style.display = 'none';\u000a  form.style.position = 'absolute';\u000a  form.method = 'POST';\u000a  form.enctype = 'application/x-www-form-urlencoded';\u000a  form.acceptCharset = 'UTF-8';\u000a\u000a  area = global.document.createElement('textarea');\u000a  area.name = 'd';\u000a  form.appendChild(area);\u000a\u000a  global.document.body.appendChild(form);\u000a}\u000a\u000amodule.exports = function(url, payload, callback) {\u000a  debug(url, payload);\u000a  if (!form) {\u000a    createForm();\u000a  }\u000a  var id = 'a' + random.string(8);\u000a  form.target = id;\u000a  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);\u000a\u000a  var iframe = createIframe(id);\u000a  iframe.id = id;\u000a  iframe.style.display = 'none';\u000a  form.appendChild(iframe);\u000a\u000a  try {\u000a    area.value = payload;\u000a  } catch (e) {\u000a    // seriously broken browsers get here\u000a  }\u000a  form.submit();\u000a\u000a  var completed = function(err) {\u000a    debug('completed', id, err);\u000a    if (!iframe.onerror) {\u000a      return;\u000a    }\u000a    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\u000a    // Opera mini doesn't like if we GC iframe\u000a    // immediately, thus this timeout.\u000a    setTimeout(function() {\u000a      debug('cleaning up', id);\u000a      iframe.parentNode.removeChild(iframe);\u000a      iframe = null;\u000a    }, 500);\u000a    area.value = '';\u000a    // It is not possible to detect if the iframe succeeded or\u000a    // failed to submit our form.\u000a    callback(err);\u000a  };\u000a  iframe.onerror = function() {\u000a    debug('onerror', id);\u000a    completed();\u000a  };\u000a  iframe.onload = function() {\u000a    debug('onload', id);\u000a    completed();\u000a  };\u000a  iframe.onreadystatechange = function(e) {\u000a    debug('onreadystatechange', id, iframe.readyState, e);\u000a    if (iframe.readyState === 'complete') {\u000a      completed();\u000a    }\u000a  };\u000a  return function() {\u000a    debug('aborted', id);\u000a    completed(new Error('Aborted'));\u000a  };\u000a};\u000a\u000a}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"../../utils/random":50,"../../utils/url":52,"debug":54}],34:[function(require,module,exports){\u000a(function (process,global){\u000a'use strict';\u000a\u000avar EventEmitter = require('events').EventEmitter\u000a  , inherits = require('inherits')\u000a  , eventUtils = require('../../utils/event')\u000a  , browser = require('../../utils/browser')\u000a  , urlUtils = require('../../utils/url')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:sender:xdr');\u000a}\u000a\u000a// References:\u000a//   http://ajaxian.com/archives/100-line-ajax-wrapper\u000a//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\u000a\u000afunction XDRObject(method, url, payload) {\u000a  debug(method, url);\u000a  var self = this;\u000a  EventEmitter.call(this);\u000a\u000a  setTimeout(function() {\u000a    self._start(method, url, payload);\u000a  }, 0);\u000a}\u000a\u000ainherits(XDRObject, EventEmitter);\u000a\u000aXDRObject.prototype._start = function(method, url, payload) {\u000a  debug('_start');\u000a  var self = this;\u000a  var xdr = new global.XDomainRequest();\u000a  // IE caches even POSTs\u000a  url = urlUtils.addQuery(url, 't=' + (+new Date()));\u000a\u000a  xdr.onerror = function() {\u000a    debug('onerror');\u000a    self._error();\u000a  };\u000a  xdr.ontimeout = function() {\u000a    debug('ontimeout');\u000a    self._error();\u000a  };\u000a  xdr.onprogress = function() {\u000a    debug('progress', xdr.responseText);\u000a    self.emit('chunk', 200, xdr.responseText);\u000a  };\u000a  xdr.onload = function() {\u000a    debug('load');\u000a    self.emit('finish', 200, xdr.responseText);\u000a    self._cleanup(false);\u000a  };\u000a  this.xdr = xdr;\u000a  this.unloadRef = eventUtils.unloadAdd(function() {\u000a    self._cleanup(true);\u000a  });\u000a  try {\u000a    // Fails with AccessDenied if port number is bogus\u000a    this.xdr.open(method, url);\u000a    if (this.timeout) {\u000a      this.xdr.timeout = this.timeout;\u000a    }\u000a    this.xdr.send(payload);\u000a  } catch (x) {\u000a    this._error();\u000a  }\u000a};\u000a\u000aXDRObject.prototype._error = function() {\u000a  this.emit('finish', 0, '');\u000a  this._cleanup(false);\u000a};\u000a\u000aXDRObject.prototype._cleanup = function(abort) {\u000a  debug('cleanup', abort);\u000a  if (!this.xdr) {\u000a    return;\u000a  }\u000a  this.removeAllListeners();\u000a  eventUtils.unloadDel(this.unloadRef);\u000a\u000a  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;\u000a  if (abort) {\u000a    try {\u000a      this.xdr.abort();\u000a    } catch (x) {\u000a      // intentionally empty\u000a    }\u000a  }\u000a  this.unloadRef = this.xdr = null;\u000a};\u000a\u000aXDRObject.prototype.close = function() {\u000a  debug('close');\u000a  this._cleanup(true);\u000a};\u000a\u000a// IE 8/9 if the request target uses the same scheme - #79\u000aXDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());\u000a\u000amodule.exports = XDRObject;\u000a\u000a}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":54,"events":3,"inherits":56}],35:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , XhrDriver = require('../driver/xhr')\u000a  ;\u000a\u000afunction XHRCorsObject(method, url, payload, opts) {\u000a  XhrDriver.call(this, method, url, payload, opts);\u000a}\u000a\u000ainherits(XHRCorsObject, XhrDriver);\u000a\u000aXHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;\u000a\u000amodule.exports = XHRCorsObject;\u000a\u000a},{"../driver/xhr":17,"inherits":56}],36:[function(require,module,exports){\u000a'use strict';\u000a\u000avar EventEmitter = require('events').EventEmitter\u000a  , inherits = require('inherits')\u000a  ;\u000a\u000afunction XHRFake(/* method, url, payload, opts */) {\u000a  var self = this;\u000a  EventEmitter.call(this);\u000a\u000a  this.to = setTimeout(function() {\u000a    self.emit('finish', 200, '{}');\u000a  }, XHRFake.timeout);\u000a}\u000a\u000ainherits(XHRFake, EventEmitter);\u000a\u000aXHRFake.prototype.close = function() {\u000a  clearTimeout(this.to);\u000a};\u000a\u000aXHRFake.timeout = 2000;\u000a\u000amodule.exports = XHRFake;\u000a\u000a},{"events":3,"inherits":56}],37:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , XhrDriver = require('../driver/xhr')\u000a  ;\u000a\u000afunction XHRLocalObject(method, url, payload /*, opts */) {\u000a  XhrDriver.call(this, method, url, payload, {\u000a    noCredentials: true\u000a  });\u000a}\u000a\u000ainherits(XHRLocalObject, XhrDriver);\u000a\u000aXHRLocalObject.enabled = XhrDriver.enabled;\u000a\u000amodule.exports = XHRLocalObject;\u000a\u000a},{"../driver/xhr":17,"inherits":56}],38:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar utils = require('../utils/event')\u000a  , urlUtils = require('../utils/url')\u000a  , inherits = require('inherits')\u000a  , EventEmitter = require('events').EventEmitter\u000a  , WebsocketDriver = require('./driver/websocket')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:websocket');\u000a}\u000a\u000afunction WebSocketTransport(transUrl, ignore, options) {\u000a  if (!WebSocketTransport.enabled()) {\u000a    throw new Error('Transport created when disabled');\u000a  }\u000a\u000a  EventEmitter.call(this);\u000a  debug('constructor', transUrl);\u000a\u000a  var self = this;\u000a  var url = urlUtils.addPath(transUrl, '/websocket');\u000a  if (url.slice(0, 5) === 'https') {\u000a    url = 'wss' + url.slice(5);\u000a  } else {\u000a    url = 'ws' + url.slice(4);\u000a  }\u000a  this.url = url;\u000a\u000a  this.ws = new WebsocketDriver(this.url, [], options);\u000a  this.ws.onmessage = function(e) {\u000a    debug('message event', e.data);\u000a    self.emit('message', e.data);\u000a  };\u000a  // Firefox has an interesting bug. If a websocket connection is\u000a  // created after onunload, it stays alive even when user\u000a  // navigates away from the page. In such situation let's lie -\u000a  // let's not open the ws connection at all. See:\u000a  // https://github.com/sockjs/sockjs-client/issues/28\u000a  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\u000a  this.unloadRef = utils.unloadAdd(function() {\u000a    debug('unload');\u000a    self.ws.close();\u000a  });\u000a  this.ws.onclose = function(e) {\u000a    debug('close event', e.code, e.reason);\u000a    self.emit('close', e.code, e.reason);\u000a    self._cleanup();\u000a  };\u000a  this.ws.onerror = function(e) {\u000a    debug('error event', e);\u000a    self.emit('close', 1006, 'WebSocket connection broken');\u000a    self._cleanup();\u000a  };\u000a}\u000a\u000ainherits(WebSocketTransport, EventEmitter);\u000a\u000aWebSocketTransport.prototype.send = function(data) {\u000a  var msg = '[' + data + ']';\u000a  debug('send', msg);\u000a  this.ws.send(msg);\u000a};\u000a\u000aWebSocketTransport.prototype.close = function() {\u000a  debug('close');\u000a  var ws = this.ws;\u000a  this._cleanup();\u000a  if (ws) {\u000a    ws.close();\u000a  }\u000a};\u000a\u000aWebSocketTransport.prototype._cleanup = function() {\u000a  debug('_cleanup');\u000a  var ws = this.ws;\u000a  if (ws) {\u000a    ws.onmessage = ws.onclose = ws.onerror = null;\u000a  }\u000a  utils.unloadDel(this.unloadRef);\u000a  this.unloadRef = this.ws = null;\u000a  this.removeAllListeners();\u000a};\u000a\u000aWebSocketTransport.enabled = function() {\u000a  debug('enabled');\u000a  return !!WebsocketDriver;\u000a};\u000aWebSocketTransport.transportName = 'websocket';\u000a\u000a// In theory, ws should require 1 round trip. But in chrome, this is\u000a// not very stable over SSL. Most likely a ws connection requires a\u000a// separate SSL connection, in which case 2 round trips are an\u000a// absolute minumum.\u000aWebSocketTransport.roundTrips = 2;\u000a\u000amodule.exports = WebSocketTransport;\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":54,"events":3,"inherits":56}],39:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , AjaxBasedTransport = require('./lib/ajax-based')\u000a  , XdrStreamingTransport = require('./xdr-streaming')\u000a  , XhrReceiver = require('./receiver/xhr')\u000a  , XDRObject = require('./sender/xdr')\u000a  ;\u000a\u000afunction XdrPollingTransport(transUrl) {\u000a  if (!XDRObject.enabled) {\u000a    throw new Error('Transport created when disabled');\u000a  }\u000a  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);\u000a}\u000a\u000ainherits(XdrPollingTransport, AjaxBasedTransport);\u000a\u000aXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\u000aXdrPollingTransport.transportName = 'xdr-polling';\u000aXdrPollingTransport.roundTrips = 2; // preflight, ajax\u000a\u000amodule.exports = XdrPollingTransport;\u000a\u000a},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":56}],40:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , AjaxBasedTransport = require('./lib/ajax-based')\u000a  , XhrReceiver = require('./receiver/xhr')\u000a  , XDRObject = require('./sender/xdr')\u000a  ;\u000a\u000a// According to:\u000a//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\u000a//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\u000a\u000afunction XdrStreamingTransport(transUrl) {\u000a  if (!XDRObject.enabled) {\u000a    throw new Error('Transport created when disabled');\u000a  }\u000a  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);\u000a}\u000a\u000ainherits(XdrStreamingTransport, AjaxBasedTransport);\u000a\u000aXdrStreamingTransport.enabled = function(info) {\u000a  if (info.cookie_needed || info.nullOrigin) {\u000a    return false;\u000a  }\u000a  return XDRObject.enabled && info.sameScheme;\u000a};\u000a\u000aXdrStreamingTransport.transportName = 'xdr-streaming';\u000aXdrStreamingTransport.roundTrips = 2; // preflight, ajax\u000a\u000amodule.exports = XdrStreamingTransport;\u000a\u000a},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":56}],41:[function(require,module,exports){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , AjaxBasedTransport = require('./lib/ajax-based')\u000a  , XhrReceiver = require('./receiver/xhr')\u000a  , XHRCorsObject = require('./sender/xhr-cors')\u000a  , XHRLocalObject = require('./sender/xhr-local')\u000a  ;\u000a\u000afunction XhrPollingTransport(transUrl) {\u000a  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\u000a    throw new Error('Transport created when disabled');\u000a  }\u000a  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);\u000a}\u000a\u000ainherits(XhrPollingTransport, AjaxBasedTransport);\u000a\u000aXhrPollingTransport.enabled = function(info) {\u000a  if (info.nullOrigin) {\u000a    return false;\u000a  }\u000a\u000a  if (XHRLocalObject.enabled && info.sameOrigin) {\u000a    return true;\u000a  }\u000a  return XHRCorsObject.enabled;\u000a};\u000a\u000aXhrPollingTransport.transportName = 'xhr-polling';\u000aXhrPollingTransport.roundTrips = 2; // preflight, ajax\u000a\u000amodule.exports = XhrPollingTransport;\u000a\u000a},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":56}],42:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000avar inherits = require('inherits')\u000a  , AjaxBasedTransport = require('./lib/ajax-based')\u000a  , XhrReceiver = require('./receiver/xhr')\u000a  , XHRCorsObject = require('./sender/xhr-cors')\u000a  , XHRLocalObject = require('./sender/xhr-local')\u000a  , browser = require('../utils/browser')\u000a  ;\u000a\u000afunction XhrStreamingTransport(transUrl) {\u000a  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\u000a    throw new Error('Transport created when disabled');\u000a  }\u000a  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);\u000a}\u000a\u000ainherits(XhrStreamingTransport, AjaxBasedTransport);\u000a\u000aXhrStreamingTransport.enabled = function(info) {\u000a  if (info.nullOrigin) {\u000a    return false;\u000a  }\u000a  // Opera doesn't support xhr-streaming #60\u000a  // But it might be able to #92\u000a  if (browser.isOpera()) {\u000a    return false;\u000a  }\u000a\u000a  return XHRCorsObject.enabled;\u000a};\u000a\u000aXhrStreamingTransport.transportName = 'xhr-streaming';\u000aXhrStreamingTransport.roundTrips = 2; // preflight, ajax\u000a\u000a// Safari gets confused when a streaming ajax request is started\u000a// before onload. This causes the load indicator to spin indefinetely.\u000a// Only require body when used in a browser\u000aXhrStreamingTransport.needBody = !!global.document;\u000a\u000amodule.exports = XhrStreamingTransport;\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":56}],43:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000aif (global.crypto && global.crypto.getRandomValues) {\u000a  module.exports.randomBytes = function(length) {\u000a    var bytes = new Uint8Array(length);\u000a    global.crypto.getRandomValues(bytes);\u000a    return bytes;\u000a  };\u000a} else {\u000a  module.exports.randomBytes = function(length) {\u000a    var bytes = new Array(length);\u000a    for (var i = 0; i < length; i++) {\u000a      bytes[i] = Math.floor(Math.random() * 256);\u000a    }\u000a    return bytes;\u000a  };\u000a}\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{}],44:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000amodule.exports = {\u000a  isOpera: function() {\u000a    return global.navigator &&\u000a      /opera/i.test(global.navigator.userAgent);\u000a  }\u000a\u000a, isKonqueror: function() {\u000a    return global.navigator &&\u000a      /konqueror/i.test(global.navigator.userAgent);\u000a  }\u000a\u000a  // #187 wrap document.domain in try/catch because of WP8 from file:///\u000a, hasDomain: function () {\u000a    // non-browser client always has a domain\u000a    if (!global.document) {\u000a      return true;\u000a    }\u000a\u000a    try {\u000a      return !!global.document.domain;\u000a    } catch (e) {\u000a      return false;\u000a    }\u000a  }\u000a};\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{}],45:[function(require,module,exports){\u000a'use strict';\u000a\u000avar JSON3 = require('json3');\u000a\u000a// Some extra characters that Chrome gets wrong, and substitutes with\u000a// something else on the wire.\u000a// eslint-disable-next-line no-control-regex\u000avar extraEscapable = /[\u005cx00-\u005cx1f\u005cud800-\u005cudfff\u005cufffe\u005cuffff\u005cu0300-\u005cu0333\u005cu033d-\u005cu0346\u005cu034a-\u005cu034c\u005cu0350-\u005cu0352\u005cu0357-\u005cu0358\u005cu035c-\u005cu0362\u005cu0374\u005cu037e\u005cu0387\u005cu0591-\u005cu05af\u005cu05c4\u005cu0610-\u005cu0617\u005cu0653-\u005cu0654\u005cu0657-\u005cu065b\u005cu065d-\u005cu065e\u005cu06df-\u005cu06e2\u005cu06eb-\u005cu06ec\u005cu0730\u005cu0732-\u005cu0733\u005cu0735-\u005cu0736\u005cu073a\u005cu073d\u005cu073f-\u005cu0741\u005cu0743\u005cu0745\u005cu0747\u005cu07eb-\u005cu07f1\u005cu0951\u005cu0958-\u005cu095f\u005cu09dc-\u005cu09dd\u005cu09df\u005cu0a33\u005cu0a36\u005cu0a59-\u005cu0a5b\u005cu0a5e\u005cu0b5c-\u005cu0b5d\u005cu0e38-\u005cu0e39\u005cu0f43\u005cu0f4d\u005cu0f52\u005cu0f57\u005cu0f5c\u005cu0f69\u005cu0f72-\u005cu0f76\u005cu0f78\u005cu0f80-\u005cu0f83\u005cu0f93\u005cu0f9d\u005cu0fa2\u005cu0fa7\u005cu0fac\u005cu0fb9\u005cu1939-\u005cu193a\u005cu1a17\u005cu1b6b\u005cu1cda-\u005cu1cdb\u005cu1dc0-\u005cu1dcf\u005cu1dfc\u005cu1dfe\u005cu1f71\u005cu1f73\u005cu1f75\u005cu1f77\u005cu1f79\u005cu1f7b\u005cu1f7d\u005cu1fbb\u005cu1fbe\u005cu1fc9\u005cu1fcb\u005cu1fd3\u005cu1fdb\u005cu1fe3\u005cu1feb\u005cu1fee-\u005cu1fef\u005cu1ff9\u005cu1ffb\u005cu1ffd\u005cu2000-\u005cu2001\u005cu20d0-\u005cu20d1\u005cu20d4-\u005cu20d7\u005cu20e7-\u005cu20e9\u005cu2126\u005cu212a-\u005cu212b\u005cu2329-\u005cu232a\u005cu2adc\u005cu302b-\u005cu302c\u005cuaab2-\u005cuaab3\u005cuf900-\u005cufa0d\u005cufa10\u005cufa12\u005cufa15-\u005cufa1e\u005cufa20\u005cufa22\u005cufa25-\u005cufa26\u005cufa2a-\u005cufa2d\u005cufa30-\u005cufa6d\u005cufa70-\u005cufad9\u005cufb1d\u005cufb1f\u005cufb2a-\u005cufb36\u005cufb38-\u005cufb3c\u005cufb3e\u005cufb40-\u005cufb41\u005cufb43-\u005cufb44\u005cufb46-\u005cufb4e\u005cufff0-\u005cuffff]/g\u000a  , extraLookup;\u000a\u000a// This may be quite slow, so let's delay until user actually uses bad\u000a// characters.\u000avar unrollLookup = function(escapable) {\u000a  var i;\u000a  var unrolled = {};\u000a  var c = [];\u000a  for (i = 0; i < 65536; i++) {\u000a    c.push( String.fromCharCode(i) );\u000a  }\u000a  escapable.lastIndex = 0;\u000a  c.join('').replace(escapable, function(a) {\u000a    unrolled[ a ] = '\u005c\u005cu' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\u000a    return '';\u000a  });\u000a  escapable.lastIndex = 0;\u000a  return unrolled;\u000a};\u000a\u000a// Quote string, also taking care of unicode characters that browsers\u000a// often break. Especially, take care of unicode surrogates:\u000a// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\u000amodule.exports = {\u000a  quote: function(string) {\u000a    var quoted = JSON3.stringify(string);\u000a\u000a    // In most cases this should be very fast and good enough.\u000a    extraEscapable.lastIndex = 0;\u000a    if (!extraEscapable.test(quoted)) {\u000a      return quoted;\u000a    }\u000a\u000a    if (!extraLookup) {\u000a      extraLookup = unrollLookup(extraEscapable);\u000a    }\u000a\u000a    return quoted.replace(extraEscapable, function(a) {\u000a      return extraLookup[a];\u000a    });\u000a  }\u000a};\u000a\u000a},{"json3":57}],46:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000avar random = require('./random');\u000a\u000avar onUnload = {}\u000a  , afterUnload = false\u000a    // detect google chrome packaged apps because they don't allow the 'unload' event\u000a  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime\u000a  ;\u000a\u000amodule.exports = {\u000a  attachEvent: function(event, listener) {\u000a    if (typeof global.addEventListener !== 'undefined') {\u000a      global.addEventListener(event, listener, false);\u000a    } else if (global.document && global.attachEvent) {\u000a      // IE quirks.\u000a      // According to: http://stevesouders.com/misc/test-postmessage.php\u000a      // the message gets delivered only to 'document', not 'window'.\u000a      global.document.attachEvent('on' + event, listener);\u000a      // I get 'window' for ie8.\u000a      global.attachEvent('on' + event, listener);\u000a    }\u000a  }\u000a\u000a, detachEvent: function(event, listener) {\u000a    if (typeof global.addEventListener !== 'undefined') {\u000a      global.removeEventListener(event, listener, false);\u000a    } else if (global.document && global.detachEvent) {\u000a      global.document.detachEvent('on' + event, listener);\u000a      global.detachEvent('on' + event, listener);\u000a    }\u000a  }\u000a\u000a, unloadAdd: function(listener) {\u000a    if (isChromePackagedApp) {\u000a      return null;\u000a    }\u000a\u000a    var ref = random.string(8);\u000a    onUnload[ref] = listener;\u000a    if (afterUnload) {\u000a      setTimeout(this.triggerUnloadCallbacks, 0);\u000a    }\u000a    return ref;\u000a  }\u000a\u000a, unloadDel: function(ref) {\u000a    if (ref in onUnload) {\u000a      delete onUnload[ref];\u000a    }\u000a  }\u000a\u000a, triggerUnloadCallbacks: function() {\u000a    for (var ref in onUnload) {\u000a      onUnload[ref]();\u000a      delete onUnload[ref];\u000a    }\u000a  }\u000a};\u000a\u000avar unloadTriggered = function() {\u000a  if (afterUnload) {\u000a    return;\u000a  }\u000a  afterUnload = true;\u000a  module.exports.triggerUnloadCallbacks();\u000a};\u000a\u000a// 'unload' alone is not reliable in opera within an iframe, but we\u000a// can't use `beforeunload` as IE fires it on javascript: links.\u000aif (!isChromePackagedApp) {\u000a  module.exports.attachEvent('unload', unloadTriggered);\u000a}\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"./random":50}],47:[function(require,module,exports){\u000a(function (process,global){\u000a'use strict';\u000a\u000avar eventUtils = require('./event')\u000a  , JSON3 = require('json3')\u000a  , browser = require('./browser')\u000a  ;\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:utils:iframe');\u000a}\u000a\u000amodule.exports = {\u000a  WPrefix: '_jp'\u000a, currentWindowId: null\u000a\u000a, polluteGlobalNamespace: function() {\u000a    if (!(module.exports.WPrefix in global)) {\u000a      global[module.exports.WPrefix] = {};\u000a    }\u000a  }\u000a\u000a, postMessage: function(type, data) {\u000a    if (global.parent !== global) {\u000a      global.parent.postMessage(JSON3.stringify({\u000a        windowId: module.exports.currentWindowId\u000a      , type: type\u000a      , data: data || ''\u000a      }), '*');\u000a    } else {\u000a      debug('Cannot postMessage, no parent window.', type, data);\u000a    }\u000a  }\u000a\u000a, createIframe: function(iframeUrl, errorCallback) {\u000a    var iframe = global.document.createElement('iframe');\u000a    var tref, unloadRef;\u000a    var unattach = function() {\u000a      debug('unattach');\u000a      clearTimeout(tref);\u000a      // Explorer had problems with that.\u000a      try {\u000a        iframe.onload = null;\u000a      } catch (x) {\u000a        // intentionally empty\u000a      }\u000a      iframe.onerror = null;\u000a    };\u000a    var cleanup = function() {\u000a      debug('cleanup');\u000a      if (iframe) {\u000a        unattach();\u000a        // This timeout makes chrome fire onbeforeunload event\u000a        // within iframe. Without the timeout it goes straight to\u000a        // onunload.\u000a        setTimeout(function() {\u000a          if (iframe) {\u000a            iframe.parentNode.removeChild(iframe);\u000a          }\u000a          iframe = null;\u000a        }, 0);\u000a        eventUtils.unloadDel(unloadRef);\u000a      }\u000a    };\u000a    var onerror = function(err) {\u000a      debug('onerror', err);\u000a      if (iframe) {\u000a        cleanup();\u000a        errorCallback(err);\u000a      }\u000a    };\u000a    var post = function(msg, origin) {\u000a      debug('post', msg, origin);\u000a      try {\u000a        // When the iframe is not loaded, IE raises an exception\u000a        // on 'contentWindow'.\u000a        setTimeout(function() {\u000a          if (iframe && iframe.contentWindow) {\u000a            iframe.contentWindow.postMessage(msg, origin);\u000a          }\u000a        }, 0);\u000a      } catch (x) {\u000a        // intentionally empty\u000a      }\u000a    };\u000a\u000a    iframe.src = iframeUrl;\u000a    iframe.style.display = 'none';\u000a    iframe.style.position = 'absolute';\u000a    iframe.onerror = function() {\u000a      onerror('onerror');\u000a    };\u000a    iframe.onload = function() {\u000a      debug('onload');\u000a      // `onload` is triggered before scripts on the iframe are\u000a      // executed. Give it few seconds to actually load stuff.\u000a      clearTimeout(tref);\u000a      tref = setTimeout(function() {\u000a        onerror('onload timeout');\u000a      }, 2000);\u000a    };\u000a    global.document.body.appendChild(iframe);\u000a    tref = setTimeout(function() {\u000a      onerror('timeout');\u000a    }, 15000);\u000a    unloadRef = eventUtils.unloadAdd(cleanup);\u000a    return {\u000a      post: post\u000a    , cleanup: cleanup\u000a    , loaded: unattach\u000a    };\u000a  }\u000a\u000a/* eslint no-undef: "off", new-cap: "off" */\u000a, createHtmlfile: function(iframeUrl, errorCallback) {\u000a    var axo = ['Active'].concat('Object').join('X');\u000a    var doc = new global[axo]('htmlfile');\u000a    var tref, unloadRef;\u000a    var iframe;\u000a    var unattach = function() {\u000a      clearTimeout(tref);\u000a      iframe.onerror = null;\u000a    };\u000a    var cleanup = function() {\u000a      if (doc) {\u000a        unattach();\u000a        eventUtils.unloadDel(unloadRef);\u000a        iframe.parentNode.removeChild(iframe);\u000a        iframe = doc = null;\u000a        CollectGarbage();\u000a      }\u000a    };\u000a    var onerror = function(r) {\u000a      debug('onerror', r);\u000a      if (doc) {\u000a        cleanup();\u000a        errorCallback(r);\u000a      }\u000a    };\u000a    var post = function(msg, origin) {\u000a      try {\u000a        // When the iframe is not loaded, IE raises an exception\u000a        // on 'contentWindow'.\u000a        setTimeout(function() {\u000a          if (iframe && iframe.contentWindow) {\u000a              iframe.contentWindow.postMessage(msg, origin);\u000a          }\u000a        }, 0);\u000a      } catch (x) {\u000a        // intentionally empty\u000a      }\u000a    };\u000a\u000a    doc.open();\u000a    doc.write('<html><s' + 'cript>' +\u000a              'document.domain="' + global.document.domain + '";' +\u000a              '</s' + 'cript></html>');\u000a    doc.close();\u000a    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];\u000a    var c = doc.createElement('div');\u000a    doc.body.appendChild(c);\u000a    iframe = doc.createElement('iframe');\u000a    c.appendChild(iframe);\u000a    iframe.src = iframeUrl;\u000a    iframe.onerror = function() {\u000a      onerror('onerror');\u000a    };\u000a    tref = setTimeout(function() {\u000a      onerror('timeout');\u000a    }, 15000);\u000a    unloadRef = eventUtils.unloadAdd(cleanup);\u000a    return {\u000a      post: post\u000a    , cleanup: cleanup\u000a    , loaded: unattach\u000a    };\u000a  }\u000a};\u000a\u000amodule.exports.iframeEnabled = false;\u000aif (global.document) {\u000a  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\u000a  // huge delay, or not at all.\u000a  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||\u000a    typeof global.postMessage === 'object') && (!browser.isKonqueror());\u000a}\u000a\u000a}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"./browser":44,"./event":46,"debug":54,"json3":57}],48:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000avar logObject = {};\u000a['log', 'debug', 'warn'].forEach(function (level) {\u000a  var levelExists;\u000a\u000a  try {\u000a    levelExists = global.console && global.console[level] && global.console[level].apply;\u000a  } catch(e) {\u000a    // do nothing\u000a  }\u000a\u000a  logObject[level] = levelExists ? function () {\u000a    return global.console[level].apply(global.console, arguments);\u000a  } : (level === 'log' ? function () {} : logObject.log);\u000a});\u000a\u000amodule.exports = logObject;\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{}],49:[function(require,module,exports){\u000a'use strict';\u000a\u000amodule.exports = {\u000a  isObject: function(obj) {\u000a    var type = typeof obj;\u000a    return type === 'function' || type === 'object' && !!obj;\u000a  }\u000a\u000a, extend: function(obj) {\u000a    if (!this.isObject(obj)) {\u000a      return obj;\u000a    }\u000a    var source, prop;\u000a    for (var i = 1, length = arguments.length; i < length; i++) {\u000a      source = arguments[i];\u000a      for (prop in source) {\u000a        if (Object.prototype.hasOwnProperty.call(source, prop)) {\u000a          obj[prop] = source[prop];\u000a        }\u000a      }\u000a    }\u000a    return obj;\u000a  }\u000a};\u000a\u000a},{}],50:[function(require,module,exports){\u000a'use strict';\u000a\u000a/* global crypto:true */\u000avar crypto = require('crypto');\u000a\u000a// This string has length 32, a power of 2, so the modulus doesn't introduce a\u000a// bias.\u000avar _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';\u000amodule.exports = {\u000a  string: function(length) {\u000a    var max = _randomStringChars.length;\u000a    var bytes = crypto.randomBytes(length);\u000a    var ret = [];\u000a    for (var i = 0; i < length; i++) {\u000a      ret.push(_randomStringChars.substr(bytes[i] % max, 1));\u000a    }\u000a    return ret.join('');\u000a  }\u000a\u000a, number: function(max) {\u000a    return Math.floor(Math.random() * max);\u000a  }\u000a\u000a, numberString: function(max) {\u000a    var t = ('' + (max - 1)).length;\u000a    var p = new Array(t + 1).join('0');\u000a    return (p + this.number(max)).slice(-t);\u000a  }\u000a};\u000a\u000a},{"crypto":43}],51:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:utils:transport');\u000a}\u000a\u000amodule.exports = function(availableTransports) {\u000a  return {\u000a    filterToEnabled: function(transportsWhitelist, info) {\u000a      var transports = {\u000a        main: []\u000a      , facade: []\u000a      };\u000a      if (!transportsWhitelist) {\u000a        transportsWhitelist = [];\u000a      } else if (typeof transportsWhitelist === 'string') {\u000a        transportsWhitelist = [transportsWhitelist];\u000a      }\u000a\u000a      availableTransports.forEach(function(trans) {\u000a        if (!trans) {\u000a          return;\u000a        }\u000a\u000a        if (trans.transportName === 'websocket' && info.websocket === false) {\u000a          debug('disabled from server', 'websocket');\u000a          return;\u000a        }\u000a\u000a        if (transportsWhitelist.length &&\u000a            transportsWhitelist.indexOf(trans.transportName) === -1) {\u000a          debug('not in whitelist', trans.transportName);\u000a          return;\u000a        }\u000a\u000a        if (trans.enabled(info)) {\u000a          debug('enabled', trans.transportName);\u000a          transports.main.push(trans);\u000a          if (trans.facadeTransport) {\u000a            transports.facade.push(trans.facadeTransport);\u000a          }\u000a        } else {\u000a          debug('disabled', trans.transportName);\u000a        }\u000a      });\u000a      return transports;\u000a    }\u000a  };\u000a};\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"debug":54}],52:[function(require,module,exports){\u000a(function (process){\u000a'use strict';\u000a\u000avar URL = require('url-parse');\u000a\u000avar debug = function() {};\u000aif (process.env.NODE_ENV !== 'production') {\u000a  debug = require('debug')('sockjs-client:utils:url');\u000a}\u000a\u000amodule.exports = {\u000a  getOrigin: function(url) {\u000a    if (!url) {\u000a      return null;\u000a    }\u000a\u000a    var p = new URL(url);\u000a    if (p.protocol === 'file:') {\u000a      return null;\u000a    }\u000a\u000a    var port = p.port;\u000a    if (!port) {\u000a      port = (p.protocol === 'https:') ? '443' : '80';\u000a    }\u000a\u000a    return p.protocol + '//' + p.hostname + ':' + port;\u000a  }\u000a\u000a, isOriginEqual: function(a, b) {\u000a    var res = this.getOrigin(a) === this.getOrigin(b);\u000a    debug('same', a, b, res);\u000a    return res;\u000a  }\u000a\u000a, isSchemeEqual: function(a, b) {\u000a    return (a.split(':')[0] === b.split(':')[0]);\u000a  }\u000a\u000a, addPath: function (url, path) {\u000a    var qs = url.split('?');\u000a    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');\u000a  }\u000a\u000a, addQuery: function (url, q) {\u000a    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));\u000a  }\u000a};\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"debug":54,"url-parse":61}],53:[function(require,module,exports){\u000amodule.exports = '1.1.2';\u000a\u000a},{}],54:[function(require,module,exports){\u000a(function (process){\u000a/**\u000a * This is the web browser implementation of `debug()`.\u000a *\u000a * Expose `debug()` as the module.\u000a */\u000a\u000aexports = module.exports = require('./debug');\u000aexports.log = log;\u000aexports.formatArgs = formatArgs;\u000aexports.save = save;\u000aexports.load = load;\u000aexports.useColors = useColors;\u000aexports.storage = 'undefined' != typeof chrome\u000a               && 'undefined' != typeof chrome.storage\u000a                  ? chrome.storage.local\u000a                  : localstorage();\u000a\u000a/**\u000a * Colors.\u000a */\u000a\u000aexports.colors = [\u000a  'lightseagreen',\u000a  'forestgreen',\u000a  'goldenrod',\u000a  'dodgerblue',\u000a  'darkorchid',\u000a  'crimson'\u000a];\u000a\u000a/**\u000a * Currently only WebKit-based Web Inspectors, Firefox >= v31,\u000a * and the Firebug extension (any Firefox version) are known\u000a * to support "%c" CSS customizations.\u000a *\u000a * TODO: add a `localStorage` variable to explicitly enable/disable colors\u000a */\u000a\u000afunction useColors() {\u000a  // NB: In an Electron preload script, document will be defined but not fully\u000a  // initialized. Since we know we're in Chrome, we'll just detect this case\u000a  // explicitly\u000a  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\u000a    return true;\u000a  }\u000a\u000a  // is webkit? http://stackoverflow.com/a/16459606/376773\u000a  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\u000a  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\u000a    // is firebug? http://stackoverflow.com/a/398120/376773\u000a    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\u000a    // is firefox >= v31?\u000a    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\u000a    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\u005c/(\u005cd+)/) && parseInt(RegExp.$1, 10) >= 31) ||\u000a    // double check webkit in userAgent just in case we are in a worker\u000a    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\u005c/(\u005cd+)/));\u000a}\u000a\u000a/**\u000a * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\u000a */\u000a\u000aexports.formatters.j = function(v) {\u000a  try {\u000a    return JSON.stringify(v);\u000a  } catch (err) {\u000a    return '[UnexpectedJSONParseError]: ' + err.message;\u000a  }\u000a};\u000a\u000a\u000a/**\u000a * Colorize log arguments if enabled.\u000a *\u000a * @api public\u000a */\u000a\u000afunction formatArgs(args) {\u000a  var useColors = this.useColors;\u000a\u000a  args[0] = (useColors ? '%c' : '')\u000a    + this.namespace\u000a    + (useColors ? ' %c' : ' ')\u000a    + args[0]\u000a    + (useColors ? '%c ' : ' ')\u000a    + '+' + exports.humanize(this.diff);\u000a\u000a  if (!useColors) return;\u000a\u000a  var c = 'color: ' + this.color;\u000a  args.splice(1, 0, c, 'color: inherit')\u000a\u000a  // the final "%c" is somewhat tricky, because there could be other\u000a  // arguments passed either before or after the %c, so we need to\u000a  // figure out the correct index to insert the CSS into\u000a  var index = 0;\u000a  var lastC = 0;\u000a  args[0].replace(/%[a-zA-Z%]/g, function(match) {\u000a    if ('%%' === match) return;\u000a    index++;\u000a    if ('%c' === match) {\u000a      // we only are interested in the *last* %c\u000a      // (the user may have provided their own)\u000a      lastC = index;\u000a    }\u000a  });\u000a\u000a  args.splice(lastC, 0, c);\u000a}\u000a\u000a/**\u000a * Invokes `console.log()` when available.\u000a * No-op when `console.log` is not a "function".\u000a *\u000a * @api public\u000a */\u000a\u000afunction log() {\u000a  // this hackery is required for IE8/9, where\u000a  // the `console.log` function doesn't have 'apply'\u000a  return 'object' === typeof console\u000a    && console.log\u000a    && Function.prototype.apply.call(console.log, console, arguments);\u000a}\u000a\u000a/**\u000a * Save `namespaces`.\u000a *\u000a * @param {String} namespaces\u000a * @api private\u000a */\u000a\u000afunction save(namespaces) {\u000a  try {\u000a    if (null == namespaces) {\u000a      exports.storage.removeItem('debug');\u000a    } else {\u000a      exports.storage.debug = namespaces;\u000a    }\u000a  } catch(e) {}\u000a}\u000a\u000a/**\u000a * Load `namespaces`.\u000a *\u000a * @return {String} returns the previously persisted debug modes\u000a * @api private\u000a */\u000a\u000afunction load() {\u000a  try {\u000a    return exports.storage.debug;\u000a  } catch(e) {}\u000a\u000a  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\u000a  if (typeof process !== 'undefined' && 'env' in process) {\u000a    return process.env.DEBUG;\u000a  }\u000a}\u000a\u000a/**\u000a * Enable namespaces listed in `localStorage.debug` initially.\u000a */\u000a\u000aexports.enable(load());\u000a\u000a/**\u000a * Localstorage attempts to return the localstorage.\u000a *\u000a * This is necessary because safari throws\u000a * when a user disables cookies/localstorage\u000a * and you attempt to access it.\u000a *\u000a * @return {LocalStorage}\u000a * @api private\u000a */\u000a\u000afunction localstorage() {\u000a  try {\u000a    return window.localStorage;\u000a  } catch (e) {}\u000a}\u000a\u000a}).call(this,{ env: {} })\u000a\u000a},{"./debug":55}],55:[function(require,module,exports){\u000a\u000a/**\u000a * This is the common logic for both the Node.js and web browser\u000a * implementations of `debug()`.\u000a *\u000a * Expose `debug()` as the module.\u000a */\u000a\u000aexports = module.exports = createDebug.debug = createDebug.default = createDebug;\u000aexports.coerce = coerce;\u000aexports.disable = disable;\u000aexports.enable = enable;\u000aexports.enabled = enabled;\u000aexports.humanize = require('ms');\u000a\u000a/**\u000a * The currently active debug mode names, and names to skip.\u000a */\u000a\u000aexports.names = [];\u000aexports.skips = [];\u000a\u000a/**\u000a * Map of special "%n" handling functions, for the debug "format" argument.\u000a *\u000a * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".\u000a */\u000a\u000aexports.formatters = {};\u000a\u000a/**\u000a * Previous log timestamp.\u000a */\u000a\u000avar prevTime;\u000a\u000a/**\u000a * Select a color.\u000a * @param {String} namespace\u000a * @return {Number}\u000a * @api private\u000a */\u000a\u000afunction selectColor(namespace) {\u000a  var hash = 0, i;\u000a\u000a  for (i in namespace) {\u000a    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\u000a    hash |= 0; // Convert to 32bit integer\u000a  }\u000a\u000a  return exports.colors[Math.abs(hash) % exports.colors.length];\u000a}\u000a\u000a/**\u000a * Create a debugger with the given `namespace`.\u000a *\u000a * @param {String} namespace\u000a * @return {Function}\u000a * @api public\u000a */\u000a\u000afunction createDebug(namespace) {\u000a\u000a  function debug() {\u000a    // disabled?\u000a    if (!debug.enabled) return;\u000a\u000a    var self = debug;\u000a\u000a    // set `diff` timestamp\u000a    var curr = +new Date();\u000a    var ms = curr - (prevTime || curr);\u000a    self.diff = ms;\u000a    self.prev = prevTime;\u000a    self.curr = curr;\u000a    prevTime = curr;\u000a\u000a    // turn the `arguments` into a proper Array\u000a    var args = new Array(arguments.length);\u000a    for (var i = 0; i < args.length; i++) {\u000a      args[i] = arguments[i];\u000a    }\u000a\u000a    args[0] = exports.coerce(args[0]);\u000a\u000a    if ('string' !== typeof args[0]) {\u000a      // anything else let's inspect with %O\u000a      args.unshift('%O');\u000a    }\u000a\u000a    // apply any `formatters` transformations\u000a    var index = 0;\u000a    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\u000a      // if we encounter an escaped % then don't increase the array index\u000a      if (match === '%%') return match;\u000a      index++;\u000a      var formatter = exports.formatters[format];\u000a      if ('function' === typeof formatter) {\u000a        var val = args[index];\u000a        match = formatter.call(self, val);\u000a\u000a        // now we need to remove `args[index]` since it's inlined in the `format`\u000a        args.splice(index, 1);\u000a        index--;\u000a      }\u000a      return match;\u000a    });\u000a\u000a    // apply env-specific formatting (colors, etc.)\u000a    exports.formatArgs.call(self, args);\u000a\u000a    var logFn = debug.log || exports.log || console.log.bind(console);\u000a    logFn.apply(self, args);\u000a  }\u000a\u000a  debug.namespace = namespace;\u000a  debug.enabled = exports.enabled(namespace);\u000a  debug.useColors = exports.useColors();\u000a  debug.color = selectColor(namespace);\u000a\u000a  // env-specific initialization logic for debug instances\u000a  if ('function' === typeof exports.init) {\u000a    exports.init(debug);\u000a  }\u000a\u000a  return debug;\u000a}\u000a\u000a/**\u000a * Enables a debug mode by namespaces. This can include modes\u000a * separated by a colon and wildcards.\u000a *\u000a * @param {String} namespaces\u000a * @api public\u000a */\u000a\u000afunction enable(namespaces) {\u000a  exports.save(namespaces);\u000a\u000a  var split = (namespaces || '').split(/[\u005cs,]+/);\u000a  var len = split.length;\u000a\u000a  for (var i = 0; i < len; i++) {\u000a    if (!split[i]) continue; // ignore empty strings\u000a    namespaces = split[i].replace(/\u005c*/g, '.*?');\u000a    if (namespaces[0] === '-') {\u000a      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\u000a    } else {\u000a      exports.names.push(new RegExp('^' + namespaces + '$'));\u000a    }\u000a  }\u000a}\u000a\u000a/**\u000a * Disable debug output.\u000a *\u000a * @api public\u000a */\u000a\u000afunction disable() {\u000a  exports.enable('');\u000a}\u000a\u000a/**\u000a * Returns true if the given mode name is enabled, false otherwise.\u000a *\u000a * @param {String} name\u000a * @return {Boolean}\u000a * @api public\u000a */\u000a\u000afunction enabled(name) {\u000a  var i, len;\u000a  for (i = 0, len = exports.skips.length; i < len; i++) {\u000a    if (exports.skips[i].test(name)) {\u000a      return false;\u000a    }\u000a  }\u000a  for (i = 0, len = exports.names.length; i < len; i++) {\u000a    if (exports.names[i].test(name)) {\u000a      return true;\u000a    }\u000a  }\u000a  return false;\u000a}\u000a\u000a/**\u000a * Coerce `val`.\u000a *\u000a * @param {Mixed} val\u000a * @return {Mixed}\u000a * @api private\u000a */\u000a\u000afunction coerce(val) {\u000a  if (val instanceof Error) return val.stack || val.message;\u000a  return val;\u000a}\u000a\u000a},{"ms":58}],56:[function(require,module,exports){\u000aif (typeof Object.create === 'function') {\u000a  // implementation from standard node.js 'util' module\u000a  module.exports = function inherits(ctor, superCtor) {\u000a    ctor.super_ = superCtor\u000a    ctor.prototype = Object.create(superCtor.prototype, {\u000a      constructor: {\u000a        value: ctor,\u000a        enumerable: false,\u000a        writable: true,\u000a        configurable: true\u000a      }\u000a    });\u000a  };\u000a} else {\u000a  // old school shim for old browsers\u000a  module.exports = function inherits(ctor, superCtor) {\u000a    ctor.super_ = superCtor\u000a    var TempCtor = function () {}\u000a    TempCtor.prototype = superCtor.prototype\u000a    ctor.prototype = new TempCtor()\u000a    ctor.prototype.constructor = ctor\u000a  }\u000a}\u000a\u000a},{}],57:[function(require,module,exports){\u000a(function (global){\u000a/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\u000a;(function () {\u000a  // Detect the `define` function exposed by asynchronous module loaders. The\u000a  // strict `define` check is necessary for compatibility with `r.js`.\u000a  var isLoader = typeof define === "function" && define.amd;\u000a\u000a  // A set of types used to distinguish objects from primitives.\u000a  var objectTypes = {\u000a    "function": true,\u000a    "object": true\u000a  };\u000a\u000a  // Detect the `exports` object exposed by CommonJS implementations.\u000a  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\u000a\u000a  // Use the `global` object exposed by Node (including Browserify via\u000a  // `insert-module-globals`), Narwhal, and Ringo as the default context,\u000a  // and the `window` object in browsers. Rhino exports a `global` function\u000a  // instead.\u000a  var root = objectTypes[typeof window] && window || this,\u000a      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;\u000a\u000a  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {\u000a    root = freeGlobal;\u000a  }\u000a\u000a  // Public: Initializes JSON 3 using the given `context` object, attaching the\u000a  // `stringify` and `parse` functions to the specified `exports` object.\u000a  function runInContext(context, exports) {\u000a    context || (context = root["Object"]());\u000a    exports || (exports = root["Object"]());\u000a\u000a    // Native constructor aliases.\u000a    var Number = context["Number"] || root["Number"],\u000a        String = context["String"] || root["String"],\u000a        Object = context["Object"] || root["Object"],\u000a        Date = context["Date"] || root["Date"],\u000a        SyntaxError = context["SyntaxError"] || root["SyntaxError"],\u000a        TypeError = context["TypeError"] || root["TypeError"],\u000a        Math = context["Math"] || root["Math"],\u000a        nativeJSON = context["JSON"] || root["JSON"];\u000a\u000a    // Delegate to the native `stringify` and `parse` implementations.\u000a    if (typeof nativeJSON == "object" && nativeJSON) {\u000a      exports.stringify = nativeJSON.stringify;\u000a      exports.parse = nativeJSON.parse;\u000a    }\u000a\u000a    // Convenience aliases.\u000a    var objectProto = Object.prototype,\u000a        getClass = objectProto.toString,\u000a        isProperty, forEach, undef;\u000a\u000a    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\u000a    var isExtended = new Date(-3509827334573292);\u000a    try {\u000a      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\u000a      // results for certain dates in Opera >= 10.53.\u000a      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\u000a        // Safari < 2.0.2 stores the internal millisecond time value correctly,\u000a        // but clips the values returned by the date methods to the range of\u000a        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\u000a        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\u000a    } catch (exception) {}\u000a\u000a    // Internal: Determines whether the native `JSON.stringify` and `parse`\u000a    // implementations are spec-compliant. Based on work by Ken Snyder.\u000a    function has(name) {\u000a      if (has[name] !== undef) {\u000a        // Return cached feature test result.\u000a        return has[name];\u000a      }\u000a      var isSupported;\u000a      if (name == "bug-string-char-index") {\u000a        // IE <= 7 doesn't support accessing string characters using square\u000a        // bracket notation. IE 8 only supports this for primitives.\u000a        isSupported = "a"[0] != "a";\u000a      } else if (name == "json") {\u000a        // Indicates whether both `JSON.stringify` and `JSON.parse` are\u000a        // supported.\u000a        isSupported = has("json-stringify") && has("json-parse");\u000a      } else {\u000a        var value, serialized = '{"a":[1,true,false,null,"\u005c\u005cu0000\u005c\u005cb\u005c\u005cn\u005c\u005cf\u005c\u005cr\u005c\u005ct"]}';\u000a        // Test `JSON.stringify`.\u000a        if (name == "json-stringify") {\u000a          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;\u000a          if (stringifySupported) {\u000a            // A test function object with a custom `toJSON` method.\u000a            (value = function () {\u000a              return 1;\u000a            }).toJSON = value;\u000a            try {\u000a              stringifySupported =\u000a                // Firefox 3.1b1 and b2 serialize string, number, and boolean\u000a                // primitives as object literals.\u000a                stringify(0) === "0" &&\u000a                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\u000a                // literals.\u000a                stringify(new Number()) === "0" &&\u000a                stringify(new String()) == '""' &&\u000a                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\u000a                // does not define a canonical JSON representation (this applies to\u000a                // objects with `toJSON` properties as well, *unless* they are nested\u000a                // within an object or array).\u000a                stringify(getClass) === undef &&\u000a                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and\u000a                // FF 3.1b3 pass this test.\u000a                stringify(undef) === undef &&\u000a                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\u000a                // respectively, if the value is omitted entirely.\u000a                stringify() === undef &&\u000a                // FF 3.1b1, 2 throw an error if the given value is not a number,\u000a                // string, array, object, Boolean, or `null` literal. This applies to\u000a                // objects with custom `toJSON` methods as well, unless they are nested\u000a                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\u000a                // methods entirely.\u000a                stringify(value) === "1" &&\u000a                stringify([value]) == "[1]" &&\u000a                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of\u000a                // `"[null]"`.\u000a                stringify([undef]) == "[null]" &&\u000a                // YUI 3.0.0b1 fails to serialize `null` literals.\u000a                stringify(null) == "null" &&\u000a                // FF 3.1b1, 2 halts serialization if an array contains a function:\u000a                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3\u000a                // elides non-JSON values from objects and arrays, unless they\u000a                // define custom `toJSON` methods.\u000a                stringify([undef, getClass, null]) == "[null,null,null]" &&\u000a                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\u000a                // where character escape codes are expected (e.g., `\u005cb` => `\u005cu0008`).\u000a                stringify({ "a": [value, true, false, null, "\u005cx00\u005cb\u005cn\u005cf\u005cr\u005ct"] }) == serialized &&\u000a                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\u000a                stringify(null, value) === "1" &&\u000a                stringify([1, 2], null, 1) == "[\u005cn 1,\u005cn 2\u005cn]" &&\u000a                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\u000a                // serialize extended years.\u000a                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&\u000a                // The milliseconds are optional in ES 5, but required in 5.1.\u000a                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&\u000a                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\u000a                // four-digit years instead of six-digit years. Credits: @Yaffle.\u000a                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&\u000a                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\u000a                // values less than 1000. Credits: @Yaffle.\u000a                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';\u000a            } catch (exception) {\u000a              stringifySupported = false;\u000a            }\u000a          }\u000a          isSupported = stringifySupported;\u000a        }\u000a        // Test `JSON.parse`.\u000a        if (name == "json-parse") {\u000a          var parse = exports.parse;\u000a          if (typeof parse == "function") {\u000a            try {\u000a              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\u000a              // Conforming implementations should also coerce the initial argument to\u000a              // a string prior to parsing.\u000a              if (parse("0") === 0 && !parse(false)) {\u000a                // Simple parsing test.\u000a                value = parse(serialized);\u000a                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;\u000a                if (parseSupported) {\u000a                  try {\u000a                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\u000a                    parseSupported = !parse('"\u005ct"');\u000a                  } catch (exception) {}\u000a                  if (parseSupported) {\u000a                    try {\u000a                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\u000a                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\u000a                      // certain octal literals.\u000a                      parseSupported = parse("01") !== 1;\u000a                    } catch (exception) {}\u000a                  }\u000a                  if (parseSupported) {\u000a                    try {\u000a                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\u000a                      // points. These environments, along with FF 3.1b1 and 2,\u000a                      // also allow trailing commas in JSON objects and arrays.\u000a                      parseSupported = parse("1.") !== 1;\u000a                    } catch (exception) {}\u000a                  }\u000a                }\u000a              }\u000a            } catch (exception) {\u000a              parseSupported = false;\u000a            }\u000a          }\u000a          isSupported = parseSupported;\u000a        }\u000a      }\u000a      return has[name] = !!isSupported;\u000a    }\u000a\u000a    if (!has("json")) {\u000a      // Common `[[Class]]` name aliases.\u000a      var functionClass = "[object Function]",\u000a          dateClass = "[object Date]",\u000a          numberClass = "[object Number]",\u000a          stringClass = "[object String]",\u000a          arrayClass = "[object Array]",\u000a          booleanClass = "[object Boolean]";\u000a\u000a      // Detect incomplete support for accessing string characters by index.\u000a      var charIndexBuggy = has("bug-string-char-index");\u000a\u000a      // Define additional utility methods if the `Date` methods are buggy.\u000a      if (!isExtended) {\u000a        var floor = Math.floor;\u000a        // A mapping between the months of the year and the number of days between\u000a        // January 1st and the first of the respective month.\u000a        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\u000a        // Internal: Calculates the number of days between the Unix epoch and the\u000a        // first day of the given month.\u000a        var getDay = function (year, month) {\u000a          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\u000a        };\u000a      }\u000a\u000a      // Internal: Determines if a property is a direct property of the given\u000a      // object. Delegates to the native `Object#hasOwnProperty` method.\u000a      if (!(isProperty = objectProto.hasOwnProperty)) {\u000a        isProperty = function (property) {\u000a          var members = {}, constructor;\u000a          if ((members.__proto__ = null, members.__proto__ = {\u000a            // The *proto* property cannot be set multiple times in recent\u000a            // versions of Firefox and SeaMonkey.\u000a            "toString": 1\u000a          }, members).toString != getClass) {\u000a            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\u000a            // supports the mutable *proto* property.\u000a            isProperty = function (property) {\u000a              // Capture and break the object's prototype chain (see section 8.6.2\u000a              // of the ES 5.1 spec). The parenthesized expression prevents an\u000a              // unsafe transformation by the Closure Compiler.\u000a              var original = this.__proto__, result = property in (this.__proto__ = null, this);\u000a              // Restore the original prototype chain.\u000a              this.__proto__ = original;\u000a              return result;\u000a            };\u000a          } else {\u000a            // Capture a reference to the top-level `Object` constructor.\u000a            constructor = members.constructor;\u000a            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\u000a            // other environments.\u000a            isProperty = function (property) {\u000a              var parent = (this.constructor || constructor).prototype;\u000a              return property in this && !(property in parent && this[property] === parent[property]);\u000a            };\u000a          }\u000a          members = null;\u000a          return isProperty.call(this, property);\u000a        };\u000a      }\u000a\u000a      // Internal: Normalizes the `for...in` iteration algorithm across\u000a      // environments. Each enumerated key is yielded to a `callback` function.\u000a      forEach = function (object, callback) {\u000a        var size = 0, Properties, members, property;\u000a\u000a        // Tests for bugs in the current environment's `for...in` algorithm. The\u000a        // `valueOf` property inherits the non-enumerable flag from\u000a        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\u000a        (Properties = function () {\u000a          this.valueOf = 0;\u000a        }).prototype.valueOf = 0;\u000a\u000a        // Iterate over a new instance of the `Properties` class.\u000a        members = new Properties();\u000a        for (property in members) {\u000a          // Ignore all properties inherited from `Object.prototype`.\u000a          if (isProperty.call(members, property)) {\u000a            size++;\u000a          }\u000a        }\u000a        Properties = members = null;\u000a\u000a        // Normalize the iteration algorithm.\u000a        if (!size) {\u000a          // A list of non-enumerable properties inherited from `Object.prototype`.\u000a          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];\u000a          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\u000a          // properties.\u000a          forEach = function (object, callback) {\u000a            var isFunction = getClass.call(object) == functionClass, property, length;\u000a            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\u000a            for (property in object) {\u000a              // Gecko <= 1.0 enumerates the `prototype` property of functions under\u000a              // certain conditions; IE does not.\u000a              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {\u000a                callback(property);\u000a              }\u000a            }\u000a            // Manually invoke the callback for each non-enumerable property.\u000a            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\u000a          };\u000a        } else if (size == 2) {\u000a          // Safari <= 2.0.4 enumerates shadowed properties twice.\u000a          forEach = function (object, callback) {\u000a            // Create a set of iterated properties.\u000a            var members = {}, isFunction = getClass.call(object) == functionClass, property;\u000a            for (property in object) {\u000a              // Store each property name to prevent double enumeration. The\u000a              // `prototype` property of functions is not enumerated due to cross-\u000a              // environment inconsistencies.\u000a              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\u000a                callback(property);\u000a              }\u000a            }\u000a          };\u000a        } else {\u000a          // No bugs detected; use the standard `for...in` algorithm.\u000a          forEach = function (object, callback) {\u000a            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\u000a            for (property in object) {\u000a              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {\u000a                callback(property);\u000a              }\u000a            }\u000a            // Manually invoke the callback for the `constructor` property due to\u000a            // cross-environment inconsistencies.\u000a            if (isConstructor || isProperty.call(object, (property = "constructor"))) {\u000a              callback(property);\u000a            }\u000a          };\u000a        }\u000a        return forEach(object, callback);\u000a      };\u000a\u000a      // Public: Serializes a JavaScript `value` as a JSON string. The optional\u000a      // `filter` argument may specify either a function that alters how object and\u000a      // array members are serialized, or an array of strings and numbers that\u000a      // indicates which properties should be serialized. The optional `width`\u000a      // argument may be either a string or number that specifies the indentation\u000a      // level of the output.\u000a      if (!has("json-stringify")) {\u000a        // Internal: A map of control characters and their escaped equivalents.\u000a        var Escapes = {\u000a          92: "\u005c\u005c\u005c\u005c",\u000a          34: '\u005c\u005c"',\u000a          8: "\u005c\u005cb",\u000a          12: "\u005c\u005cf",\u000a          10: "\u005c\u005cn",\u000a          13: "\u005c\u005cr",\u000a          9: "\u005c\u005ct"\u000a        };\u000a\u000a        // Internal: Converts `value` into a zero-padded string such that its\u000a        // length is at least equal to `width`. The `width` must be <= 6.\u000a        var leadingZeroes = "000000";\u000a        var toPaddedString = function (width, value) {\u000a          // The `|| 0` expression is necessary to work around a bug in\u000a          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.\u000a          return (leadingZeroes + (value || 0)).slice(-width);\u000a        };\u000a\u000a        // Internal: Double-quotes a string `value`, replacing all ASCII control\u000a        // characters (characters with code unit values between 0 and 31) with\u000a        // their escaped equivalents. This is an implementation of the\u000a        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\u000a        var unicodePrefix = "\u005c\u005cu00";\u000a        var quote = function (value) {\u000a          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\u000a          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);\u000a          for (; index < length; index++) {\u000a            var charCode = value.charCodeAt(index);\u000a            // If the character is a control character, append its Unicode or\u000a            // shorthand escape sequence; otherwise, append the character as-is.\u000a            switch (charCode) {\u000a              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\u000a                result += Escapes[charCode];\u000a                break;\u000a              default:\u000a                if (charCode < 32) {\u000a                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\u000a                  break;\u000a                }\u000a                result += useCharIndex ? symbols[index] : value.charAt(index);\u000a            }\u000a          }\u000a          return result + '"';\u000a        };\u000a\u000a        // Internal: Recursively serializes an object. Implements the\u000a        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\u000a        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\u000a          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\u000a          try {\u000a            // Necessary for host object support.\u000a            value = object[property];\u000a          } catch (exception) {}\u000a          if (typeof value == "object" && value) {\u000a            className = getClass.call(value);\u000a            if (className == dateClass && !isProperty.call(value, "toJSON")) {\u000a              if (value > -1 / 0 && value < 1 / 0) {\u000a                // Dates are serialized according to the `Date#toJSON` method\u000a                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\u000a                // for the ISO 8601 date time string format.\u000a                if (getDay) {\u000a                  // Manually compute the year, month, date, hours, minutes,\u000a                  // seconds, and milliseconds if the `getUTC*` methods are\u000a                  // buggy. Adapted from @Yaffle's `date-shim` project.\u000a                  date = floor(value / 864e5);\u000a                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\u000a                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\u000a                  date = 1 + date - getDay(year, month);\u000a                  // The `time` value specifies the time within the day (see ES\u000a                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\u000a                  // to compute `A modulo B`, as the `%` operator does not\u000a                  // correspond to the `modulo` operation for negative numbers.\u000a                  time = (value % 864e5 + 864e5) % 864e5;\u000a                  // The hours, minutes, seconds, and milliseconds are obtained by\u000a                  // decomposing the time within the day. See section 15.9.1.10.\u000a                  hours = floor(time / 36e5) % 24;\u000a                  minutes = floor(time / 6e4) % 60;\u000a                  seconds = floor(time / 1e3) % 60;\u000a                  milliseconds = time % 1e3;\u000a                } else {\u000a                  year = value.getUTCFullYear();\u000a                  month = value.getUTCMonth();\u000a                  date = value.getUTCDate();\u000a                  hours = value.getUTCHours();\u000a                  minutes = value.getUTCMinutes();\u000a                  seconds = value.getUTCSeconds();\u000a                  milliseconds = value.getUTCMilliseconds();\u000a                }\u000a                // Serialize extended years correctly.\u000a                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\u000a                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +\u000a                  // Months, dates, hours, minutes, and seconds should have two\u000a                  // digits; milliseconds should have three.\u000a                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +\u000a                  // Milliseconds are optional in ES 5.0, but required in 5.1.\u000a                  "." + toPaddedString(3, milliseconds) + "Z";\u000a              } else {\u000a                value = null;\u000a              }\u000a            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {\u000a              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\u000a              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\u000a              // ignores all `toJSON` methods on these objects unless they are\u000a              // defined directly on an instance.\u000a              value = value.toJSON(property);\u000a            }\u000a          }\u000a          if (callback) {\u000a            // If a replacement function was provided, call it to obtain the value\u000a            // for serialization.\u000a            value = callback.call(object, property, value);\u000a          }\u000a          if (value === null) {\u000a            return "null";\u000a          }\u000a          className = getClass.call(value);\u000a          if (className == booleanClass) {\u000a            // Booleans are represented literally.\u000a            return "" + value;\u000a          } else if (className == numberClass) {\u000a            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\u000a            // `"null"`.\u000a            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";\u000a          } else if (className == stringClass) {\u000a            // Strings are double-quoted and escaped.\u000a            return quote("" + value);\u000a          }\u000a          // Recursively serialize objects and arrays.\u000a          if (typeof value == "object") {\u000a            // Check for cyclic structures. This is a linear search; performance\u000a            // is inversely proportional to the number of unique nested objects.\u000a            for (length = stack.length; length--;) {\u000a              if (stack[length] === value) {\u000a                // Cyclic structures cannot be serialized by `JSON.stringify`.\u000a                throw TypeError();\u000a              }\u000a            }\u000a            // Add the object to the stack of traversed objects.\u000a            stack.push(value);\u000a            results = [];\u000a            // Save the current indentation level and indent one additional level.\u000a            prefix = indentation;\u000a            indentation += whitespace;\u000a            if (className == arrayClass) {\u000a              // Recursively serialize array elements.\u000a              for (index = 0, length = value.length; index < length; index++) {\u000a                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\u000a                results.push(element === undef ? "null" : element);\u000a              }\u000a              result = results.length ? (whitespace ? "[\u005cn" + indentation + results.join(",\u005cn" + indentation) + "\u005cn" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";\u000a            } else {\u000a              // Recursively serialize object members. Members are selected from\u000a              // either a user-specified list of property names, or the object\u000a              // itself.\u000a              forEach(properties || value, function (property) {\u000a                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\u000a                if (element !== undef) {\u000a                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}\u000a                  // is not the empty string, let `member` {quote(property) + ":"}\u000a                  // be the concatenation of `member` and the `space` character."\u000a                  // The "`space` character" refers to the literal space\u000a                  // character, not the `space` {width} argument provided to\u000a                  // `JSON.stringify`.\u000a                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);\u000a                }\u000a              });\u000a              result = results.length ? (whitespace ? "{\u005cn" + indentation + results.join(",\u005cn" + indentation) + "\u005cn" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";\u000a            }\u000a            // Remove the object from the traversed object stack.\u000a            stack.pop();\u000a            return result;\u000a          }\u000a        };\u000a\u000a        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\u000a        exports.stringify = function (source, filter, width) {\u000a          var whitespace, callback, properties, className;\u000a          if (objectTypes[typeof filter] && filter) {\u000a            if ((className = getClass.call(filter)) == functionClass) {\u000a              callback = filter;\u000a            } else if (className == arrayClass) {\u000a              // Convert the property names array into a makeshift set.\u000a              properties = {};\u000a              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\u000a            }\u000a          }\u000a          if (width) {\u000a            if ((className = getClass.call(width)) == numberClass) {\u000a              // Convert the `width` to an integer and create a string containing\u000a              // `width` number of space characters.\u000a              if ((width -= width % 1) > 0) {\u000a                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");\u000a              }\u000a            } else if (className == stringClass) {\u000a              whitespace = width.length <= 10 ? width : width.slice(0, 10);\u000a            }\u000a          }\u000a          // Opera <= 7.54u2 discards the values associated with empty string keys\u000a          // (`""`) only if they are used directly within an object member list\u000a          // (e.g., `!("" in { "": 1})`).\u000a          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);\u000a        };\u000a      }\u000a\u000a      // Public: Parses a JSON source string.\u000a      if (!has("json-parse")) {\u000a        var fromCharCode = String.fromCharCode;\u000a\u000a        // Internal: A map of escaped control characters and their unescaped\u000a        // equivalents.\u000a        var Unescapes = {\u000a          92: "\u005c\u005c",\u000a          34: '"',\u000a          47: "/",\u000a          98: "\u005cb",\u000a          116: "\u005ct",\u000a          110: "\u005cn",\u000a          102: "\u005cf",\u000a          114: "\u005cr"\u000a        };\u000a\u000a        // Internal: Stores the parser state.\u000a        var Index, Source;\u000a\u000a        // Internal: Resets the parser state and throws a `SyntaxError`.\u000a        var abort = function () {\u000a          Index = Source = null;\u000a          throw SyntaxError();\u000a        };\u000a\u000a        // Internal: Returns the next token, or `"$"` if the parser has reached\u000a        // the end of the source string. A token may be a string, number, `null`\u000a        // literal, or Boolean literal.\u000a        var lex = function () {\u000a          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\u000a          while (Index < length) {\u000a            charCode = source.charCodeAt(Index);\u000a            switch (charCode) {\u000a              case 9: case 10: case 13: case 32:\u000a                // Skip whitespace tokens, including tabs, carriage returns, line\u000a                // feeds, and space characters.\u000a                Index++;\u000a                break;\u000a              case 123: case 125: case 91: case 93: case 58: case 44:\u000a                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\u000a                // the current position.\u000a                value = charIndexBuggy ? source.charAt(Index) : source[Index];\u000a                Index++;\u000a                return value;\u000a              case 34:\u000a                // `"` delimits a JSON string; advance to the next character and\u000a                // begin parsing the string. String tokens are prefixed with the\u000a                // sentinel `@` character to distinguish them from punctuators and\u000a                // end-of-string tokens.\u000a                for (value = "@", Index++; Index < length;) {\u000a                  charCode = source.charCodeAt(Index);\u000a                  if (charCode < 32) {\u000a                    // Unescaped ASCII control characters (those with a code unit\u000a                    // less than the space character) are not permitted.\u000a                    abort();\u000a                  } else if (charCode == 92) {\u000a                    // A reverse solidus (`\u005c`) marks the beginning of an escaped\u000a                    // control character (including `"`, `\u005c`, and `/`) or Unicode\u000a                    // escape sequence.\u000a                    charCode = source.charCodeAt(++Index);\u000a                    switch (charCode) {\u000a                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\u000a                        // Revive escaped control characters.\u000a                        value += Unescapes[charCode];\u000a                        Index++;\u000a                        break;\u000a                      case 117:\u000a                        // `\u005cu` marks the beginning of a Unicode escape sequence.\u000a                        // Advance to the first character and validate the\u000a                        // four-digit code point.\u000a                        begin = ++Index;\u000a                        for (position = Index + 4; Index < position; Index++) {\u000a                          charCode = source.charCodeAt(Index);\u000a                          // A valid sequence comprises four hexdigits (case-\u000a                          // insensitive) that form a single hexadecimal value.\u000a                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\u000a                            // Invalid Unicode escape sequence.\u000a                            abort();\u000a                          }\u000a                        }\u000a                        // Revive the escaped character.\u000a                        value += fromCharCode("0x" + source.slice(begin, Index));\u000a                        break;\u000a                      default:\u000a                        // Invalid escape sequence.\u000a                        abort();\u000a                    }\u000a                  } else {\u000a                    if (charCode == 34) {\u000a                      // An unescaped double-quote character marks the end of the\u000a                      // string.\u000a                      break;\u000a                    }\u000a                    charCode = source.charCodeAt(Index);\u000a                    begin = Index;\u000a                    // Optimize for the common case where a string is valid.\u000a                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\u000a                      charCode = source.charCodeAt(++Index);\u000a                    }\u000a                    // Append the string as-is.\u000a                    value += source.slice(begin, Index);\u000a                  }\u000a                }\u000a                if (source.charCodeAt(Index) == 34) {\u000a                  // Advance to the next character and return the revived string.\u000a                  Index++;\u000a                  return value;\u000a                }\u000a                // Unterminated string.\u000a                abort();\u000a              default:\u000a                // Parse numbers and literals.\u000a                begin = Index;\u000a                // Advance past the negative sign, if one is specified.\u000a                if (charCode == 45) {\u000a                  isSigned = true;\u000a                  charCode = source.charCodeAt(++Index);\u000a                }\u000a                // Parse an integer or floating-point value.\u000a                if (charCode >= 48 && charCode <= 57) {\u000a                  // Leading zeroes are interpreted as octal literals.\u000a                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\u000a                    // Illegal octal literal.\u000a                    abort();\u000a                  }\u000a                  isSigned = false;\u000a                  // Parse the integer component.\u000a                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\u000a                  // Floats cannot contain a leading decimal point; however, this\u000a                  // case is already accounted for by the parser.\u000a                  if (source.charCodeAt(Index) == 46) {\u000a                    position = ++Index;\u000a                    // Parse the decimal component.\u000a                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\u000a                    if (position == Index) {\u000a                      // Illegal trailing decimal.\u000a                      abort();\u000a                    }\u000a                    Index = position;\u000a                  }\u000a                  // Parse exponents. The `e` denoting the exponent is\u000a                  // case-insensitive.\u000a                  charCode = source.charCodeAt(Index);\u000a                  if (charCode == 101 || charCode == 69) {\u000a                    charCode = source.charCodeAt(++Index);\u000a                    // Skip past the sign following the exponent, if one is\u000a                    // specified.\u000a                    if (charCode == 43 || charCode == 45) {\u000a                      Index++;\u000a                    }\u000a                    // Parse the exponential component.\u000a                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\u000a                    if (position == Index) {\u000a                      // Illegal empty exponent.\u000a                      abort();\u000a                    }\u000a                    Index = position;\u000a                  }\u000a                  // Coerce the parsed value to a JavaScript number.\u000a                  return +source.slice(begin, Index);\u000a                }\u000a                // A negative sign may only precede numbers.\u000a                if (isSigned) {\u000a                  abort();\u000a                }\u000a                // `true`, `false`, and `null` literals.\u000a                if (source.slice(Index, Index + 4) == "true") {\u000a                  Index += 4;\u000a                  return true;\u000a                } else if (source.slice(Index, Index + 5) == "false") {\u000a                  Index += 5;\u000a                  return false;\u000a                } else if (source.slice(Index, Index + 4) == "null") {\u000a                  Index += 4;\u000a                  return null;\u000a                }\u000a                // Unrecognized token.\u000a                abort();\u000a            }\u000a          }\u000a          // Return the sentinel `$` character if the parser has reached the end\u000a          // of the source string.\u000a          return "$";\u000a        };\u000a\u000a        // Internal: Parses a JSON `value` token.\u000a        var get = function (value) {\u000a          var results, hasMembers;\u000a          if (value == "$") {\u000a            // Unexpected end of input.\u000a            abort();\u000a          }\u000a          if (typeof value == "string") {\u000a            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {\u000a              // Remove the sentinel `@` character.\u000a              return value.slice(1);\u000a            }\u000a            // Parse object and array literals.\u000a            if (value == "[") {\u000a              // Parses a JSON array, returning a new JavaScript array.\u000a              results = [];\u000a              for (;; hasMembers || (hasMembers = true)) {\u000a                value = lex();\u000a                // A closing square bracket marks the end of the array literal.\u000a                if (value == "]") {\u000a                  break;\u000a                }\u000a                // If the array literal contains elements, the current token\u000a                // should be a comma separating the previous element from the\u000a                // next.\u000a                if (hasMembers) {\u000a                  if (value == ",") {\u000a                    value = lex();\u000a                    if (value == "]") {\u000a                      // Unexpected trailing `,` in array literal.\u000a                      abort();\u000a                    }\u000a                  } else {\u000a                    // A `,` must separate each array element.\u000a                    abort();\u000a                  }\u000a                }\u000a                // Elisions and leading commas are not permitted.\u000a                if (value == ",") {\u000a                  abort();\u000a                }\u000a                results.push(get(value));\u000a              }\u000a              return results;\u000a            } else if (value == "{") {\u000a              // Parses a JSON object, returning a new JavaScript object.\u000a              results = {};\u000a              for (;; hasMembers || (hasMembers = true)) {\u000a                value = lex();\u000a                // A closing curly brace marks the end of the object literal.\u000a                if (value == "}") {\u000a                  break;\u000a                }\u000a                // If the object literal contains members, the current token\u000a                // should be a comma separator.\u000a                if (hasMembers) {\u000a                  if (value == ",") {\u000a                    value = lex();\u000a                    if (value == "}") {\u000a                      // Unexpected trailing `,` in object literal.\u000a                      abort();\u000a                    }\u000a                  } else {\u000a                    // A `,` must separate each object member.\u000a                    abort();\u000a                  }\u000a                }\u000a                // Leading commas are not permitted, object property names must be\u000a                // double-quoted strings, and a `:` must separate each property\u000a                // name and value.\u000a                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {\u000a                  abort();\u000a                }\u000a                results[value.slice(1)] = get(lex());\u000a              }\u000a              return results;\u000a            }\u000a            // Unexpected token encountered.\u000a            abort();\u000a          }\u000a          return value;\u000a        };\u000a\u000a        // Internal: Updates a traversed object member.\u000a        var update = function (source, property, callback) {\u000a          var element = walk(source, property, callback);\u000a          if (element === undef) {\u000a            delete source[property];\u000a          } else {\u000a            source[property] = element;\u000a          }\u000a        };\u000a\u000a        // Internal: Recursively traverses a parsed JSON object, invoking the\u000a        // `callback` function for each value. This is an implementation of the\u000a        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\u000a        var walk = function (source, property, callback) {\u000a          var value = source[property], length;\u000a          if (typeof value == "object" && value) {\u000a            // `forEach` can't be used to traverse an array in Opera <= 8.54\u000a            // because its `Object#hasOwnProperty` implementation returns `false`\u000a            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).\u000a            if (getClass.call(value) == arrayClass) {\u000a              for (length = value.length; length--;) {\u000a                update(value, length, callback);\u000a              }\u000a            } else {\u000a              forEach(value, function (property) {\u000a                update(value, property, callback);\u000a              });\u000a            }\u000a          }\u000a          return callback.call(source, property, value);\u000a        };\u000a\u000a        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\u000a        exports.parse = function (source, callback) {\u000a          var result, value;\u000a          Index = 0;\u000a          Source = "" + source;\u000a          result = get(lex());\u000a          // If a JSON string contains multiple tokens, it is invalid.\u000a          if (lex() != "$") {\u000a            abort();\u000a          }\u000a          // Reset the parser state.\u000a          Index = Source = null;\u000a          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;\u000a        };\u000a      }\u000a    }\u000a\u000a    exports["runInContext"] = runInContext;\u000a    return exports;\u000a  }\u000a\u000a  if (freeExports && !isLoader) {\u000a    // Export for CommonJS environments.\u000a    runInContext(root, freeExports);\u000a  } else {\u000a    // Export for web browsers and JavaScript engines.\u000a    var nativeJSON = root.JSON,\u000a        previousJSON = root["JSON3"],\u000a        isRestored = false;\u000a\u000a    var JSON3 = runInContext(root, (root["JSON3"] = {\u000a      // Public: Restores the original value of the global `JSON` object and\u000a      // returns a reference to the `JSON3` object.\u000a      "noConflict": function () {\u000a        if (!isRestored) {\u000a          isRestored = true;\u000a          root.JSON = nativeJSON;\u000a          root["JSON3"] = previousJSON;\u000a          nativeJSON = previousJSON = null;\u000a        }\u000a        return JSON3;\u000a      }\u000a    }));\u000a\u000a    root.JSON = {\u000a      "parse": JSON3.parse,\u000a      "stringify": JSON3.stringify\u000a    };\u000a  }\u000a\u000a  // Export for asynchronous module loaders.\u000a  if (isLoader) {\u000a    define(function () {\u000a      return JSON3;\u000a    });\u000a  }\u000a}).call(this);\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{}],58:[function(require,module,exports){\u000a/**\u000a * Helpers.\u000a */\u000a\u000avar s = 1000\u000avar m = s * 60\u000avar h = m * 60\u000avar d = h * 24\u000avar y = d * 365.25\u000a\u000a/**\u000a * Parse or format the given `val`.\u000a *\u000a * Options:\u000a *\u000a *  - `long` verbose formatting [false]\u000a *\u000a * @param {String|Number} val\u000a * @param {Object} options\u000a * @throws {Error} throw an error if val is not a non-empty string or a number\u000a * @return {String|Number}\u000a * @api public\u000a */\u000a\u000amodule.exports = function (val, options) {\u000a  options = options || {}\u000a  var type = typeof val\u000a  if (type === 'string' && val.length > 0) {\u000a    return parse(val)\u000a  } else if (type === 'number' && isNaN(val) === false) {\u000a    return options.long ?\u000a			fmtLong(val) :\u000a			fmtShort(val)\u000a  }\u000a  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\u000a}\u000a\u000a/**\u000a * Parse the given `str` and return milliseconds.\u000a *\u000a * @param {String} str\u000a * @return {Number}\u000a * @api private\u000a */\u000a\u000afunction parse(str) {\u000a  str = String(str)\u000a  if (str.length > 10000) {\u000a    return\u000a  }\u000a  var match = /^((?:\u005cd+)?\u005c.?\u005cd+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\u000a  if (!match) {\u000a    return\u000a  }\u000a  var n = parseFloat(match[1])\u000a  var type = (match[2] || 'ms').toLowerCase()\u000a  switch (type) {\u000a    case 'years':\u000a    case 'year':\u000a    case 'yrs':\u000a    case 'yr':\u000a    case 'y':\u000a      return n * y\u000a    case 'days':\u000a    case 'day':\u000a    case 'd':\u000a      return n * d\u000a    case 'hours':\u000a    case 'hour':\u000a    case 'hrs':\u000a    case 'hr':\u000a    case 'h':\u000a      return n * h\u000a    case 'minutes':\u000a    case 'minute':\u000a    case 'mins':\u000a    case 'min':\u000a    case 'm':\u000a      return n * m\u000a    case 'seconds':\u000a    case 'second':\u000a    case 'secs':\u000a    case 'sec':\u000a    case 's':\u000a      return n * s\u000a    case 'milliseconds':\u000a    case 'millisecond':\u000a    case 'msecs':\u000a    case 'msec':\u000a    case 'ms':\u000a      return n\u000a    default:\u000a      return undefined\u000a  }\u000a}\u000a\u000a/**\u000a * Short format for `ms`.\u000a *\u000a * @param {Number} ms\u000a * @return {String}\u000a * @api private\u000a */\u000a\u000afunction fmtShort(ms) {\u000a  if (ms >= d) {\u000a    return Math.round(ms / d) + 'd'\u000a  }\u000a  if (ms >= h) {\u000a    return Math.round(ms / h) + 'h'\u000a  }\u000a  if (ms >= m) {\u000a    return Math.round(ms / m) + 'm'\u000a  }\u000a  if (ms >= s) {\u000a    return Math.round(ms / s) + 's'\u000a  }\u000a  return ms + 'ms'\u000a}\u000a\u000a/**\u000a * Long format for `ms`.\u000a *\u000a * @param {Number} ms\u000a * @return {String}\u000a * @api private\u000a */\u000a\u000afunction fmtLong(ms) {\u000a  return plural(ms, d, 'day') ||\u000a    plural(ms, h, 'hour') ||\u000a    plural(ms, m, 'minute') ||\u000a    plural(ms, s, 'second') ||\u000a    ms + ' ms'\u000a}\u000a\u000a/**\u000a * Pluralization helper.\u000a */\u000a\u000afunction plural(ms, n, name) {\u000a  if (ms < n) {\u000a    return\u000a  }\u000a  if (ms < n * 1.5) {\u000a    return Math.floor(ms / n) + ' ' + name\u000a  }\u000a  return Math.ceil(ms / n) + ' ' + name + 's'\u000a}\u000a\u000a},{}],59:[function(require,module,exports){\u000a'use strict';\u000a\u000avar has = Object.prototype.hasOwnProperty;\u000a\u000a/**\u000a * Simple query string parser.\u000a *\u000a * @param {String} query The query string that needs to be parsed.\u000a * @returns {Object}\u000a * @api public\u000a */\u000afunction querystring(query) {\u000a  var parser = /([^=?&]+)=?([^&]*)/g\u000a    , result = {}\u000a    , part;\u000a\u000a  //\u000a  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\u000a  // the lastIndex property so we can continue executing this loop until we've\u000a  // parsed all results.\u000a  //\u000a  for (;\u000a    part = parser.exec(query);\u000a    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\u000a  );\u000a\u000a  return result;\u000a}\u000a\u000a/**\u000a * Transform a query string to an object.\u000a *\u000a * @param {Object} obj Object that should be transformed.\u000a * @param {String} prefix Optional prefix.\u000a * @returns {String}\u000a * @api public\u000a */\u000afunction querystringify(obj, prefix) {\u000a  prefix = prefix || '';\u000a\u000a  var pairs = [];\u000a\u000a  //\u000a  // Optionally prefix with a '?' if needed\u000a  //\u000a  if ('string' !== typeof prefix) prefix = '?';\u000a\u000a  for (var key in obj) {\u000a    if (has.call(obj, key)) {\u000a      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\u000a    }\u000a  }\u000a\u000a  return pairs.length ? prefix + pairs.join('&') : '';\u000a}\u000a\u000a//\u000a// Expose the module.\u000a//\u000aexports.stringify = querystringify;\u000aexports.parse = querystring;\u000a\u000a},{}],60:[function(require,module,exports){\u000a'use strict';\u000a\u000a/**\u000a * Check if we're required to add a port number.\u000a *\u000a * @see https://url.spec.whatwg.org/#default-port\u000a * @param {Number|String} port Port number we need to check\u000a * @param {String} protocol Protocol we need to check against.\u000a * @returns {Boolean} Is it a default port for the given protocol\u000a * @api private\u000a */\u000amodule.exports = function required(port, protocol) {\u000a  protocol = protocol.split(':')[0];\u000a  port = +port;\u000a\u000a  if (!port) return false;\u000a\u000a  switch (protocol) {\u000a    case 'http':\u000a    case 'ws':\u000a    return port !== 80;\u000a\u000a    case 'https':\u000a    case 'wss':\u000a    return port !== 443;\u000a\u000a    case 'ftp':\u000a    return port !== 21;\u000a\u000a    case 'gopher':\u000a    return port !== 70;\u000a\u000a    case 'file':\u000a    return false;\u000a  }\u000a\u000a  return port !== 0;\u000a};\u000a\u000a},{}],61:[function(require,module,exports){\u000a'use strict';\u000a\u000avar required = require('requires-port')\u000a  , lolcation = require('./lolcation')\u000a  , qs = require('querystringify')\u000a  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\u005c/\u005c/)?([\u005cS\u005cs]*)/i;\u000a\u000a/**\u000a * These are the parse rules for the URL parser, it informs the parser\u000a * about:\u000a *\u000a * 0. The char it Needs to parse, if it's a string it should be done using\u000a *    indexOf, RegExp using exec and NaN means set as current value.\u000a * 1. The property we should set when parsing this value.\u000a * 2. Indication if it's backwards or forward parsing, when set as number it's\u000a *    the value of extra chars that should be split off.\u000a * 3. Inherit from location if non existing in the parser.\u000a * 4. `toLowerCase` the resulting value.\u000a */\u000avar rules = [\u000a  ['#', 'hash'],                        // Extract from the back.\u000a  ['?', 'query'],                       // Extract from the back.\u000a  ['/', 'pathname'],                    // Extract from the back.\u000a  ['@', 'auth', 1],                     // Extract from the front.\u000a  [NaN, 'host', undefined, 1, 1],       // Set left over value.\u000a  [/:(\u005cd+)$/, 'port', undefined, 1],    // RegExp the back.\u000a  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\u000a];\u000a\u000a/**\u000a * @typedef ProtocolExtract\u000a * @type Object\u000a * @property {String} protocol Protocol matched in the URL, in lowercase.\u000a * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.\u000a * @property {String} rest Rest of the URL that is not part of the protocol.\u000a */\u000a\u000a/**\u000a * Extract protocol information from a URL with/without double slash ("//").\u000a *\u000a * @param {String} address URL we want to extract from.\u000a * @return {ProtocolExtract} Extracted information.\u000a * @api private\u000a */\u000afunction extractProtocol(address) {\u000a  var match = protocolre.exec(address);\u000a\u000a  return {\u000a    protocol: match[1] ? match[1].toLowerCase() : '',\u000a    slashes: !!match[2],\u000a    rest: match[3]\u000a  };\u000a}\u000a\u000a/**\u000a * Resolve a relative URL pathname against a base URL pathname.\u000a *\u000a * @param {String} relative Pathname of the relative URL.\u000a * @param {String} base Pathname of the base URL.\u000a * @return {String} Resolved pathname.\u000a * @api private\u000a */\u000afunction resolve(relative, base) {\u000a  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\u000a    , i = path.length\u000a    , last = path[i - 1]\u000a    , unshift = false\u000a    , up = 0;\u000a\u000a  while (i--) {\u000a    if (path[i] === '.') {\u000a      path.splice(i, 1);\u000a    } else if (path[i] === '..') {\u000a      path.splice(i, 1);\u000a      up++;\u000a    } else if (up) {\u000a      if (i === 0) unshift = true;\u000a      path.splice(i, 1);\u000a      up--;\u000a    }\u000a  }\u000a\u000a  if (unshift) path.unshift('');\u000a  if (last === '.' || last === '..') path.push('');\u000a\u000a  return path.join('/');\u000a}\u000a\u000a/**\u000a * The actual URL instance. Instead of returning an object we've opted-in to\u000a * create an actual constructor as it's much more memory efficient and\u000a * faster and it pleases my OCD.\u000a *\u000a * @constructor\u000a * @param {String} address URL we want to parse.\u000a * @param {Object|String} location Location defaults for relative paths.\u000a * @param {Boolean|Function} parser Parser for the query string.\u000a * @api public\u000a */\u000afunction URL(address, location, parser) {\u000a  if (!(this instanceof URL)) {\u000a    return new URL(address, location, parser);\u000a  }\u000a\u000a  var relative, extracted, parse, instruction, index, key\u000a    , instructions = rules.slice()\u000a    , type = typeof location\u000a    , url = this\u000a    , i = 0;\u000a\u000a  //\u000a  // The following if statements allows this module two have compatibility with\u000a  // 2 different API:\u000a  //\u000a  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\u000a  //    where the boolean indicates that the query string should also be parsed.\u000a  //\u000a  // 2. The `URL` interface of the browser which accepts a URL, object as\u000a  //    arguments. The supplied object will be used as default values / fall-back\u000a  //    for relative paths.\u000a  //\u000a  if ('object' !== type && 'string' !== type) {\u000a    parser = location;\u000a    location = null;\u000a  }\u000a\u000a  if (parser && 'function' !== typeof parser) parser = qs.parse;\u000a\u000a  location = lolcation(location);\u000a\u000a  //\u000a  // Extract protocol information before running the instructions.\u000a  //\u000a  extracted = extractProtocol(address || '');\u000a  relative = !extracted.protocol && !extracted.slashes;\u000a  url.slashes = extracted.slashes || relative && location.slashes;\u000a  url.protocol = extracted.protocol || location.protocol || '';\u000a  address = extracted.rest;\u000a\u000a  //\u000a  // When the authority component is absent the URL starts with a path\u000a  // component.\u000a  //\u000a  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];\u000a\u000a  for (; i < instructions.length; i++) {\u000a    instruction = instructions[i];\u000a    parse = instruction[0];\u000a    key = instruction[1];\u000a\u000a    if (parse !== parse) {\u000a      url[key] = address;\u000a    } else if ('string' === typeof parse) {\u000a      if (~(index = address.indexOf(parse))) {\u000a        if ('number' === typeof instruction[2]) {\u000a          url[key] = address.slice(0, index);\u000a          address = address.slice(index + instruction[2]);\u000a        } else {\u000a          url[key] = address.slice(index);\u000a          address = address.slice(0, index);\u000a        }\u000a      }\u000a    } else if (index = parse.exec(address)) {\u000a      url[key] = index[1];\u000a      address = address.slice(0, index.index);\u000a    }\u000a\u000a    url[key] = url[key] || (\u000a      relative && instruction[3] ? location[key] || '' : ''\u000a    );\u000a\u000a    //\u000a    // Hostname, host and protocol should be lowercased so they can be used to\u000a    // create a proper `origin`.\u000a    //\u000a    if (instruction[4]) url[key] = url[key].toLowerCase();\u000a  }\u000a\u000a  //\u000a  // Also parse the supplied query string in to an object. If we're supplied\u000a  // with a custom parser as function use that instead of the default build-in\u000a  // parser.\u000a  //\u000a  if (parser) url.query = parser(url.query);\u000a\u000a  //\u000a  // If the URL is relative, resolve the pathname against the base URL.\u000a  //\u000a  if (\u000a      relative\u000a    && location.slashes\u000a    && url.pathname.charAt(0) !== '/'\u000a    && (url.pathname !== '' || location.pathname !== '')\u000a  ) {\u000a    url.pathname = resolve(url.pathname, location.pathname);\u000a  }\u000a\u000a  //\u000a  // We should not add port numbers if they are already the default port number\u000a  // for a given protocol. As the host also contains the port number we're going\u000a  // override it with the hostname which contains no port number.\u000a  //\u000a  if (!required(url.port, url.protocol)) {\u000a    url.host = url.hostname;\u000a    url.port = '';\u000a  }\u000a\u000a  //\u000a  // Parse down the `auth` for the username and password.\u000a  //\u000a  url.username = url.password = '';\u000a  if (url.auth) {\u000a    instruction = url.auth.split(':');\u000a    url.username = instruction[0] || '';\u000a    url.password = instruction[1] || '';\u000a  }\u000a\u000a  url.origin = url.protocol && url.host && url.protocol !== 'file:'\u000a    ? url.protocol +'//'+ url.host\u000a    : 'null';\u000a\u000a  //\u000a  // The href is just the compiled result.\u000a  //\u000a  url.href = url.toString();\u000a}\u000a\u000a/**\u000a * This is convenience method for changing properties in the URL instance to\u000a * insure that they all propagate correctly.\u000a *\u000a * @param {String} part          Property we need to adjust.\u000a * @param {Mixed} value          The newly assigned value.\u000a * @param {Boolean|Function} fn  When setting the query, it will be the function\u000a *                               used to parse the query.\u000a *                               When setting the protocol, double slash will be\u000a *                               removed from the final url if it is true.\u000a * @returns {URL}\u000a * @api public\u000a */\u000aURL.prototype.set = function set(part, value, fn) {\u000a  var url = this;\u000a\u000a  switch (part) {\u000a    case 'query':\u000a      if ('string' === typeof value && value.length) {\u000a        value = (fn || qs.parse)(value);\u000a      }\u000a\u000a      url[part] = value;\u000a      break;\u000a\u000a    case 'port':\u000a      url[part] = value;\u000a\u000a      if (!required(value, url.protocol)) {\u000a        url.host = url.hostname;\u000a        url[part] = '';\u000a      } else if (value) {\u000a        url.host = url.hostname +':'+ value;\u000a      }\u000a\u000a      break;\u000a\u000a    case 'hostname':\u000a      url[part] = value;\u000a\u000a      if (url.port) value += ':'+ url.port;\u000a      url.host = value;\u000a      break;\u000a\u000a    case 'host':\u000a      url[part] = value;\u000a\u000a      if (/:\u005cd+$/.test(value)) {\u000a        value = value.split(':');\u000a        url.port = value.pop();\u000a        url.hostname = value.join(':');\u000a      } else {\u000a        url.hostname = value;\u000a        url.port = '';\u000a      }\u000a\u000a      break;\u000a\u000a    case 'protocol':\u000a      url.protocol = value.toLowerCase();\u000a      url.slashes = !fn;\u000a      break;\u000a\u000a    case 'pathname':\u000a      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;\u000a\u000a      break;\u000a\u000a    default:\u000a      url[part] = value;\u000a  }\u000a\u000a  for (var i = 0; i < rules.length; i++) {\u000a    var ins = rules[i];\u000a\u000a    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\u000a  }\u000a\u000a  url.origin = url.protocol && url.host && url.protocol !== 'file:'\u000a    ? url.protocol +'//'+ url.host\u000a    : 'null';\u000a\u000a  url.href = url.toString();\u000a\u000a  return url;\u000a};\u000a\u000a/**\u000a * Transform the properties back in to a valid and full URL string.\u000a *\u000a * @param {Function} stringify Optional query stringify function.\u000a * @returns {String}\u000a * @api public\u000a */\u000aURL.prototype.toString = function toString(stringify) {\u000a  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\u000a\u000a  var query\u000a    , url = this\u000a    , protocol = url.protocol;\u000a\u000a  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\u000a\u000a  var result = protocol + (url.slashes ? '//' : '');\u000a\u000a  if (url.username) {\u000a    result += url.username;\u000a    if (url.password) result += ':'+ url.password;\u000a    result += '@';\u000a  }\u000a\u000a  result += url.host + url.pathname;\u000a\u000a  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\u000a  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\u000a\u000a  if (url.hash) result += url.hash;\u000a\u000a  return result;\u000a};\u000a\u000a//\u000a// Expose the URL parser and some additional properties that might be useful for\u000a// others or testing.\u000a//\u000aURL.extractProtocol = extractProtocol;\u000aURL.location = lolcation;\u000aURL.qs = qs;\u000a\u000amodule.exports = URL;\u000a\u000a},{"./lolcation":62,"querystringify":59,"requires-port":60}],62:[function(require,module,exports){\u000a(function (global){\u000a'use strict';\u000a\u000avar slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\u005c/\u005c//;\u000a\u000a/**\u000a * These properties should not be copied or inherited from. This is only needed\u000a * for all non blob URL's as a blob URL does not include a hash, only the\u000a * origin.\u000a *\u000a * @type {Object}\u000a * @private\u000a */\u000avar ignore = { hash: 1, query: 1 }\u000a  , URL;\u000a\u000a/**\u000a * The location object differs when your code is loaded through a normal page,\u000a * Worker or through a worker using a blob. And with the blobble begins the\u000a * trouble as the location object will contain the URL of the blob, not the\u000a * location of the page where our code is loaded in. The actual origin is\u000a * encoded in the `pathname` so we can thankfully generate a good "default"\u000a * location from it so we can generate proper relative URL's again.\u000a *\u000a * @param {Object|String} loc Optional default location object.\u000a * @returns {Object} lolcation object.\u000a * @api public\u000a */\u000amodule.exports = function lolcation(loc) {\u000a  loc = loc || global.location || {};\u000a  URL = URL || require('./');\u000a\u000a  var finaldestination = {}\u000a    , type = typeof loc\u000a    , key;\u000a\u000a  if ('blob:' === loc.protocol) {\u000a    finaldestination = new URL(unescape(loc.pathname), {});\u000a  } else if ('string' === type) {\u000a    finaldestination = new URL(loc, {});\u000a    for (key in ignore) delete finaldestination[key];\u000a  } else if ('object' === type) {\u000a    for (key in loc) {\u000a      if (key in ignore) continue;\u000a      finaldestination[key] = loc[key];\u000a    }\u000a\u000a    if (finaldestination.slashes === undefined) {\u000a      finaldestination.slashes = slashes.test(loc.href);\u000a    }\u000a  }\u000a\u000a  return finaldestination;\u000a};\u000a\u000a}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\u000a\u000a},{"./":61}]},{},[1])(1)\u000a});\u000a\u000a\u000a\u000a\u000a;\u000a
p0
.