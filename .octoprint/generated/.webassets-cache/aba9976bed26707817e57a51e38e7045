V// source: js/app/viewmodels/settings.js\u000a$(function() {\u000a    function SettingsViewModel(parameters) {\u000a        var self = this;\u000a\u000a        self.loginState = parameters[0];\u000a        self.users = parameters[1];\u000a        self.printerProfiles = parameters[2];\u000a        self.about = parameters[3];\u000a\u000a        // use this promise to do certain things once the SettingsViewModel has processed\u000a        // its first request\u000a        var firstRequest = $.Deferred();\u000a        self.firstRequest = firstRequest.promise();\u000a\u000a        self.allViewModels = [];\u000a\u000a        self.receiving = ko.observable(false);\u000a        self.sending = ko.observable(false);\u000a        self.exchanging = ko.pureComputed(function() {\u000a            return self.receiving() || self.sending();\u000a        });\u000a        self.outstanding = [];\u000a\u000a        self.active = false;\u000a        self.sawUpdateEventWhileActive = false;\u000a        self.ignoreNextUpdateEvent = false;\u000a\u000a        self.settingsDialog = undefined;\u000a        self.settings_dialog_update_detected = undefined;\u000a        self.translationManagerDialog = undefined;\u000a        self.translationUploadElement = $("#settings_appearance_managelanguagesdialog_upload");\u000a        self.translationUploadButton = $("#settings_appearance_managelanguagesdialog_upload_start");\u000a\u000a        self.translationUploadFilename = ko.observable();\u000a        self.invalidTranslationArchive = ko.pureComputed(function() {\u000a            var name = self.translationUploadFilename();\u000a            return name !== undefined && !(_.endsWith(name.toLocaleLowerCase(), ".zip") || _.endsWith(name.toLocaleLowerCase(), ".tar.gz") || _.endsWith(name.toLocaleLowerCase(), ".tgz") || _.endsWith(name.toLocaleLowerCase(), ".tar"));\u000a        });\u000a        self.enableTranslationUpload = ko.pureComputed(function() {\u000a            var name = self.translationUploadFilename();\u000a            return name !== undefined && name.trim() != "" && !self.invalidTranslationArchive();\u000a        });\u000a\u000a        self.translations = new ItemListHelper(\u000a            "settings.translations",\u000a            {\u000a                "locale": function (a, b) {\u000a                    // sorts ascending\u000a                    if (a["locale"].toLocaleLowerCase() < b["locale"].toLocaleLowerCase()) return -1;\u000a                    if (a["locale"].toLocaleLowerCase() > b["locale"].toLocaleLowerCase()) return 1;\u000a                    return 0;\u000a                }\u000a            },\u000a            {\u000a            },\u000a            "locale",\u000a            [],\u000a            [],\u000a            0\u000a        );\u000a\u000a        self.appearance_available_colors = ko.observable([\u000a            {key: "default", name: gettext("default")},\u000a            {key: "red", name: gettext("red")},\u000a            {key: "orange", name: gettext("orange")},\u000a            {key: "yellow", name: gettext("yellow")},\u000a            {key: "green", name: gettext("green")},\u000a            {key: "blue", name: gettext("blue")},\u000a            {key: "violet", name: gettext("violet")},\u000a            {key: "black", name: gettext("black")},\u000a            {key: "white", name: gettext("white")},\u000a        ]);\u000a\u000a        self.appearance_colorName = function(color) {\u000a            switch (color) {\u000a                case "red":\u000a                    return gettext("red");\u000a                case "orange":\u000a                    return gettext("orange");\u000a                case "yellow":\u000a                    return gettext("yellow");\u000a                case "green":\u000a                    return gettext("green");\u000a                case "blue":\u000a                    return gettext("blue");\u000a                case "violet":\u000a                    return gettext("violet");\u000a                case "black":\u000a                    return gettext("black");\u000a                case "white":\u000a                    return gettext("white");\u000a                case "default":\u000a                    return gettext("default");\u000a                default:\u000a                    return color;\u000a            }\u000a        };\u000a\u000a        self.webcam_available_ratios = ["16:9", "4:3"];\u000a\u000a        var auto_locale = {language: "_default", display: gettext("Autodetect from browser"), english: undefined};\u000a        self.locales = ko.observableArray([auto_locale].concat(_.sortBy(_.values(AVAILABLE_LOCALES), function(n) {\u000a            return n.display;\u000a        })));\u000a        self.locale_languages = _.keys(AVAILABLE_LOCALES);\u000a\u000a        self.api_key = ko.observable(undefined);\u000a        self.api_allowCrossOrigin = ko.observable(undefined);\u000a\u000a        self.appearance_name = ko.observable(undefined);\u000a        self.appearance_color = ko.observable(undefined);\u000a        self.appearance_colorTransparent = ko.observable();\u000a        self.appearance_colorIcon = ko.observable();\u000a        self.appearance_defaultLanguage = ko.observable();\u000a        self.appearance_showFahrenheitAlso = ko.observable(undefined);\u000a        self.appearance_fuzzyTimes = ko.observable(undefined);\u000a        self.appearance_closeModalsWithClick = ko.observable(undefined);\u000a\u000a        self.printer_defaultExtrusionLength = ko.observable(undefined);\u000a\u000a        self.webcam_webcamEnabled = ko.observable(undefined);\u000a        self.webcam_timelapseEnabled = ko.observable(undefined);\u000a        self.webcam_streamUrl = ko.observable(undefined);\u000a        self.webcam_streamRatio = ko.observable(undefined);\u000a        self.webcam_streamTimeout = ko.observable(undefined);\u000a        self.webcam_snapshotUrl = ko.observable(undefined);\u000a        self.webcam_snapshotTimeout = ko.observable(undefined);\u000a        self.webcam_snapshotSslValidation = ko.observable(undefined);\u000a        self.webcam_ffmpegPath = ko.observable(undefined);\u000a        self.webcam_bitrate = ko.observable(undefined);\u000a        self.webcam_ffmpegThreads = ko.observable(undefined);\u000a        self.webcam_watermark = ko.observable(undefined);\u000a        self.webcam_flipH = ko.observable(undefined);\u000a        self.webcam_flipV = ko.observable(undefined);\u000a        self.webcam_rotate90 = ko.observable(undefined);\u000a\u000a        self.feature_gcodeViewer = ko.observable(undefined);\u000a        self.feature_sizeThreshold = ko.observable();\u000a        self.feature_mobileSizeThreshold = ko.observable();\u000a        self.feature_sizeThreshold_str = sizeObservable(self.feature_sizeThreshold);\u000a        self.feature_mobileSizeThreshold_str = sizeObservable(self.feature_mobileSizeThreshold);\u000a        self.feature_temperatureGraph = ko.observable(undefined);\u000a        self.feature_sdSupport = ko.observable(undefined);\u000a        self.feature_keyboardControl = ko.observable(undefined);\u000a        self.feature_pollWatched = ko.observable(undefined);\u000a        self.feature_modelSizeDetection = ko.observable(undefined);\u000a        self.feature_printStartConfirmation = ko.observable(undefined);\u000a        self.feature_printCancelConfirmation = ko.observable(undefined);\u000a        self.feature_g90InfluencesExtruder = ko.observable(undefined);\u000a        self.feature_autoUppercaseBlacklist = ko.observable(undefined);\u000a\u000a        self.serial_port = ko.observable();\u000a        self.serial_baudrate = ko.observable();\u000a        self.serial_exclusive = ko.observable();\u000a        self.serial_portOptions = ko.observableArray([]);\u000a        self.serial_baudrateOptions = ko.observableArray([]);\u000a        self.serial_autoconnect = ko.observable(undefined);\u000a        self.serial_timeoutConnection = ko.observable(undefined);\u000a        self.serial_timeoutDetection = ko.observable(undefined);\u000a        self.serial_timeoutCommunication = ko.observable(undefined);\u000a        self.serial_timeoutCommunicationBusy = ko.observable(undefined);\u000a        self.serial_timeoutTemperature = ko.observable(undefined);\u000a        self.serial_timeoutTemperatureTargetSet = ko.observable(undefined);\u000a        self.serial_timeoutTemperatureAutoreport = ko.observable(undefined);\u000a        self.serial_timeoutSdStatus = ko.observable(undefined);\u000a        self.serial_timeoutSdStatusAutoreport = ko.observable(undefined);\u000a        self.serial_timeoutBaudrateDetectionPause = ko.observable(undefined);\u000a        self.serial_timeoutPositionLogWait = ko.observable(undefined);\u000a        self.serial_log = ko.observable(undefined);\u000a        self.serial_additionalPorts = ko.observable(undefined);\u000a        self.serial_additionalBaudrates = ko.observable(undefined);\u000a        self.serial_longRunningCommands = ko.observable(undefined);\u000a        self.serial_checksumRequiringCommands = ko.observable(undefined);\u000a        self.serial_blockedCommands = ko.observable(undefined);\u000a        self.serial_pausingCommands = ko.observable(undefined);\u000a        self.serial_emergencyCommands = ko.observable(undefined);\u000a        self.serial_helloCommand = ko.observable(undefined);\u000a        self.serial_serialErrorBehaviour = ko.observable("cancel");\u000a        self.serial_triggerOkForM29 = ko.observable(undefined);\u000a        self.serial_waitForStart =  ko.observable(undefined);\u000a        self.serial_sendChecksum =  ko.observable("print");\u000a        self.serial_sdRelativePath =  ko.observable(undefined);\u000a        self.serial_sdAlwaysAvailable =  ko.observable(undefined);\u000a        self.serial_swallowOkAfterResend =  ko.observable(undefined);\u000a        self.serial_repetierTargetTemp =  ko.observable(undefined);\u000a        self.serial_disableExternalHeatupDetection =  ko.observable(undefined);\u000a        self.serial_ignoreIdenticalResends =  ko.observable(undefined);\u000a        self.serial_firmwareDetection =  ko.observable(undefined);\u000a        self.serial_blockWhileDwelling =  ko.observable(undefined);\u000a        self.serial_useParityWorkaround = ko.observable(undefined);\u000a        self.serial_supportResendsWithoutOk = ko.observable(undefined);\u000a        self.serial_logPositionOnPause = ko.observable(undefined);\u000a        self.serial_logPositionOnCancel = ko.observable(undefined);\u000a        self.serial_abortHeatupOnCancel = ko.observable(undefined);\u000a        self.serial_maxTimeoutsIdle = ko.observable(undefined);\u000a        self.serial_maxTimeoutsPrinting = ko.observable(undefined);\u000a        self.serial_maxTimeoutsLong = ko.observable(undefined);\u000a        self.serial_capAutoreportTemp = ko.observable(undefined);\u000a        self.serial_capAutoreportSdStatus = ko.observable(undefined);\u000a        self.serial_capBusyProtocol = ko.observable(undefined);\u000a        self.serial_capEmergencyParser = ko.observable(undefined);\u000a        self.serial_sendM112OnError = ko.observable(undefined);\u000a\u000a        self.folder_uploads = ko.observable(undefined);\u000a        self.folder_timelapse = ko.observable(undefined);\u000a        self.folder_timelapseTmp = ko.observable(undefined);\u000a        self.folder_logs = ko.observable(undefined);\u000a        self.folder_watched = ko.observable(undefined);\u000a\u000a        self.scripts_gcode_beforePrintStarted = ko.observable(undefined);\u000a        self.scripts_gcode_afterPrintDone = ko.observable(undefined);\u000a        self.scripts_gcode_afterPrintCancelled = ko.observable(undefined);\u000a        self.scripts_gcode_afterPrintPaused = ko.observable(undefined);\u000a        self.scripts_gcode_beforePrintResumed = ko.observable(undefined);\u000a        self.scripts_gcode_afterPrinterConnected = ko.observable(undefined);\u000a        self.scripts_gcode_beforePrinterDisconnected = ko.observable(undefined);\u000a        self.scripts_gcode_afterToolChange = ko.observable(undefined);\u000a        self.scripts_gcode_beforeToolChange = ko.observable(undefined);\u000a\u000a        self.temperature_profiles = ko.observableArray(undefined);\u000a        self.temperature_cutoff = ko.observable(undefined);\u000a        self.temperature_sendAutomatically = ko.observable(undefined);\u000a        self.temperature_sendAutomaticallyAfter = ko.observable(undefined);\u000a\u000a        self.system_actions = ko.observableArray([]);\u000a\u000a        self.terminalFilters = ko.observableArray([]);\u000a\u000a        self.server_commands_systemShutdownCommand = ko.observable(undefined);\u000a        self.server_commands_systemRestartCommand = ko.observable(undefined);\u000a        self.server_commands_serverRestartCommand = ko.observable(undefined);\u000a\u000a        self.server_diskspace_warning = ko.observable();\u000a        self.server_diskspace_critical = ko.observable();\u000a        self.server_diskspace_warning_str = sizeObservable(self.server_diskspace_warning);\u000a        self.server_diskspace_critical_str = sizeObservable(self.server_diskspace_critical);\u000a\u000a        self.server_onlineCheck_enabled = ko.observable();\u000a        self.server_onlineCheck_interval = ko.observable();\u000a        self.server_onlineCheck_host = ko.observable();\u000a        self.server_onlineCheck_port = ko.observable();\u000a\u000a        self.server_pluginBlacklist_enabled = ko.observable();\u000a        self.server_pluginBlacklist_url = ko.observable();\u000a        self.server_pluginBlacklist_ttl = ko.observable();\u000a\u000a        self.settings = undefined;\u000a        self.lastReceivedSettings = undefined;\u000a\u000a        self.webcam_ffmpegPathText = ko.observable();\u000a        self.webcam_ffmpegPathOk = ko.observable(false);\u000a        self.webcam_ffmpegPathBroken = ko.observable(false);\u000a        self.webcam_ffmpegPathReset = function() {\u000a            self.webcam_ffmpegPathText("");\u000a            self.webcam_ffmpegPathOk(false);\u000a            self.webcam_ffmpegPathBroken(false);\u000a        };\u000a\u000a        self.server_onlineCheckText = ko.observable();\u000a        self.server_onlineCheckOk = ko.observable(false);\u000a        self.server_onlineCheckBroken = ko.observable(false);\u000a        self.server_onlineCheckReset = function() {\u000a            self.server_onlineCheckText("");\u000a            self.server_onlineCheckOk(false);\u000a            self.server_onlineCheckBroken(false);\u000a        };\u000a\u000a        var folderTypes = ["uploads", "timelapse", "timelapseTmp", "logs", "watched"];\u000a        self.testFolderConfigText = {};\u000a        self.testFolderConfigOk = {};\u000a        self.testFolderConfigBroken = {};\u000a        _.each(folderTypes, function(folderType) {\u000a            self.testFolderConfigText[folderType] = ko.observable("");\u000a            self.testFolderConfigOk[folderType] = ko.observable(false);\u000a            self.testFolderConfigBroken[folderType] = ko.observable(false);\u000a        });\u000a        self.testFolderConfigReset = function() {\u000a            _.each(folderTypes, function(folderType) {\u000a                self.testFolderConfigText[folderType]("");\u000a                self.testFolderConfigOk[folderType](false);\u000a                self.testFolderConfigBroken[folderType](false);\u000a            });\u000a        };\u000a\u000a        self.observableCopies = {\u000a            "feature_waitForStart": "serial_waitForStart",\u000a            "feature_sendChecksum": "serial_sendChecksum",\u000a            "feature_sdRelativePath": "serial_sdRelativePath",\u000a            "feature_sdAlwaysAvailable": "serial_sdAlwaysAvailable",\u000a            "feature_swallowOkAfterResend": "serial_swallowOkAfterResend",\u000a            "feature_repetierTargetTemp": "serial_repetierTargetTemp",\u000a            "feature_disableExternalHeatupDetection": "serial_disableExternalHeatupDetection",\u000a            "feature_ignoreIdenticalResends": "serial_ignoreIdenticalResends",\u000a            "feature_firmwareDetection": "serial_firmwareDetection",\u000a            "feature_blockWhileDwelling": "serial_blockWhileDwelling",\u000a            "serial_": "feature_"\u000a        };\u000a        _.each(self.observableCopies, function(value, key) {\u000a            if (self.hasOwnProperty(value)) {\u000a                self[key] = self[value];\u000a            }\u000a        });\u000a\u000a        self.addTemperatureProfile = function() {\u000a            self.temperature_profiles.push({name: "New", extruder:0, bed:0, chamber:0});\u000a        };\u000a\u000a        self.removeTemperatureProfile = function(profile) {\u000a            self.temperature_profiles.remove(profile);\u000a        };\u000a\u000a        self.addTerminalFilter = function() {\u000a            self.terminalFilters.push({name: "New", regex: "(Send: (N\u005cd+\u005cs+)?M105)|(Recv:\u005cs+(ok\u005cs+)?.*(B|T\u005cd*):\u005cd+)"})\u000a        };\u000a\u000a        self.removeTerminalFilter = function(filter) {\u000a            self.terminalFilters.remove(filter);\u000a        };\u000a\u000a        self.testWebcamStreamUrlBusy = ko.observable(false);\u000a        self.testWebcamStreamUrl = function() {\u000a            if (!self.webcam_streamUrl()) {\u000a                return;\u000a            }\u000a\u000a            if (self.testWebcamStreamUrlBusy()) {\u000a                return;\u000a            }\u000a\u000a            var text = gettext("If you see your webcam stream below, the entered stream URL is ok.");\u000a            var image = $('<img src="' + self.webcam_streamUrl() + '">');\u000a            var message = $("<p></p>")\u000a                .append(text)\u000a                .append(image);\u000a\u000a            self.testWebcamStreamUrlBusy(true);\u000a            showMessageDialog({\u000a                title: gettext("Stream test"),\u000a                message: message,\u000a                onclose: function() {\u000a                    self.testWebcamStreamUrlBusy(false);\u000a                }\u000a            });\u000a        };\u000a\u000a        self.testWebcamSnapshotUrlBusy = ko.observable(false);\u000a        self.testWebcamSnapshotUrl = function(viewModel, event) {\u000a            if (!self.webcam_snapshotUrl()) {\u000a                return;\u000a            }\u000a\u000a            if (self.testWebcamSnapshotUrlBusy()) {\u000a                return;\u000a            }\u000a\u000a            var errorText = gettext("Could not retrieve snapshot URL, please double check the URL");\u000a            var errorTitle = gettext("Snapshot test failed");\u000a\u000a            self.testWebcamSnapshotUrlBusy(true);\u000a            OctoPrint.util.testUrl(self.webcam_snapshotUrl(), {\u000a                method: "GET",\u000a                response: "bytes",\u000a                timeout: self.webcam_snapshotTimeout(),\u000a                validSsl: self.webcam_snapshotSslValidation(),\u000a                content_type_whitelist: ["image/*"],\u000a                content_type_guess: true\u000a            })\u000a                .done(function(response) {\u000a                    if (!response.result) {\u000a                        if (response.status && response.response && response.response.content_type) {\u000a                            // we could contact the server, but something else was wrong, probably the mime type\u000a                            errorText = gettext("Could retrieve the snapshot URL, but it didn't look like an " +\u000a                                                "image. Got this as a content type header: <code>%(content_type)s</code>. Please " +\u000a                                                "double check that the URL is returning static images, not multipart data " +\u000a                                                "or videos.");\u000a                            errorText = _.sprintf(errorText, {content_type: response.response.content_type});\u000a                        }\u000a\u000a                        showMessageDialog({\u000a                            title: errorTitle,\u000a                            message: errorText,\u000a                            onclose: function() {\u000a                                self.testWebcamSnapshotUrlBusy(false);\u000a                            }\u000a                        });\u000a                        return;\u000a                    }\u000a\u000a                    var content = response.response.content;\u000a                    var contentType = response.response.assumed_content_type;\u000a\u000a                    var mimeType = "image/jpeg";\u000a                    if (contentType) {\u000a                        mimeType = contentType.split(";")[0];\u000a                    }\u000a\u000a                    var text = gettext("If you see your webcam snapshot picture below, the entered snapshot URL is ok.");\u000a                    showMessageDialog({\u000a                        title: gettext("Snapshot test"),\u000a                        message: $('<p>' + text + '</p><p><img src="data:' + mimeType + ';base64,' + content + '" style="border: 1px solid black" /></p>'),\u000a                        onclose: function() {\u000a                            self.testWebcamSnapshotUrlBusy(false);\u000a                        }\u000a                    });\u000a                })\u000a                .fail(function() {\u000a                    showMessageDialog({\u000a                        title: errorTitle,\u000a                        message: errorText,\u000a                        onclose: function() {\u000a                            self.testWebcamSnapshotUrlBusy(false);\u000a                        }\u000a                    });\u000a                });\u000a        };\u000a\u000a        self.testWebcamFfmpegPathBusy = ko.observable(false);\u000a        self.testWebcamFfmpegPath = function() {\u000a            if (!self.webcam_ffmpegPath()) {\u000a                return;\u000a            }\u000a\u000a            if (self.testWebcamFfmpegPathBusy()) {\u000a                return;\u000a            }\u000a\u000a            self.testWebcamFfmpegPathBusy(true);\u000a            OctoPrint.util.testExecutable(self.webcam_ffmpegPath())\u000a                .done(function(response) {\u000a                    if (!response.result) {\u000a                        if (!response.exists) {\u000a                            self.webcam_ffmpegPathText(gettext("The path doesn't exist"));\u000a                        } else if (!response.typeok) {\u000a                            self.webcam_ffmpegPathText(gettext("The path is not a file"));\u000a                        } else if (!response.access) {\u000a                            self.webcam_ffmpegPathText(gettext("The path is not an executable"));\u000a                        }\u000a                    } else {\u000a                        self.webcam_ffmpegPathText(gettext("The path is valid"));\u000a                    }\u000a                    self.webcam_ffmpegPathOk(response.result);\u000a                    self.webcam_ffmpegPathBroken(!response.result);\u000a                })\u000a                .always(function() {\u000a                    self.testWebcamFfmpegPathBusy(false);\u000a                });\u000a        };\u000a\u000a        self.testOnlineConnectivityConfigBusy = ko.observable(false);\u000a        self.testOnlineConnectivityConfig = function() {\u000a            if (!self.server_onlineCheck_host()) return;\u000a            if (!self.server_onlineCheck_port()) return;\u000a            if (self.testOnlineConnectivityConfigBusy()) return;\u000a\u000a            self.testOnlineConnectivityConfigBusy(true);\u000a            OctoPrint.util.testServer(self.server_onlineCheck_host(), self.server_onlineCheck_port())\u000a                .done(function(response) {\u000a                    if (!response.result) {\u000a                        self.server_onlineCheckText(gettext("The server is not reachable"));\u000a                    } else {\u000a                        self.server_onlineCheckText(gettext("The server is reachable"));\u000a                    }\u000a                    self.server_onlineCheckOk(response.result);\u000a                    self.server_onlineCheckBroken(!response.result);\u000a                })\u000a                .always(function() {\u000a                    self.testOnlineConnectivityConfigBusy(false);\u000a                });\u000a        };\u000a\u000a        self.testFolderConfigBusy = ko.observable(false);\u000a        self.testFolderConfig = function(folder) {\u000a            var observable = "folder_" + folder;\u000a            if (!self.hasOwnProperty(observable)) return;\u000a\u000a            if (self.testFolderConfigBusy()) return;\u000a            self.testFolderConfigBusy(true);\u000a\u000a            var opts = {\u000a                check_type: "dir",\u000a                check_access: "w",\u000a                allow_create_dir: true,\u000a                check_writable_dir: true\u000a            };\u000a            var path = self[observable]();\u000a            OctoPrint.util.testPath(path, opts)\u000a                .done(function(response) {\u000a                    if (!response.result) {\u000a                        if (response.broken_symlink) {\u000a                            self.testFolderConfigText[folder](gettext("The path is a broken symlink."));\u000a                        } else if (!response.exists) {\u000a                            self.testFolderConfigText[folder](gettext("The path does not exist and cannot be created."));\u000a                        } else if (!response.typeok) {\u000a                            self.testFolderConfigText[folder](gettext("The path is not a folder."));\u000a                        } else if (!response.access) {\u000a                            self.testFolderConfigText[folder](gettext("The path is not writable."));\u000a                        }\u000a                    } else {\u000a                        self.testFolderConfigText[folder](gettext("The path is valid"));\u000a                    }\u000a                    self.testFolderConfigOk[folder](response.result);\u000a                    self.testFolderConfigBroken[folder](!response.result);\u000a                })\u000a                .always(function() {\u000a                    self.testFolderConfigBusy(false);\u000a                });\u000a        };\u000a\u000a        self.onSettingsHidden = function() {\u000a            self.webcam_ffmpegPathReset();\u000a            self.server_onlineCheckReset();\u000a            self.testFolderConfigReset();\u000a        };\u000a\u000a        self.isDialogActive = function() {\u000a            return self.settingsDialog.is(":visible");\u000a        };\u000a\u000a        self.onStartup = function() {\u000a            self.settingsDialog = $('#settings_dialog');\u000a            self.settingsUpdatedDialog = $('#settings_dialog_update_detected');\u000a            self.translationManagerDialog = $('#settings_appearance_managelanguagesdialog');\u000a            self.translationUploadElement = $("#settings_appearance_managelanguagesdialog_upload");\u000a            self.translationUploadButton = $("#settings_appearance_managelanguagesdialog_upload_start");\u000a\u000a            self.translationUploadElement.fileupload({\u000a                dataType: "json",\u000a                maxNumberOfFiles: 1,\u000a                autoUpload: false,\u000a                headers: OctoPrint.getRequestHeaders(),\u000a                add: function(e, data) {\u000a                    if (data.files.length == 0) {\u000a                        return false;\u000a                    }\u000a\u000a                    self.translationUploadFilename(data.files[0].name);\u000a\u000a                    self.translationUploadButton.unbind("click");\u000a                    self.translationUploadButton.bind("click", function() {\u000a                        data.submit();\u000a                        return false;\u000a                    });\u000a                },\u000a                done: function(e, data) {\u000a                    self.translationUploadButton.unbind("click");\u000a                    self.translationUploadFilename(undefined);\u000a                    self.fromTranslationResponse(data.result);\u000a                },\u000a                fail: function(e, data) {\u000a                    self.translationUploadButton.unbind("click");\u000a                    self.translationUploadFilename(undefined);\u000a                }\u000a            });\u000a        };\u000a\u000a        self.onAllBound = function(allViewModels) {\u000a            self.allViewModels = allViewModels;\u000a\u000a            self.settingsDialog.on('show', function(event) {\u000a                OctoPrint.coreui.settingsOpen = true;\u000a                if (event.target.id == "settings_dialog") {\u000a                    self.requestTranslationData();\u000a                    callViewModels(allViewModels, "onSettingsShown");\u000a                }\u000a            });\u000a            self.settingsDialog.on('hidden', function(event) {\u000a                OctoPrint.coreui.settingsOpen = false;\u000a                if (event.target.id == "settings_dialog") {\u000a                    callViewModels(allViewModels, "onSettingsHidden");\u000a                }\u000a            });\u000a            self.settingsDialog.on('beforeSave', function () {\u000a                callViewModels(allViewModels, "onSettingsBeforeSave");\u000a            });\u000a\u000a            $(".reload_all", self.settingsUpdatedDialog).click(function(e) {\u000a                e.preventDefault();\u000a                self.settingsUpdatedDialog.modal("hide");\u000a                self.requestData();\u000a                return false;\u000a            });\u000a            $(".reload_nonconflicts", self.settingsUpdatedDialog).click(function(e) {\u000a                e.preventDefault();\u000a                self.settingsUpdatedDialog.modal("hide");\u000a                self.requestData(undefined, true);\u000a                return false;\u000a            });\u000a\u000a            // reset scroll position on tab change\u000a            $('ul.nav-list a[data-toggle="tab"]', self.settingsDialog).on("show", function() {\u000a                self._resetScrollPosition();\u000a            });\u000a        };\u000a\u000a        self.show = function(tab) {\u000a            // select first or specified tab\u000a            self.selectTab(tab);\u000a\u000a            // reset scroll position\u000a            self._resetScrollPosition();\u000a\u000a            // show settings, ensure centered position\u000a            self.settingsDialog.modal({\u000a                minHeight: function() { return Math.max($.fn.modal.defaults.maxHeight() - 80, 250); }\u000a            }).css({\u000a                width: 'auto',\u000a                'margin-left': function() { return -($(this).width() /2); }\u000a            });\u000a\u000a            return false;\u000a        };\u000a\u000a        self.hide = function() {\u000a            self.settingsDialog.modal("hide");\u000a        };\u000a\u000a        self.generateApiKey = function() {\u000a            if (!CONFIG_ACCESS_CONTROL) return;\u000a\u000a            showConfirmationDialog(gettext("This will generate a new API Key. The old API Key will cease to function immediately."),\u000a                function() {\u000a                    OctoPrint.settings.generateApiKey()\u000a                        .done(function(response) {\u000a                            self.api_key(response.apikey);\u000a                            self.requestData();\u000a                        });\u000a                });\u000a        };\u000a\u000a        self.copyApiKey = function() {\u000a            copyToClipboard(self.api_key());\u000a        };\u000a\u000a        self.showTranslationManager = function() {\u000a            self.translationManagerDialog.modal();\u000a            return false;\u000a        };\u000a\u000a        self.requestData = function(local) {\u000a            // handle old parameter format\u000a            var callback = undefined;\u000a            if (arguments.length == 2 || _.isFunction(local)) {\u000a                var exc = new Error();\u000a                log.warn("The callback parameter of SettingsViewModel.requestData is deprecated, the method now returns a promise, please use that instead. Stacktrace:", (exc.stack || exc.stacktrace || "<n/a>"));\u000a\u000a                if (arguments.length == 2) {\u000a                    callback = arguments[0];\u000a                    local = arguments[1];\u000a                } else {\u000a                    callback = local;\u000a                    local = false;\u000a                }\u000a            }\u000a\u000a            // handler for any explicitely provided callbacks\u000a            var callbackHandler = function() {\u000a                if (!callback) return;\u000a                try {\u000a                    callback();\u000a                } catch (exc) {\u000a                    log.error("Error calling settings callback", callback, ":", (exc.stack || exc.stacktrace || exc));\u000a                }\u000a            };\u000a\u000a            // if a request is already active, create a new deferred and return\u000a            // its promise, it will be resolved in the response handler of the\u000a            // current request\u000a            if (self.receiving()) {\u000a                var deferred = $.Deferred();\u000a                self.outstanding.push(deferred);\u000a\u000a                if (callback) {\u000a                    // if we have a callback, we need to make sure it will\u000a                    // get called when the deferred is resolved\u000a                    deferred.done(callbackHandler);\u000a                }\u000a\u000a                return deferred.promise();\u000a            }\u000a\u000a            // perform the request\u000a            self.receiving(true);\u000a            return OctoPrint.settings.get()\u000a                .always(function() {\u000a                    self.receiving(false);\u000a                })\u000a                .done(function(response) {\u000a                    self.fromResponse(response, local);\u000a\u000a                    if (callback) {\u000a                        var deferred = $.Deferred();\u000a                        deferred.done(callbackHandler);\u000a                        self.outstanding.push(deferred);\u000a                    }\u000a\u000a                    // resolve all promises\u000a                    var args = arguments;\u000a                    _.each(self.outstanding, function(deferred) {\u000a                        deferred.resolve(args);\u000a                    });\u000a                    self.outstanding = [];\u000a                })\u000a                .fail(function() {\u000a                    // reject all promises\u000a                    var args = arguments;\u000a                    _.each(self.outstanding, function(deferred) {\u000a                        deferred.reject(args);\u000a                    });\u000a                    self.outstanding = [];\u000a                });\u000a        };\u000a\u000a        self.requestTranslationData = function() {\u000a            return OctoPrint.languages.list()\u000a                .done(self.fromTranslationResponse);\u000a        };\u000a\u000a        self.fromTranslationResponse = function(response) {\u000a            var translationsByLocale = {};\u000a            _.each(response.language_packs, function(item, key) {\u000a                _.each(item.languages, function(pack) {\u000a                    var locale = pack.locale;\u000a                    if (!_.has(translationsByLocale, locale)) {\u000a                        translationsByLocale[locale] = {\u000a                            locale: locale,\u000a                            display: pack.locale_display,\u000a                            english: pack.locale_english,\u000a                            packs: []\u000a                        };\u000a                    }\u000a\u000a                    translationsByLocale[locale]["packs"].push({\u000a                        identifier: key,\u000a                        display: item.display,\u000a                        pack: pack\u000a                    });\u000a                });\u000a            });\u000a\u000a            var translations = [];\u000a            _.each(translationsByLocale, function(item) {\u000a                item["packs"].sort(function(a, b) {\u000a                    if (a.identifier == "_core") return -1;\u000a                    if (b.identifier == "_core") return 1;\u000a\u000a                    if (a.display < b.display) return -1;\u000a                    if (a.display > b.display) return 1;\u000a                    return 0;\u000a                });\u000a                translations.push(item);\u000a            });\u000a\u000a            self.translations.updateItems(translations);\u000a        };\u000a\u000a        self.languagePackDisplay = function(item) {\u000a            return item.display + ((item.english != undefined) ? ' (' + item.english + ')' : '');\u000a        };\u000a\u000a        self.languagePacksAvailable = ko.pureComputed(function() {\u000a            return self.translations.allSize() > 0;\u000a        });\u000a\u000a        self.deleteLanguagePack = function(locale, pack) {\u000a            OctoPrint.languages.delete(locale, pack)\u000a                .done(self.fromTranslationResponse);\u000a        };\u000a\u000a        /**\u000a         * Fetches the settings as currently stored in this client instance.\u000a         */\u000a        self.getLocalData = function() {\u000a            var data = {};\u000a            if (self.settings != undefined) {\u000a                data = ko.mapping.toJS(self.settings);\u000a            }\u000a\u000a            // some special read functions for various observables\u000a            var specialMappings = {\u000a                feature: {\u000a                    autoUppercaseBlacklist: function() { return splitTextToArray(self.feature_autoUppercaseBlacklist(), ",", true) }\u000a                },\u000a                serial: {\u000a                    additionalPorts : function() { return commentableLinesToArray(self.serial_additionalPorts()) },\u000a                    additionalBaudrates: function() { return _.map(splitTextToArray(self.serial_additionalBaudrates(), ",", true, function(item) { return !isNaN(parseInt(item)); }), function(item) { return parseInt(item); }) },\u000a                    longRunningCommands: function() { return splitTextToArray(self.serial_longRunningCommands(), ",", true) },\u000a                    checksumRequiringCommands: function() { return splitTextToArray(self.serial_checksumRequiringCommands(), ",", true) },\u000a                    blockedCommands: function() { return splitTextToArray(self.serial_blockedCommands(), ",", true) },\u000a                    pausingCommands: function() { return splitTextToArray(self.serial_pausingCommands(), ",", true) },\u000a                    emergencyCommands: function() {return splitTextToArray(self.serial_emergencyCommands(), ",", true) },\u000a                    externalHeatupDetection: function() { return !self.serial_disableExternalHeatupDetection()},\u000a                    alwaysSendChecksum: function() { return self.serial_sendChecksum() === "always"},\u000a                    neverSendChecksum: function() { return self.serial_sendChecksum() === "never"},\u000a                    ignoreErrorsFromFirmware: function() { return self.serial_serialErrorBehaviour() === "ignore"},\u000a                    disconnectOnErrors: function() { return self.serial_serialErrorBehaviour() === "disconnect" }\u000a                },\u000a                scripts: {\u000a                    gcode: function() {\u000a                        // we have a special handler function for the gcode scripts since the\u000a                        // server will always send us those that have been set already, so we\u000a                        // can't depend on all keys that we support to be present in the\u000a                        // original request we iterate through in mapFromObservables to\u000a                        // generate our response - hence we use our observables instead\u000a                        //\u000a                        // Note: If we ever introduce sub categories in the gcode scripts\u000a                        // here (more _ after the prefix), we'll need to adjust this code\u000a                        // to be able to cope with that, right now it only strips the prefix\u000a                        // and uses the rest as key in the result, no recursive translation\u000a                        // is done!\u000a                        var result = {};\u000a                        var prefix = "scripts_gcode_";\u000a                        var observables = _.filter(_.keys(self), function(key) { return _.startsWith(key, prefix); });\u000a                        _.each(observables, function(observable) {\u000a                            var script = observable.substring(prefix.length);\u000a                            result[script] = self[observable]();\u000a                        });\u000a                        return result;\u000a                    }\u000a                },\u000a                temperature: {\u000a                    profiles: function() {\u000a                        var result = [];\u000a                        _.each(self.temperature_profiles(), function(profile) {\u000a                            try {\u000a                                result.push({\u000a                                    name: profile.name,\u000a                                    extruder: Math.floor(_.isNumber(profile.extruder) ? profile.extruder : parseInt(profile.extruder)),\u000a                                    bed: Math.floor(_.isNumber(profile.bed) ? profile.bed : parseInt(profile.bed)),\u000a                                    chamber: Math.floor(_.isNumber(profile.chamber) ? profile.chamber : (_.isNumber(parseInt(profile.chamber)) ? parseInt(profile.chamber) : 0))\u000a                                });\u000a                            } catch (ex) {\u000a                                // ignore\u000a                            }\u000a                        });\u000a                        return result;\u000a                    }\u000a                }\u000a            };\u000a\u000a            var mapFromObservables = function(data, mapping, keyPrefix) {\u000a                var flag = false;\u000a                var result = {};\u000a\u000a                // process all key-value-pairs here\u000a                _.forOwn(data, function(value, key) {\u000a                    var observable = key;\u000a                    if (keyPrefix != undefined) {\u000a                        observable = keyPrefix + "_" + observable;\u000a                    }\u000a\u000a                    if (self.observableCopies.hasOwnProperty(observable)) {\u000a                        // only a copy, skip\u000a                        return;\u000a                    }\u000a\u000a                    if (mapping && mapping[key] && _.isFunction(mapping[key])) {\u000a                        result[key] = mapping[key]();\u000a                        flag = true;\u000a                    } else if (_.isPlainObject(value)) {\u000a                        // value is another object, we'll dive deeper\u000a                        var subresult = mapFromObservables(value, (mapping && mapping[key]) ? mapping[key] : undefined, observable);\u000a                        if (subresult != undefined) {\u000a                            // we only set something on our result if we got something back\u000a                            result[key] = subresult;\u000a                            flag = true;\u000a                        }\u000a                    } else if (self.hasOwnProperty(observable)) {\u000a                        result[key] = self[observable]();\u000a                        flag = true;\u000a                    }\u000a                });\u000a\u000a                // if we set something on our result (flag is true), we return result, else we return undefined\u000a                return flag ? result : undefined;\u000a            };\u000a\u000a            // map local observables based on our existing data\u000a            var dataFromObservables = mapFromObservables(data, specialMappings);\u000a\u000a            data = _.extend(data, dataFromObservables);\u000a            return data;\u000a        };\u000a\u000a        self.fromResponse = function(response, local) {\u000a            // server side changes to set\u000a            var serverChangedData;\u000a\u000a            // client side changes to keep\u000a            var clientChangedData;\u000a\u000a            if (local) {\u000a                // local is true, so we'll keep all local changes and only update what's been updated server side\u000a                serverChangedData = getOnlyChangedData(response, self.lastReceivedSettings);\u000a                clientChangedData = getOnlyChangedData(self.getLocalData(), self.lastReceivedSettings);\u000a            } else  {\u000a                // local is false or unset, so we'll forcefully update with the settings from the server\u000a                serverChangedData = response;\u000a                clientChangedData = undefined;\u000a            }\u000a\u000a            // last received settings reset to response\u000a            self.lastReceivedSettings = response;\u000a\u000a            if (self.settings === undefined) {\u000a                self.settings = ko.mapping.fromJS(serverChangedData);\u000a            } else {\u000a                ko.mapping.fromJS(serverChangedData, self.settings);\u000a            }\u000a\u000a            // some special apply functions for various observables\u000a            var specialMappings = {\u000a                appearance: {\u000a                    defaultLanguage: function(value) {\u000a                        self.appearance_defaultLanguage("_default");\u000a                        if (_.includes(self.locale_languages, value)) {\u000a                            self.appearance_defaultLanguage(value);\u000a                        }\u000a                    }\u000a                },\u000a                feature: {\u000a                    autoUppercaseBlacklist: function(value) { self.feature_autoUppercaseBlacklist(value.join(", "))}\u000a                },\u000a                serial: {\u000a                    additionalPorts : function(value) { self.serial_additionalPorts(value.join("\u005cn"))},\u000a                    additionalBaudrates: function(value) { self.serial_additionalBaudrates(value.join(", "))},\u000a                    longRunningCommands: function(value) { self.serial_longRunningCommands(value.join(", "))},\u000a                    checksumRequiringCommands: function(value) { self.serial_checksumRequiringCommands(value.join(", "))},\u000a                    blockedCommands: function(value) { self.serial_blockedCommands(value.join(", "))},\u000a                    pausingCommands: function(value) { self.serial_pausingCommands(value.join(", "))},\u000a                    emergencyCommands: function(value) { self.serial_emergencyCommands(value.join(", "))},\u000a                    externalHeatupDetection: function(value) { self.serial_disableExternalHeatupDetection(!value) },\u000a                    alwaysSendChecksum: function(value) { if (value) { self.serial_sendChecksum("always")}},\u000a                    neverSendChecksum: function(value) { if (value) { self.serial_sendChecksum("never")}},\u000a                    ignoreErrorsFromFirmware: function(value) { if (value) {self.serial_serialErrorBehaviour("ignore")}},\u000a                    disconnectOnErrors: function(value) { if (value) {self.serial_serialErrorBehaviour("disconnect")}}\u000a                },\u000a                terminalFilters: function(value) { self.terminalFilters($.extend(true, [], value)) },\u000a                temperature: {\u000a                    profiles: function(value) { self.temperature_profiles($.extend(true, [], value)); }\u000a                }\u000a            };\u000a\u000a            var mapToObservables = function(data, mapping, local, keyPrefix) {\u000a                if (!_.isPlainObject(data)) {\u000a                    return;\u000a                }\u000a\u000a                // process all key-value-pairs here\u000a                _.forOwn(data, function(value, key) {\u000a                    var observable = key;\u000a                    if (keyPrefix != undefined) {\u000a                        observable = keyPrefix + "_" + observable;\u000a                    }\u000a\u000a                    if (self.observableCopies.hasOwnProperty(observable)) {\u000a                        // only a copy, skip\u000a                        return;\u000a                    }\u000a\u000a                    var haveLocalVersion = local && local.hasOwnProperty(key);\u000a\u000a                    if (mapping && mapping[key] && _.isFunction(mapping[key]) && !haveLocalVersion) {\u000a                        // if we have a custom apply function for this, we'll use it\u000a                        mapping[key](value);\u000a                    } else if (_.isPlainObject(value)) {\u000a                        // value is another object, we'll dive deeper\u000a                        mapToObservables(value, (mapping && mapping[key]) ? mapping[key] : undefined, (local && local[key]) ? local[key] : undefined, observable);\u000a                    } else if (!haveLocalVersion && self.hasOwnProperty(observable)) {\u000a                        // if we have a matching observable, we'll use that\u000a                        self[observable](value);\u000a                    }\u000a                });\u000a            };\u000a\u000a            mapToObservables(serverChangedData, specialMappings, clientChangedData);\u000a\u000a            firstRequest.resolve();\u000a        };\u000a\u000a        self.cancelData = function () {\u000a            // revert unsaved changes\u000a            self.fromResponse(self.lastReceivedSettings);\u000a\u000a            self.hide();\u000a        }\u000a\u000a        self.saveData = function (data, successCallback, setAsSending) {\u000a            var options;\u000a            if (_.isPlainObject(successCallback)) {\u000a                options = successCallback;\u000a            } else {\u000a                options = {\u000a                    success: successCallback,\u000a                    sending: (setAsSending == true)\u000a                }\u000a            }\u000a\u000a            self.settingsDialog.trigger("beforeSave");\u000a\u000a            self.sawUpdateEventWhileSending = false;\u000a            self.sending(data == undefined || options.sending || false);\u000a\u000a            if (data == undefined) {\u000a                // we also only send data that actually changed when no data is specified\u000a                data = getOnlyChangedData(self.getLocalData(), self.lastReceivedSettings);\u000a            }\u000a\u000a            self.active = true;\u000a            return OctoPrint.settings.save(data)\u000a                .done(function(data, status, xhr) {\u000a                    self.ignoreNextUpdateEvent = !self.sawUpdateEventWhileSending;\u000a                    self.active = false;\u000a\u000a                    self.receiving(true);\u000a                    self.sending(false);\u000a\u000a                    try {\u000a                        self.fromResponse(data);\u000a                        if (options.success) options.success(data, status, xhr);\u000a                    } finally {\u000a                        self.receiving(false);\u000a                    }\u000a                })\u000a                .fail(function(xhr, status, error) {\u000a                    self.sending(false);\u000a                    self.active = false;\u000a                    if (options.error) options.error(xhr, status, error);\u000a                })\u000a                .always(function(xhr, status) {\u000a                    if (options.complete) options.complete(xhr, status);\u000a                });\u000a        };\u000a\u000a        self.onEventSettingsUpdated = function() {\u000a            if (self.active) {\u000a                self.sawUpdateEventWhileActive = true;\u000a            }\u000a\u000a            var preventSettingsRefresh = _.any(self.allViewModels, function(viewModel) {\u000a                if (viewModel.hasOwnProperty("onSettingsPreventRefresh")) {\u000a                    try {\u000a                        return viewModel["onSettingsPreventRefresh"]();\u000a                    } catch (e) {\u000a                        log.warn("Error while calling onSettingsPreventRefresh on", viewModel, ":", e);\u000a                        return false;\u000a                    }\u000a                } else {\u000a                    return false;\u000a                }\u000a            });\u000a\u000a            if (preventSettingsRefresh) {\u000a                // if any of our viewmodels prevented this refresh, we'll just return now\u000a                return;\u000a            }\u000a\u000a            if (self.isDialogActive()) {\u000a                // dialog is open and not currently busy...\u000a                if (self.sending() || self.receiving() || self.active || self.ignoreNextUpdateEvent) {\u000a                    self.ignoreNextUpdateEvent = false;\u000a                    return;\u000a                }\u000a\u000a                if (!hasDataChanged(self.getLocalData(), self.lastReceivedSettings)) {\u000a                    // we don't have local changes, so just fetch new data\u000a                    self.requestData();\u000a                } else {\u000a                    // we have local changes, show update dialog\u000a                    self.settingsUpdatedDialog.modal("show");\u000a                }\u000a            } else {\u000a                // dialog is not open, just fetch new data\u000a                self.requestData();\u000a            }\u000a        };\u000a\u000a        self._resetScrollPosition = function() {\u000a            $('#settings_dialog_content', self.settingsDialog).scrollTop(0);\u000a\u000a            // also reset any contained tabs/pills/lists to first pane\u000a            $('#settings_dialog_content ul.nav-pills a[data-toggle="tab"]:first', self.settingsDialog).tab("show");\u000a            $('#settings_dialog_content ul.nav-list a[data-toggle="tab"]:first', self.settingsDialog).tab("show");\u000a            $('#settings_dialog_content ul.nav-tabs a[data-toggle="tab"]:first', self.settingsDialog).tab("show");\u000a        };\u000a\u000a        self.selectTab = function(tab) {\u000a            if (tab != undefined) {\u000a                if (!_.startsWith(tab, "#")) {\u000a                    tab = "#" + tab;\u000a                }\u000a                $('ul.nav-list a[href="' + tab + '"]', self.settingsDialog).tab("show");\u000a            } else {\u000a                $('ul.nav-list a[data-toggle="tab"]:first', self.settingsDialog).tab("show");\u000a            }\u000a        };\u000a\u000a        self.onServerReconnect = function() {\u000a            // the settings might have changed if the server was just restarted,\u000a            // better refresh them now\u000a            self.requestData();\u000a        };\u000a\u000a        self.onUserLoggedIn = function() {\u000a            // we might have other user rights now, refresh (but only if startup has fully completed)\u000a            if (!self._startupComplete) return;\u000a            self.requestData();\u000a        };\u000a\u000a        self.onUserLoggedOut = function() {\u000a            // we might have other user rights now, refresh (but only if startup has fully completed)\u000a            if (!self._startupComplete) return;\u000a            self.requestData();\u000a        }\u000a    }\u000a\u000a    OCTOPRINT_VIEWMODELS.push({\u000a        construct: SettingsViewModel,\u000a        dependencies: ["loginStateViewModel", "usersViewModel", "printerProfilesViewModel", "aboutViewModel"],\u000a        elements: ["#settings_dialog", "#navbar_settings"]\u000a    });\u000a});\u000a\u000a;\u000a
p0
.