V// source: js/lib/jquery/jquery.ui.widget.js\u000a/*\u000a * jQuery UI Widget 1.9.1+amd\u000a * https://github.com/blueimp/jQuery-File-Upload\u000a *\u000a * Copyright 2012 jQuery Foundation and other contributors\u000a * Released under the MIT license.\u000a * http://jquery.org/license\u000a *\u000a * http://api.jqueryui.com/jQuery.widget/\u000a */\u000a\u000a(function (factory) {\u000a    if (typeof define === "function" && define.amd) {\u000a        // Register as an anonymous AMD module:\u000a        define(["jquery"], factory);\u000a    } else {\u000a        // Browser globals:\u000a        factory(jQuery);\u000a    }\u000a}(function( $, undefined ) {\u000a\u000avar uuid = 0,\u000a	slice = Array.prototype.slice,\u000a	_cleanData = $.cleanData;\u000a$.cleanData = function( elems ) {\u000a	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\u000a		try {\u000a			$( elem ).triggerHandler( "remove" );\u000a		// http://bugs.jquery.com/ticket/8235\u000a		} catch( e ) {}\u000a	}\u000a	_cleanData( elems );\u000a};\u000a\u000a$.widget = function( name, base, prototype ) {\u000a	var fullName, existingConstructor, constructor, basePrototype,\u000a		namespace = name.split( "." )[ 0 ];\u000a\u000a	name = name.split( "." )[ 1 ];\u000a	fullName = namespace + "-" + name;\u000a\u000a	if ( !prototype ) {\u000a		prototype = base;\u000a		base = $.Widget;\u000a	}\u000a\u000a	// create selector for plugin\u000a	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {\u000a		return !!$.data( elem, fullName );\u000a	};\u000a\u000a	$[ namespace ] = $[ namespace ] || {};\u000a	existingConstructor = $[ namespace ][ name ];\u000a	constructor = $[ namespace ][ name ] = function( options, element ) {\u000a		// allow instantiation without "new" keyword\u000a		if ( !this._createWidget ) {\u000a			return new constructor( options, element );\u000a		}\u000a\u000a		// allow instantiation without initializing for simple inheritance\u000a		// must use "new" keyword (the code above always passes args)\u000a		if ( arguments.length ) {\u000a			this._createWidget( options, element );\u000a		}\u000a	};\u000a	// extend with the existing constructor to carry over any static properties\u000a	$.extend( constructor, existingConstructor, {\u000a		version: prototype.version,\u000a		// copy the object used to create the prototype in case we need to\u000a		// redefine the widget later\u000a		_proto: $.extend( {}, prototype ),\u000a		// track widgets that inherit from this widget in case this widget is\u000a		// redefined after a widget inherits from it\u000a		_childConstructors: []\u000a	});\u000a\u000a	basePrototype = new base();\u000a	// we need to make the options hash a property directly on the new instance\u000a	// otherwise we'll modify the options hash on the prototype that we're\u000a	// inheriting from\u000a	basePrototype.options = $.widget.extend( {}, basePrototype.options );\u000a	$.each( prototype, function( prop, value ) {\u000a		if ( $.isFunction( value ) ) {\u000a			prototype[ prop ] = (function() {\u000a				var _super = function() {\u000a						return base.prototype[ prop ].apply( this, arguments );\u000a					},\u000a					_superApply = function( args ) {\u000a						return base.prototype[ prop ].apply( this, args );\u000a					};\u000a				return function() {\u000a					var __super = this._super,\u000a						__superApply = this._superApply,\u000a						returnValue;\u000a\u000a					this._super = _super;\u000a					this._superApply = _superApply;\u000a\u000a					returnValue = value.apply( this, arguments );\u000a\u000a					this._super = __super;\u000a					this._superApply = __superApply;\u000a\u000a					return returnValue;\u000a				};\u000a			})();\u000a		}\u000a	});\u000a	constructor.prototype = $.widget.extend( basePrototype, {\u000a		// TODO: remove support for widgetEventPrefix\u000a		// always use the name + a colon as the prefix, e.g., draggable:start\u000a		// don't prefix for widgets that aren't DOM-based\u000a		widgetEventPrefix: basePrototype.widgetEventPrefix || name\u000a	}, prototype, {\u000a		constructor: constructor,\u000a		namespace: namespace,\u000a		widgetName: name,\u000a		// TODO remove widgetBaseClass, see #8155\u000a		widgetBaseClass: fullName,\u000a		widgetFullName: fullName\u000a	});\u000a\u000a	// If this widget is being redefined then we need to find all widgets that\u000a	// are inheriting from it and redefine all of them so that they inherit from\u000a	// the new version of this widget. We're essentially trying to replace one\u000a	// level in the prototype chain.\u000a	if ( existingConstructor ) {\u000a		$.each( existingConstructor._childConstructors, function( i, child ) {\u000a			var childPrototype = child.prototype;\u000a\u000a			// redefine the child widget using the same prototype that was\u000a			// originally used, but inherit from the new version of the base\u000a			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );\u000a		});\u000a		// remove the list of existing child constructors from the old constructor\u000a		// so the old child constructors can be garbage collected\u000a		delete existingConstructor._childConstructors;\u000a	} else {\u000a		base._childConstructors.push( constructor );\u000a	}\u000a\u000a	$.widget.bridge( name, constructor );\u000a};\u000a\u000a$.widget.extend = function( target ) {\u000a	var input = slice.call( arguments, 1 ),\u000a		inputIndex = 0,\u000a		inputLength = input.length,\u000a		key,\u000a		value;\u000a	for ( ; inputIndex < inputLength; inputIndex++ ) {\u000a		for ( key in input[ inputIndex ] ) {\u000a			value = input[ inputIndex ][ key ];\u000a			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\u000a				// Clone objects\u000a				if ( $.isPlainObject( value ) ) {\u000a					target[ key ] = $.isPlainObject( target[ key ] ) ?\u000a						$.widget.extend( {}, target[ key ], value ) :\u000a						// Don't extend strings, arrays, etc. with objects\u000a						$.widget.extend( {}, value );\u000a				// Copy everything else by reference\u000a				} else {\u000a					target[ key ] = value;\u000a				}\u000a			}\u000a		}\u000a	}\u000a	return target;\u000a};\u000a\u000a$.widget.bridge = function( name, object ) {\u000a	var fullName = object.prototype.widgetFullName;\u000a	$.fn[ name ] = function( options ) {\u000a		var isMethodCall = typeof options === "string",\u000a			args = slice.call( arguments, 1 ),\u000a			returnValue = this;\u000a\u000a		// allow multiple hashes to be passed on init\u000a		options = !isMethodCall && args.length ?\u000a			$.widget.extend.apply( null, [ options ].concat(args) ) :\u000a			options;\u000a\u000a		if ( isMethodCall ) {\u000a			this.each(function() {\u000a				var methodValue,\u000a					instance = $.data( this, fullName );\u000a				if ( !instance ) {\u000a					return $.error( "cannot call methods on " + name + " prior to initialization; " +\u000a						"attempted to call method '" + options + "'" );\u000a				}\u000a				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {\u000a					return $.error( "no such method '" + options + "' for " + name + " widget instance" );\u000a				}\u000a				methodValue = instance[ options ].apply( instance, args );\u000a				if ( methodValue !== instance && methodValue !== undefined ) {\u000a					returnValue = methodValue && methodValue.jquery ?\u000a						returnValue.pushStack( methodValue.get() ) :\u000a						methodValue;\u000a					return false;\u000a				}\u000a			});\u000a		} else {\u000a			this.each(function() {\u000a				var instance = $.data( this, fullName );\u000a				if ( instance ) {\u000a					instance.option( options || {} )._init();\u000a				} else {\u000a					new object( options, this );\u000a				}\u000a			});\u000a		}\u000a\u000a		return returnValue;\u000a	};\u000a};\u000a\u000a$.Widget = function( /* options, element */ ) {};\u000a$.Widget._childConstructors = [];\u000a\u000a$.Widget.prototype = {\u000a	widgetName: "widget",\u000a	widgetEventPrefix: "",\u000a	defaultElement: "<div>",\u000a	options: {\u000a		disabled: false,\u000a\u000a		// callbacks\u000a		create: null\u000a	},\u000a	_createWidget: function( options, element ) {\u000a		element = $( element || this.defaultElement || this )[ 0 ];\u000a		this.element = $( element );\u000a		this.uuid = uuid++;\u000a		this.eventNamespace = "." + this.widgetName + this.uuid;\u000a		this.options = $.widget.extend( {},\u000a			this.options,\u000a			this._getCreateOptions(),\u000a			options );\u000a\u000a		this.bindings = $();\u000a		this.hoverable = $();\u000a		this.focusable = $();\u000a\u000a		if ( element !== this ) {\u000a			// 1.9 BC for #7810\u000a			// TODO remove dual storage\u000a			$.data( element, this.widgetName, this );\u000a			$.data( element, this.widgetFullName, this );\u000a			this._on( this.element, {\u000a				remove: function( event ) {\u000a					if ( event.target === element ) {\u000a						this.destroy();\u000a					}\u000a				}\u000a			});\u000a			this.document = $( element.style ?\u000a				// element within the document\u000a				element.ownerDocument :\u000a				// element is window or document\u000a				element.document || element );\u000a			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );\u000a		}\u000a\u000a		this._create();\u000a		this._trigger( "create", null, this._getCreateEventData() );\u000a		this._init();\u000a	},\u000a	_getCreateOptions: $.noop,\u000a	_getCreateEventData: $.noop,\u000a	_create: $.noop,\u000a	_init: $.noop,\u000a\u000a	destroy: function() {\u000a		this._destroy();\u000a		// we can probably remove the unbind calls in 2.0\u000a		// all event bindings should go through this._on()\u000a		this.element\u000a			.unbind( this.eventNamespace )\u000a			// 1.9 BC for #7810\u000a			// TODO remove dual storage\u000a			.removeData( this.widgetName )\u000a			.removeData( this.widgetFullName )\u000a			// support: jquery <1.6.3\u000a			// http://bugs.jquery.com/ticket/9413\u000a			.removeData( $.camelCase( this.widgetFullName ) );\u000a		this.widget()\u000a			.unbind( this.eventNamespace )\u000a			.removeAttr( "aria-disabled" )\u000a			.removeClass(\u000a				this.widgetFullName + "-disabled " +\u000a				"ui-state-disabled" );\u000a\u000a		// clean up events and states\u000a		this.bindings.unbind( this.eventNamespace );\u000a		this.hoverable.removeClass( "ui-state-hover" );\u000a		this.focusable.removeClass( "ui-state-focus" );\u000a	},\u000a	_destroy: $.noop,\u000a\u000a	widget: function() {\u000a		return this.element;\u000a	},\u000a\u000a	option: function( key, value ) {\u000a		var options = key,\u000a			parts,\u000a			curOption,\u000a			i;\u000a\u000a		if ( arguments.length === 0 ) {\u000a			// don't return a reference to the internal hash\u000a			return $.widget.extend( {}, this.options );\u000a		}\u000a\u000a		if ( typeof key === "string" ) {\u000a			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }\u000a			options = {};\u000a			parts = key.split( "." );\u000a			key = parts.shift();\u000a			if ( parts.length ) {\u000a				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\u000a				for ( i = 0; i < parts.length - 1; i++ ) {\u000a					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\u000a					curOption = curOption[ parts[ i ] ];\u000a				}\u000a				key = parts.pop();\u000a				if ( value === undefined ) {\u000a					return curOption[ key ] === undefined ? null : curOption[ key ];\u000a				}\u000a				curOption[ key ] = value;\u000a			} else {\u000a				if ( value === undefined ) {\u000a					return this.options[ key ] === undefined ? null : this.options[ key ];\u000a				}\u000a				options[ key ] = value;\u000a			}\u000a		}\u000a\u000a		this._setOptions( options );\u000a\u000a		return this;\u000a	},\u000a	_setOptions: function( options ) {\u000a		var key;\u000a\u000a		for ( key in options ) {\u000a			this._setOption( key, options[ key ] );\u000a		}\u000a\u000a		return this;\u000a	},\u000a	_setOption: function( key, value ) {\u000a		this.options[ key ] = value;\u000a\u000a		if ( key === "disabled" ) {\u000a			this.widget()\u000a				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )\u000a				.attr( "aria-disabled", value );\u000a			this.hoverable.removeClass( "ui-state-hover" );\u000a			this.focusable.removeClass( "ui-state-focus" );\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	enable: function() {\u000a		return this._setOption( "disabled", false );\u000a	},\u000a	disable: function() {\u000a		return this._setOption( "disabled", true );\u000a	},\u000a\u000a	_on: function( element, handlers ) {\u000a		var delegateElement,\u000a			instance = this;\u000a		// no element argument, shuffle and use this.element\u000a		if ( !handlers ) {\u000a			handlers = element;\u000a			element = this.element;\u000a			delegateElement = this.widget();\u000a		} else {\u000a			// accept selectors, DOM elements\u000a			element = delegateElement = $( element );\u000a			this.bindings = this.bindings.add( element );\u000a		}\u000a\u000a		$.each( handlers, function( event, handler ) {\u000a			function handlerProxy() {\u000a				// allow widgets to customize the disabled handling\u000a				// - disabled as an array instead of boolean\u000a				// - disabled class as method for disabling individual parts\u000a				if ( instance.options.disabled === true ||\u000a						$( this ).hasClass( "ui-state-disabled" ) ) {\u000a					return;\u000a				}\u000a				return ( typeof handler === "string" ? instance[ handler ] : handler )\u000a					.apply( instance, arguments );\u000a			}\u000a\u000a			// copy the guid so direct unbinding works\u000a			if ( typeof handler !== "string" ) {\u000a				handlerProxy.guid = handler.guid =\u000a					handler.guid || handlerProxy.guid || $.guid++;\u000a			}\u000a\u000a			var match = event.match( /^(\u005cw+)\u005cs*(.*)$/ ),\u000a				eventName = match[1] + instance.eventNamespace,\u000a				selector = match[2];\u000a			if ( selector ) {\u000a				delegateElement.delegate( selector, eventName, handlerProxy );\u000a			} else {\u000a				element.bind( eventName, handlerProxy );\u000a			}\u000a		});\u000a	},\u000a\u000a	_off: function( element, eventName ) {\u000a		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;\u000a		element.unbind( eventName ).undelegate( eventName );\u000a	},\u000a\u000a	_delay: function( handler, delay ) {\u000a		function handlerProxy() {\u000a			return ( typeof handler === "string" ? instance[ handler ] : handler )\u000a				.apply( instance, arguments );\u000a		}\u000a		var instance = this;\u000a		return setTimeout( handlerProxy, delay || 0 );\u000a	},\u000a\u000a	_hoverable: function( element ) {\u000a		this.hoverable = this.hoverable.add( element );\u000a		this._on( element, {\u000a			mouseenter: function( event ) {\u000a				$( event.currentTarget ).addClass( "ui-state-hover" );\u000a			},\u000a			mouseleave: function( event ) {\u000a				$( event.currentTarget ).removeClass( "ui-state-hover" );\u000a			}\u000a		});\u000a	},\u000a\u000a	_focusable: function( element ) {\u000a		this.focusable = this.focusable.add( element );\u000a		this._on( element, {\u000a			focusin: function( event ) {\u000a				$( event.currentTarget ).addClass( "ui-state-focus" );\u000a			},\u000a			focusout: function( event ) {\u000a				$( event.currentTarget ).removeClass( "ui-state-focus" );\u000a			}\u000a		});\u000a	},\u000a\u000a	_trigger: function( type, event, data ) {\u000a		var prop, orig,\u000a			callback = this.options[ type ];\u000a\u000a		data = data || {};\u000a		event = $.Event( event );\u000a		event.type = ( type === this.widgetEventPrefix ?\u000a			type :\u000a			this.widgetEventPrefix + type ).toLowerCase();\u000a		// the original event may come from any element\u000a		// so we need to reset the target on the new event\u000a		event.target = this.element[ 0 ];\u000a\u000a		// copy original event properties over to the new event\u000a		orig = event.originalEvent;\u000a		if ( orig ) {\u000a			for ( prop in orig ) {\u000a				if ( !( prop in event ) ) {\u000a					event[ prop ] = orig[ prop ];\u000a				}\u000a			}\u000a		}\u000a\u000a		this.element.trigger( event, data );\u000a		return !( $.isFunction( callback ) &&\u000a			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||\u000a			event.isDefaultPrevented() );\u000a	}\u000a};\u000a\u000a$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {\u000a	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {\u000a		if ( typeof options === "string" ) {\u000a			options = { effect: options };\u000a		}\u000a		var hasOptions,\u000a			effectName = !options ?\u000a				method :\u000a				options === true || typeof options === "number" ?\u000a					defaultEffect :\u000a					options.effect || defaultEffect;\u000a		options = options || {};\u000a		if ( typeof options === "number" ) {\u000a			options = { duration: options };\u000a		}\u000a		hasOptions = !$.isEmptyObject( options );\u000a		options.complete = callback;\u000a		if ( options.delay ) {\u000a			element.delay( options.delay );\u000a		}\u000a		if ( hasOptions && $.effects && ( $.effects.effect[ effectName ] || $.uiBackCompat !== false && $.effects[ effectName ] ) ) {\u000a			element[ method ]( options );\u000a		} else if ( effectName !== method && element[ effectName ] ) {\u000a			element[ effectName ]( options.duration, options.easing, callback );\u000a		} else {\u000a			element.queue(function( next ) {\u000a				$( this )[ method ]();\u000a				if ( callback ) {\u000a					callback.call( element[ 0 ] );\u000a				}\u000a				next();\u000a			});\u000a		}\u000a	};\u000a});\u000a\u000a// DEPRECATED\u000aif ( $.uiBackCompat !== false ) {\u000a	$.Widget.prototype._getCreateOptions = function() {\u000a		return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];\u000a	};\u000a}\u000a\u000a}));\u000a\u000a;\u000a
p0
.